-- Generated by Haxe 4.3.1
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                local str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            local buffer = {}
            local ref = obj
            if obj.__fields__ ~= nil then
                ref = obj.__fields__
            end
            for k,v in pairs(ref) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end

            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    local res = {}
    local idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local _hx_exports = _hx_exports or {}
local Array = _hx_e()
local Date = _hx_e()
local DateTools = _hx_e()
__lua_lib_lrexlib_Rex = _G.require("rex_pcre2")
__lua_lib_luautf8_Utf8 = _G.require("lua-utf8")
local EReg = _hx_e()
local Lambda = _hx_e()
local Main = _hx_e()
local API = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
__config_DiffConfig = _hx_e()
__diff_comparison_ByCharRt = _hx_e()
__diff_comparison_CodePointsOffsets = _hx_e()
__diff_comparison_ByLineRt = _hx_e()
__diff_comparison_Line = _hx_e()
__diff_comparison_BuilderRunner = _hx_e()
__diff_comparison_AlignmentRunner = _hx_e()
__diff_comparison_ByWordRt = _hx_e()
__util_Hashable = _hx_e()
__util_Equals = _hx_e()
__diff_comparison_InlineChunk = _hx_e()
__diff_comparison_WordChunk = _hx_e()
__diff_comparison_NewlineChunk = _hx_e()
__diff_comparison_LineBlock = _hx_e()
__diff_comparison_DefaultCorrector = _hx_e()
__diff_comparison_MergeDefaultCorrector = _hx_e()
__diff_comparison_IgnoreSpacesCorrector = _hx_e()
__diff_comparison_MergeIgnoreSpacesCorrector = _hx_e()
__diff_comparison_TrimSpacesCorrector = _hx_e()
__diff_comparison_MergeTrimSpacesCorrector = _hx_e()
__diff_comparison_AdjustmentPunctuationMatcher = _hx_e()
__diff_comparison__ByWordRt_ByWordRt_Fields_ = _hx_e()
__diff_comparison_ChangeCorrector = _hx_e()
__diff_comparison_DefaultCharChangeCorrector = _hx_e()
__diff_comparison_SmartLineChangeCorrector = _hx_e()
__diff_comparison_ChunkOptimizer = _hx_e()
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic = _hx_e()
__diff_comparison_WordChunkOptimizer = _hx_e()
__diff_comparison_ChunkOptimizer_diff_comparison_Line = _hx_e()
__diff_comparison_LineChunkOptimizer = _hx_e()
__diff_comparison_SideEquality = _hx_e()
__diff_comparison_ComparisonMergeUtil = _hx_e()
__diff_comparison_FairMergeBuilder = _hx_e()
__diff_comparison_ChangeBuilder = _hx_e()
__diff_comparison_IgnoringChangeBuilder = _hx_e()
__diff_comparison_ComparisonPolicy = _hx_e()
__diff_comparison_ComparisonUtil = _hx_e()
__diff_comparison__ComparisonUtil_ComparisonUtil_Fields_ = _hx_e()
__haxe_Exception = _hx_e()
__diff_comparison_DiffTooBigException = _hx_e()
__diff_comparison_LineFragmentSplitter = _hx_e()
__diff_comparison_WordBlock = _hx_e()
__diff_comparison_PendingChunk = _hx_e()
__diff_comparison_MergeResolveUtil = _hx_e()
__diff_comparison_SimpleHelper = _hx_e()
__diff_comparison_GreedyHelper = _hx_e()
__diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_ = _hx_e()
__diff_comparison_TrimUtil = _hx_e()
__diff_comparison_iterables_ChangeIterable = _hx_e()
__diff_comparison_iterables_DiffIterable = _hx_e()
__diff_comparison_iterables_ChangeDiffIterableBase = _hx_e()
__diff_comparison_iterables_ChangedIterator = _hx_e()
__diff_comparison_iterables_UnchangedIterator = _hx_e()
__diff_comparison_iterables_DiffChangeDiffIterable = _hx_e()
__diff_comparison_iterables_DiffChangeChangeIterable = _hx_e()
__diff_comparison_iterables_DiffFragmentsDiffIterable = _hx_e()
__diff_comparison_iterables_FragmentsChangeIterable = _hx_e()
__diff_comparison_iterables_GenericIterable = _hx_e()
__diff_comparison_iterables_DiffIterableUtil = _hx_e()
__diff_comparison_iterables_ChangeBuilderBase = _hx_e()
__diff_comparison_iterables_ChangeBuilder = _hx_e()
__diff_comparison_iterables_ExpandChangeBuilder = _hx_e()
__diff_comparison_iterables_LineRangeData = _hx_e()
__diff_comparison_iterables_IterateAllIterator = _hx_e()
__diff_comparison_iterables_ExpandedDiffIterable = _hx_e()
__diff_comparison_iterables_ShiftedChangeIterable = _hx_e()
__diff_comparison_iterables_FairDiffIterable = _hx_e()
__diff_comparison_iterables_FairDiffIterableWrapper = _hx_e()
__diff_comparison_iterables_GenericIterable_diff_util_Range = _hx_e()
__diff_comparison_iterables_InvertedDiffIterableWrapper = _hx_e()
__diff_comparison_iterables_RangesDiffIterable = _hx_e()
__diff_comparison_iterables_RangesChangeIterable = _hx_e()
__diff_comparison_iterables_SubiterableDiffIterable = _hx_e()
__diff_comparison_iterables_SubiterableChangeIterable = _hx_e()
__diff_fragments_DiffFragment = _hx_e()
__diff_fragments_DiffFragmentImpl = _hx_e()
__diff_fragments_LineFragment = _hx_e()
__diff_fragments_MergeLineFragment = _hx_e()
__diff_fragments_MergeWordFragment = _hx_e()
__diff_tools_util_text_LineOffsets = _hx_e()
__diff_util_DiffRangeUtil = _hx_e()
__diff_util_MergeConflictTypeEnum = _hx_e()
__diff_util_MergeConflictType = _hx_e()
__diff_util_MergeRange = _hx_e()
__diff_util_MergeRangeUtil = _hx_e()
__diff_util_Range = _hx_e()
__diff_util_SideEnum = _hx_e()
__diff_util_Side = _hx_e()
__diff_util_ThreeSideEnum = _hx_e()
__diff_util_ThreeSide = _hx_e()
__ds_BiPredicate = _hx_e()
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum = _hx_e()
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide = _hx_e()
__ds_BooleanSupplier = _hx_e()
__ds_Couple = _hx_e()
__ds_Enumerator = _hx_e()
__ds_Enumerator_util_HashableType = _hx_e()
__ds__MergingCharSequence_MergingCharSequence_Impl_ = _hx_e()
__ds_Pair = _hx_e()
__ds_NonNull = _hx_e()
__ds_Predicate = _hx_e()
__ds_Predicate_diff_util_ThreeSide = _hx_e()
__ds_Predicate_diff_util_ThreeSideEnum = _hx_e()
__ds_Ref = _hx_e()
__ds__Ref_Ref_Fields_ = _hx_e()
__ds_Ref_util_diff_Change = _hx_e()
__ds_TextRange = _hx_e()
__exceptions_IllegalArgumentException = _hx_e()
__exceptions_IllegalStateException = _hx_e()
__exceptions_IndexOutOfBoundsException = _hx_e()
__exceptions_NoSuchElementException = _hx_e()
__exceptions_UnsupportedOperationException = _hx_e()
__haxe_StackItem = _hx_e()
__haxe__CallStack_CallStack_Impl_ = _hx_e()
__haxe_IMap = _hx_e()
__haxe__Int32_Int32_Impl_ = _hx_e()
__haxe_Log = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_crypto_Base64 = _hx_e()
__haxe_ds_BalancedTree = _hx_e()
__haxe_ds_TreeNode = _hx_e()
__haxe_ds_EnumValueMap = _hx_e()
__haxe_ds_IntMap = _hx_e()
__haxe_ds_ObjectMap = _hx_e()
__haxe_ds_Option = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_ds__Vector_Vector_Impl_ = _hx_e()
__haxe_exceptions_PosException = _hx_e()
__haxe_exceptions_NotImplementedException = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__iterators_PeekableIterator = _hx_e()
__iterators_PeekableIteratorWrapper = _hx_e()
__iterators_StepIterator = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Lib = _hx_e()
__lua_Thread = _hx_e()
__thx_Arrays = _hx_e()
__thx_ArrayFloats = _hx_e()
__thx_ArrayInts = _hx_e()
__thx_ArrayStrings = _hx_e()
__thx__BitSet_BitSet_Impl_ = _hx_e()
__thx_Bools = _hx_e()
__thx__Ord_Ord_Impl_ = _hx_e()
__thx__Ord_Ordering_Impl_ = _hx_e()
__thx_OrderingImpl = _hx_e()
__thx_Dates = _hx_e()
__thx_Dynamics = _hx_e()
__thx_DynamicsT = _hx_e()
__thx_Either = _hx_e()
__thx_Eithers = _hx_e()
__thx__Eithers_EitherK_Impl_ = _hx_e()
__thx_Enums = _hx_e()
__thx_Error = _hx_e()
__thx_Floats = _hx_e()
__thx_Functions0 = _hx_e()
__thx_Functions1 = _hx_e()
__thx_Functions2 = _hx_e()
__thx_Functions3 = _hx_e()
__thx_Functions4 = _hx_e()
__thx_Functions5 = _hx_e()
__thx_Functions6 = _hx_e()
__thx_Functions7 = _hx_e()
__thx_Functions8 = _hx_e()
__thx_Functions9 = _hx_e()
__thx_Functions10 = _hx_e()
__thx_Functions11 = _hx_e()
__thx_Functions12 = _hx_e()
__thx_Functions13 = _hx_e()
__thx_Functions14 = _hx_e()
__thx_Functions15 = _hx_e()
__thx_Functions16 = _hx_e()
__thx_Functions17 = _hx_e()
__thx_Functions18 = _hx_e()
__thx_Functions19 = _hx_e()
__thx_Functions20 = _hx_e()
__thx__Functions_Reader_Impl_ = _hx_e()
__thx_Functions = _hx_e()
__thx_Ints = _hx_e()
__thx_RangeIterator = _hx_e()
__thx_Iterables = _hx_e()
__thx_Iterators = _hx_e()
__thx_MapIterator = _hx_e()
__thx_MapIIterator = _hx_e()
__thx_Maps = _hx_e()
__thx__Monoid_Monoid_Impl_ = _hx_e()
__thx__Nel_Nel_Impl_ = _hx_e()
__thx_NonEmptyList = _hx_e()
__thx_Nil = _hx_e()
__thx_Objects = _hx_e()
__thx_Options = _hx_e()
__thx_Orderings = _hx_e()
__thx__ReadonlyArray_ReadonlyArray_Impl_ = _hx_e()
__thx__Semigroup_Semigroup_Impl_ = _hx_e()
__thx__Set_Set_Impl_ = _hx_e()
__thx_Strings = _hx_e()
__thx_TimePeriod = _hx_e()
__thx__Timestamp_Timestamp_Impl_ = _hx_e()
__thx__Tuple_Tuple0_Impl_ = _hx_e()
__thx__Tuple_Tuple1_Impl_ = _hx_e()
__thx__Tuple_Tuple2_Impl_ = _hx_e()
__thx__Tuple_Tuple3_Impl_ = _hx_e()
__thx__Tuple_Tuple4_Impl_ = _hx_e()
__thx__Tuple_Tuple5_Impl_ = _hx_e()
__thx__Tuple_Tuple6_Impl_ = _hx_e()
__thx_Types = _hx_e()
__thx__Validation_Validation_Impl_ = _hx_e()
__thx_ValidationExtensions = _hx_e()
__thx_error_ErrorWrapper = _hx_e()
__thx_fp__Map_Map_Impl_ = _hx_e()
__thx_fp_MapImpl = _hx_e()
__tokenizers_LineTokenizer = _hx_e()
__util__HashableString_HashableStringArray_Impl_ = _hx_e()
__util__HashableString_HashableString_Impl_ = _hx_e()
__util_SafeBitSetAt = _hx_e()
__util_diff_Diff = _hx_e()
__util_diff_Change = _hx_e()
__util_diff_LCSBuilder = _hx_e()
__util_diff_ChangeBuilder = _hx_e()
__util_diff_FilesTooBigForDiffException = _hx_e()
__util_diff_MyersLCS = _hx_e()
__util_diff_PatienceIntLCS = _hx_e()
__util_diff_Reindexer = _hx_e()
__util_diff__Reindexer_Reindexer_Fields_ = _hx_e()
__util_diff_UniqueLCS = _hx_e()
__util_diff__UniqueLCS_UniqueLCS_Fields_ = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = "Array"
Array.prototype = _hx_e();
Array.prototype.length= nil;
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do _hx_do_first_1 = false;
    
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    _G.table.insert(tbl, Std.string(i));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do _hx_do_first_1 = false;
    
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do _hx_do_first_1 = false;
    
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do _hx_do_first_2 = false;
      
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do _hx_do_first_2 = false;
        
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do _hx_do_first_1 = false;
    
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t", self.t);
  self.dUTC = _G.os.date("!*t", self.t);
end
Date.__name__ = "Date"
Date.prototype = _hx_e();
Date.prototype.d= nil;
Date.prototype.dUTC= nil;
Date.prototype.t= nil;
Date.prototype.getTime = function(self) 
  do return self.t * 1000 end
end
Date.prototype.getHours = function(self) 
  do return self.d.hour end
end
Date.prototype.getMinutes = function(self) 
  do return self.d.min end
end
Date.prototype.getSeconds = function(self) 
  do return self.d.sec end
end
Date.prototype.getFullYear = function(self) 
  do return self.d.year end
end
Date.prototype.getMonth = function(self) 
  do return self.d.month - 1 end
end
Date.prototype.getDate = function(self) 
  do return self.d.day end
end
Date.prototype.getDay = function(self) 
  do return self.d.wday - 1 end
end

Date.prototype.__class__ =  Date

DateTools.new = {}
DateTools.__name__ = "DateTools"
DateTools.getMonthDays = function(d) 
  local month = d:getMonth();
  local year = d:getFullYear();
  if (month ~= 1) then 
    do return DateTools.DAYS_OF_MONTH[month] end;
  end;
  local isB = (((_G.math.fmod(year, 4)) == 0) and ((_G.math.fmod(year, 100)) ~= 0)) or ((_G.math.fmod(year, 400)) == 0);
  if (isB) then 
    do return 29 end;
  else
    do return 28 end;
  end;
end

EReg.new = function(r,opt) 
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt) 
  local ropt = 0;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(opt);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local _g = __lua_lib_luautf8_Utf8.sub(opt, i + 1, i + 1);
    if (_g) == "g" then 
      self.global = true;
    elseif (_g) == "i" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.CASELESS);
    elseif (_g) == "m" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.MULTILINE);
    elseif (_g) == "s" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.DOTALL);else end;
  end;
  ropt = _hx_bit.bor(ropt,EReg.FLAGS.UTF);
  ropt = _hx_bit.bor(ropt,EReg.FLAGS.UCP);
  if (self.global == nil) then 
    self.global = false;
  end;
  self.r = __lua_lib_lrexlib_Rex.new(r, ropt);
end
EReg.__name__ = "EReg"
EReg.prototype = _hx_e();
EReg.prototype.r= nil;
EReg.prototype.global= nil;
EReg.prototype.s= nil;
EReg.prototype.m= nil;
EReg.prototype.match = function(self,s) 
  if (s == nil) then 
    do return false end;
  else
    self.m = _hx_table.pack(self.r:exec(s, 1));
    self.s = s;
    do return self.m[1] ~= nil end;
  end;
end
EReg.prototype.matched = function(self,n) 
  if ((self.m[1] == nil) or (n < 0)) then 
    _G.error(__haxe_Exception.thrown("EReg::matched"),0);
  else
    if (n == 0) then 
      local k = _G.string.sub(self.s, self.m[1], self.m[2]);
      do return k end;
    else
      if (__lua_Boot.__instanceof(self.m[3], _G.table)) then 
        local mn = 2 * (n - 1);
        if (__lua_Boot.__instanceof(self.m[3][mn + 1], Bool)) then 
          do return nil end;
        end;
        do return _G.string.sub(self.s, self.m[3][mn + 1], self.m[3][mn + 2]) end;
      else
        _G.error(__haxe_Exception.thrown("EReg:matched"),0);
      end;
    end;
  end;
end
EReg.prototype.split = function(self,s) 
  if (self.global) then 
    do return __lua_Lib.fillArray(_hx_wrap_if_string_field(__lua_lib_lrexlib_Rex,'split')(s, self.r)) end;
  else
    local d = "#__delim__#";
    do return __lua_Lib.fillArray(_hx_wrap_if_string_field(__lua_lib_lrexlib_Rex,'split')(self:replace(s, d), d)) end;
  end;
end
EReg.prototype.replace = function(self,s,by) 
  local chunks = String.prototype.split(by, "$$");
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  while (_g1 < chunks.length) do _hx_do_first_1 = false;
    
    local chunk = chunks[_g1];
    _g1 = _g1 + 1;
    _g:push(__lua_lib_lrexlib_Rex.gsub(chunk, "\\$(\\d)", "%%%1", 1));
  end;
  chunks = _g;
  by = chunks:join("$");
  do return __lua_lib_lrexlib_Rex.gsub(s, self.r, by, (function() 
    local _hx_1
    if (self.global) then 
    _hx_1 = nil; else 
    _hx_1 = 1; end
    return _hx_1
  end )()) end
end
EReg.prototype.map = function(self,s,f) 
  local bytesOffset = 1;
  local buf_b = ({});
  local buf_length = 0;
  local _hx_do_first_1 = true;
  while (self.global) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    if (bytesOffset > _G.string.len(s)) then 
      break;
    else
      local tmp;
      if (s == nil) then 
        tmp = false;
      else
        self.m = _hx_table.pack(self.r:exec(s, bytesOffset));
        self.s = s;
        tmp = self.m[1] ~= nil;
      end;
      if (not tmp) then 
        local str = Std.string(_G.string.sub(s, bytesOffset));
        _G.table.insert(buf_b, str);
        buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
        break;
      end;
    end;
    local pos = self.m[1];
    local length = self.m[2] - self.m[1];
    local str = Std.string(_G.string.sub(s, bytesOffset, pos - 1));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(f(self));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    if (length < 0) then 
      local charBytes = _G.string.len(__lua_lib_luautf8_Utf8.sub(_G.string.sub(s, pos), 1, 1));
      local str = Std.string(_G.string.sub(s, pos, (pos + charBytes) - 1));
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      bytesOffset = pos + charBytes;
    else
      bytesOffset = self.m[2] + 1;
    end;
  end;
  if ((not self.global and (bytesOffset > 1)) and ((bytesOffset - 1) < _G.string.len(s))) then 
    local str = Std.string(_G.string.sub(s, bytesOffset));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  do return _G.table.concat(buf_b) end
end

EReg.prototype.__class__ =  EReg

Lambda.new = {}
Lambda.__name__ = "Lambda"
Lambda.has = function(it,elt) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    if (x == elt) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.fold = function(it,f,first) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    first = f(x, first);
  end;
  do return first end;
end

Main.new = {}
Main.__name__ = "Main"
Main.main = function() 
  __haxe_Log.trace("Loaded haxe-ij-merge", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/Main.hx",lineNumber=9,className="Main",methodName="main"}));
end

API.new = {}
_hx_exports["API"] = API
API.__name__ = "API"
API.merge = function(left,middle,right) 
  do return __diff_comparison_MergeResolveUtil.tryResolve(left, middle, right) end;
end
API.greedyMerge = function(left,middle,right) 
  do return __diff_comparison_MergeResolveUtil.tryGreedyResolve(left, middle, right) end;
end

Math.new = {}
Math.__name__ = "Math"
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.max = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.max(a, b) end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

Reflect.new = {}
Reflect.__name__ = "Reflect"
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.callMethod = function(o,func,args) 
  if ((args == nil) or (args.length == 0)) then 
    do return func(o) end;
  else
    local self_arg = false;
    if ((o ~= nil) and (o.__name__ == nil)) then 
      self_arg = true;
    end;
    if (self_arg) then 
      do return func(o, _hx_table.unpack(args, 0, args.length - 1)) end;
    else
      do return func(_hx_table.unpack(args, 0, args.length - 1)) end;
    end;
  end;
end
Reflect.fields = function(o) 
  if (_G.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    do return _hx_field_arr(o) end;
  end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.compareMethods = function(f1,f2) 
  do return f1 == f2 end;
end
Reflect.isObject = function(v) 
  if (v == nil) then 
    do return false end;
  end;
  local t = _G.type(v);
  if (not ((t == "string") or ((t == "table") and (v.__enum__ == nil)))) then 
    if (t == "function") then 
      do return ((function() 
        local _hx_1
        if (_G.type(v) ~= "table") then 
        _hx_1 = false; else 
        _hx_1 = v.__name__; end
        return _hx_1
      end )() or (function() 
        local _hx_2
        if (_G.type(v) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = v.__ename__; end
        return _hx_2
      end )()) ~= nil end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and __lua_Boot.__instanceof(v, _G.table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end
Reflect.deleteField = function(o,field) 
  if (not ((function() 
    local _hx_1
    if ((_G.type(o) == "function") and not ((function() 
      local _hx_2
      if (_G.type(o) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = o.__name__; end
      return _hx_2
    end )() or (function() 
      local _hx_3
      if (_G.type(o) ~= "table") then 
      _hx_3 = false; else 
      _hx_3 = o.__ename__; end
      return _hx_3
    end )())) then 
    _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
    _hx_1 = true; elseif (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__[field] ~= nil; else 
    _hx_1 = o[field] ~= nil; end
    return _hx_1
  end )())) then 
    do return false end;
  end;
  o[field] = nil;
  o.__fields__[field] = nil;
  do return true end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = "String"
String.__index = function(s,k) 
  if (k == "length") then 
    do return __lua_lib_luautf8_Utf8.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "function") and not ((function() 
        local _hx_2
        if (_G.type(o) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = o.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (_G.type(o) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = o.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = __lua_lib_luautf8_Utf8.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return __lua_lib_luautf8_Utf8.char(code) end;
end
String.prototype = _hx_e();
String.prototype.length= nil;
String.prototype.toUpperCase = function(self) 
  do return __lua_lib_luautf8_Utf8.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return __lua_lib_luautf8_Utf8.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  while (true) do _hx_do_first_1 = false;
    
    local p = String.prototype.indexOf(self, str, ret + 1);
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do _hx_do_first_1 = false;
    
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(delimiter) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(self, delimiter, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(self)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(delimiter);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(self, idx, __lua_lib_luautf8_Utf8.len(self)));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return __lua_lib_luautf8_Utf8.sub(self, endIndex + 1, startIndex) end;
  else
    do return __lua_lib_luautf8_Utf8.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(self)))) then 
    len = __lua_lib_luautf8_Utf8.len(self);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(self) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(self) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return __lua_lib_luautf8_Utf8.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = "Std"
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local sign, numString = _G.string.match(x, "^%s*([%-+]?)0[xX]([%da-fA-F]*)");
  if (numString ~= nil) then 
    if (sign == "-") then 
      do return -_G.tonumber(numString, 16) end;
    else
      do return _G.tonumber(numString, 16) end;
    end;
  end;
  local intMatch = _G.string.match(x, "^%s*[%-+]?%d*");
  if (intMatch == nil) then 
    do return nil end;
  end;
  do return _G.tonumber(intMatch) end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x, "^%s*[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  x = String.prototype.substr(x, __lua_lib_luautf8_Utf8.len(digitMatch));
  local decimalMatch = _G.string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  x = String.prototype.substr(x, __lua_lib_luautf8_Utf8.len(decimalMatch));
  local eMatch = _G.string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = ({});
  self.length = 0;
end
StringBuf.__name__ = "StringBuf"
StringBuf.prototype = _hx_e();
StringBuf.prototype.b= nil;
StringBuf.prototype.length= nil;

StringBuf.prototype.__class__ =  StringBuf

StringTools.new = {}
StringTools.__name__ = "StringTools"
StringTools.startsWith = function(s,start) 
  do return s:sub(1, #start) == start end;
end
StringTools.endsWith = function(s,_end) 
  if (_end ~= "") then 
    do return s:sub(-#_end) == _end end;
  else
    do return true end;
  end;
end
StringTools.isSpace = function(s,pos) 
  if (((__lua_lib_luautf8_Utf8.len(s) == 0) or (pos < 0)) or (pos >= __lua_lib_luautf8_Utf8.len(s))) then 
    do return false end;
  end;
  local c = __lua_lib_luautf8_Utf8.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do _hx_do_first_1 = false;
    
    r = r + 1;
  end;
  if (r > 0) then 
    do return String.prototype.substr(s, r, l - r) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, (l - r) - 1)) do _hx_do_first_1 = false;
    
    r = r + 1;
  end;
  if (r > 0) then 
    do return String.prototype.substr(s, 0, l - r) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.lpad = function(s,c,l) 
  if (__lua_lib_luautf8_Utf8.len(c) <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  l = l - __lua_lib_luautf8_Utf8.len(s);
  while (buf_length < l) do _hx_do_first_1 = false;
    
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(buf_b) end;
end
StringTools.rpad = function(s,c,l) 
  if (__lua_lib_luautf8_Utf8.len(c) <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  while (buf_length < l) do _hx_do_first_1 = false;
    
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  do return _G.table.concat(buf_b) end;
end
StringTools.replace = function(s,sub,by) 
  do return String.prototype.split(s, sub):join(by) end;
end
_hxClasses["ValueType"] = { __ename__ = "ValueType", __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)


Type.new = {}
Type.__name__ = "Type"
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o = o;
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getEnum = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  do return o.__enum__ end;
end
Type.getSuperClass = function(c) 
  do return c.__super__ end;
end
Type.getClassName = function(c) 
  do return c.__name__ end;
end
Type.getEnumName = function(e) 
  if (e.__ename__ == nil) then 
    do return nil end;
  end;
  do return e.__ename__ end;
end
Type.createInstance = function(cl,args) 
  do return cl.new(_hx_table.unpack(args, 0)) end;
end
Type.createEmptyInstance = function(cl) 
  local ret = ({});
  _G.setmetatable(ret, _hx_o({__fields__={__index=true},__index=cl.prototype}));
  do return ret end;
end
Type.getInstanceFields = function(c) 
  local p = c.prototype;
  local a = _hx_tab_array({}, 0);
  while (p ~= nil) do _hx_do_first_1 = false;
    
    local _g = 0;
    local _g1 = Reflect.fields(p);
    while (_g < _g1.length) do _hx_do_first_2 = false;
      
      local f = _g1[_g];
      _g = _g + 1;
      if (not Lambda.has(a, f)) then 
        a:push(f);
      end;
    end;
    local mt = _G.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then 
      p = mt.__index;
    else
      p = nil;
    end;
  end;
  do return a end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end

__config_DiffConfig.new = {}
__config_DiffConfig.__name__ = "config.DiffConfig"

__diff_comparison_ByCharRt.new = {}
__diff_comparison_ByCharRt.__name__ = "diff.comparison.ByCharRt"
__diff_comparison_ByCharRt.compare = function(text1,text2) 
  local codePoints1 = __diff_comparison_ByCharRt.getAllCodePoints(text1);
  local codePoints2 = __diff_comparison_ByCharRt.getAllCodePoints(text2);
  local iterable = __diff_comparison_iterables_DiffIterableUtil.diffA(codePoints1, codePoints2);
  local offset1 = 0;
  local offset2 = 0;
  local builder = __diff_comparison_iterables_ChangeBuilder.new(__lua_lib_luautf8_Utf8.len(text1), __lua_lib_luautf8_Utf8.len(text2));
  local pair = __diff_comparison_iterables_DiffIterableUtil.iterateAll(iterable);
  while (pair:hasNext()) do _hx_do_first_1 = false;
    
    local pair = pair:next();
    local range = pair.first;
    local equals = pair.second;
    local end1 = offset1 + __diff_comparison_ByCharRt.countChars(codePoints1, range.start1, range.end1);
    local end2 = offset2 + __diff_comparison_ByCharRt.countChars(codePoints2, range.start2, range.end2);
    if (equals) then 
      builder:markEqualC(offset1, offset2, end1, end2);
    end;
    offset1 = end1;
    offset2 = end2;
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.fair(builder:finish()) end;
end
__diff_comparison_ByCharRt.compareTwoStep = function(text1,text2) 
  local codePoints1 = __diff_comparison_ByCharRt.getNonSpaceCodePoints(text1);
  local codePoints2 = __diff_comparison_ByCharRt.getNonSpaceCodePoints(text2);
  local nonSpaceChanges = __diff_comparison_iterables_DiffIterableUtil.diffA(codePoints1.codePoints, codePoints2.codePoints);
  do return __diff_comparison_ByCharRt.matchAdjustmentSpaces(codePoints1, codePoints2, text1, text2, nonSpaceChanges) end;
end
__diff_comparison_ByCharRt.compareTrimWhitespaces = function(text1,text2) 
  local iterable = __diff_comparison_ByCharRt.compareTwoStep(text1, text2);
  do return __diff_comparison_TrimSpacesCorrector.new(iterable, text1, text2):build() end;
end
__diff_comparison_ByCharRt.compareIgnoreWhitespaces = function(text1,text2) 
  local codePoints1 = __diff_comparison_ByCharRt.getNonSpaceCodePoints(text1);
  local codePoints2 = __diff_comparison_ByCharRt.getNonSpaceCodePoints(text2);
  local changes = __diff_comparison_iterables_DiffIterableUtil.diffA(codePoints1.codePoints, codePoints2.codePoints);
  do return __diff_comparison_ByCharRt.matchAdjustmentSpacesIW(codePoints1, codePoints2, text1, text2, changes) end;
end
__diff_comparison_ByCharRt.comparePunctuation = function(text1,text2) 
  local chars1 = __diff_comparison_ByCharRt.getPunctuationChars(text1);
  local chars2 = __diff_comparison_ByCharRt.getPunctuationChars(text2);
  local nonSpaceChanges = __diff_comparison_iterables_DiffIterableUtil.diffA(chars1.codePoints, chars2.codePoints);
  do return __diff_comparison_ByCharRt.transferPunctuation(chars1, chars2, text1, text2, nonSpaceChanges) end;
end
__diff_comparison_ByCharRt.transferPunctuation = function(chars1,chars2,text1,text2,changes) 
  local builder = __diff_comparison_iterables_ChangeBuilder.new(__lua_lib_luautf8_Utf8.len(text1), __lua_lib_luautf8_Utf8.len(text2));
  local range = changes:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    local count = range.end1 - range.start1;
    local _g = 0;
    local _g1 = count;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local offset1 = chars1.offsets[range.start1 + i];
      local offset2 = chars2.offsets[range.start2 + i];
      builder:markEqualA(offset1, offset2);
    end;
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.fair(builder:finish()) end;
end
__diff_comparison_ByCharRt.matchAdjustmentSpaces = function(codePoints1,codePoints2,text1,text2,changes) 
  do return __diff_comparison_DefaultCharChangeCorrector.new(codePoints1, codePoints2, text1, text2, changes):build() end;
end
__diff_comparison_ByCharRt.matchAdjustmentSpacesIW = function(codePoints1,codePoints2,text1,text2,changes) 
  local ranges = Array.new();
  local ch = changes:iterateChanges():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    local startOffset1;
    local endOffset1;
    if (ch.start1 == ch.end1) then 
      endOffset1 = __diff_comparison_ByCharRt.expandForwardW(codePoints1, codePoints2, text1, text2, ch, true);
      startOffset1 = endOffset1;
    else
      startOffset1 = codePoints1:charOffset(ch.start1);
      endOffset1 = codePoints1:charOffsetAfter(ch.end1 - 1);
    end;
    local startOffset2;
    local endOffset2;
    if (ch.start2 == ch.end2) then 
      endOffset2 = __diff_comparison_ByCharRt.expandForwardW(codePoints1, codePoints2, text1, text2, ch, false);
      startOffset2 = endOffset2;
    else
      startOffset2 = codePoints2:charOffset(ch.start2);
      endOffset2 = codePoints2:charOffsetAfter(ch.end2 - 1);
    end;
    ranges:push(__diff_util_Range.new(startOffset1, endOffset1, startOffset2, endOffset2));
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.createB(ranges, __lua_lib_luautf8_Utf8.len(text1), __lua_lib_luautf8_Utf8.len(text2)) end;
end
__diff_comparison_ByCharRt.expandForwardW = function(codePoints1,codePoints2,text1,text2,ch,left) 
  local offset1 = (function() 
    local _hx_1
    if (ch.start1 == 0) then 
    _hx_1 = 0; else 
    _hx_1 = codePoints1:charOffsetAfter(ch.start1 - 1); end
    return _hx_1
  end )();
  local offset2 = (function() 
    local _hx_2
    if (ch.start2 == 0) then 
    _hx_2 = 0; else 
    _hx_2 = codePoints2:charOffsetAfter(ch.start2 - 1); end
    return _hx_2
  end )();
  local start = (function() 
    local _hx_3
    if (left) then 
    _hx_3 = offset1; else 
    _hx_3 = offset2; end
    return _hx_3
  end )();
  do return start + __diff_comparison_TrimUtil.expandWhitespacesForwardA(text1, text2, offset1, offset2, __lua_lib_luautf8_Utf8.len(text1), __lua_lib_luautf8_Utf8.len(text2)) end;
end
__diff_comparison_ByCharRt.getAllCodePoints = function(text) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __lua_lib_luautf8_Utf8.len(text);
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  local list = _g;
  local len = __lua_lib_luautf8_Utf8.len(text);
  local offset = 0;
  while (offset < len) do _hx_do_first_1 = false;
    
    local ch = __lua_lib_luautf8_Utf8.byte(text, offset + 1);
    local charCount = __diff_comparison__ByWordRt_ByWordRt_Fields_.charCount(ch);
    list:push(ch);
    offset = offset + charCount;
  end;
  do return list end;
end
__diff_comparison_ByCharRt.getNonSpaceCodePoints = function(text) 
  local codePoints = _hx_tab_array({}, 0);
  local offsets = _hx_tab_array({}, 0);
  local len = __lua_lib_luautf8_Utf8.len(text);
  local offset = 0;
  while (offset < len) do _hx_do_first_1 = false;
    
    local ch = __lua_lib_luautf8_Utf8.byte(text, offset + 1);
    local charCount = __diff_comparison__ByWordRt_ByWordRt_Fields_.charCount(ch);
    if (not __diff_comparison_TrimUtil.isWhiteSpaceCodePoint(ch)) then 
      codePoints:push(ch);
      offsets:push(offset);
    end;
    offset = offset + charCount;
  end;
  do return __diff_comparison_CodePointsOffsets.new(codePoints, offsets) end;
end
__diff_comparison_ByCharRt.getPunctuationChars = function(text) 
  local codePoints = _hx_tab_array({}, 0);
  local offsets = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(text);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local c = __lua_lib_luautf8_Utf8.sub(text, i + 1, i + 1);
    if (__diff_comparison_TrimUtil.isPunctuationA(c)) then 
      codePoints:push(__lua_lib_luautf8_Utf8.byte(c, 1));
      offsets:push(i);
    end;
  end;
  do return __diff_comparison_CodePointsOffsets.new(codePoints, offsets) end;
end
__diff_comparison_ByCharRt.countChars = function(codePoints,start,_end) 
  local count = 0;
  local _g = start;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    count = count + __diff_comparison__ByWordRt_ByWordRt_Fields_.charCount(codePoints[i]);
  end;
  do return count end;
end

__diff_comparison_CodePointsOffsets.new = function(codePoints,offsets) 
  local self = _hx_new(__diff_comparison_CodePointsOffsets.prototype)
  __diff_comparison_CodePointsOffsets.super(self,codePoints,offsets)
  return self
end
__diff_comparison_CodePointsOffsets.super = function(self,codePoints,offsets) 
  self.codePoints = codePoints;
  self.offsets = offsets;
end
__diff_comparison_CodePointsOffsets.__name__ = "diff.comparison.CodePointsOffsets"
__diff_comparison_CodePointsOffsets.prototype = _hx_e();
__diff_comparison_CodePointsOffsets.prototype.codePoints= nil;
__diff_comparison_CodePointsOffsets.prototype.offsets= nil;
__diff_comparison_CodePointsOffsets.prototype.charOffset = function(self,index) 
  do return self.offsets[index] end
end
__diff_comparison_CodePointsOffsets.prototype.charOffsetAfter = function(self,index) 
  do return self.offsets[index] + __diff_comparison__ByWordRt_ByWordRt_Fields_.charCount(self.codePoints[index]) end
end

__diff_comparison_CodePointsOffsets.prototype.__class__ =  __diff_comparison_CodePointsOffsets

__diff_comparison_ByLineRt.new = {}
__diff_comparison_ByLineRt.__name__ = "diff.comparison.ByLineRt"
__diff_comparison_ByLineRt.compareA = function(lines1,lines2,policy) 
  do return __diff_comparison_ByLineRt.doCompareA(__diff_comparison_ByLineRt.getLines(lines1, policy), __diff_comparison_ByLineRt.getLines(lines2, policy), policy) end;
end
__diff_comparison_ByLineRt.compareB = function(lines1,lines2,lines3,policy) 
  do return __diff_comparison_ByLineRt.doCompareB(__diff_comparison_ByLineRt.getLines(lines1, policy), __diff_comparison_ByLineRt.getLines(lines2, policy), __diff_comparison_ByLineRt.getLines(lines3, policy), policy, false) end;
end
__diff_comparison_ByLineRt.merge = function(lines1,lines2,lines3,policy) 
  do return __diff_comparison_ByLineRt.doCompareB(__diff_comparison_ByLineRt.getLines(lines1, policy), __diff_comparison_ByLineRt.getLines(lines2, policy), __diff_comparison_ByLineRt.getLines(lines3, policy), policy, true) end;
end
__diff_comparison_ByLineRt.doCompareA = function(lines1,lines2,policy) 
  if (policy == __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES) then 
    local changes = __diff_comparison_ByLineRt.compareSmart(lines1, lines2);
    changes = __diff_comparison_ByLineRt.optimizeLineChunks(lines1, lines2, changes);
    do return __diff_comparison_ByLineRt.expandRanges(lines1, lines2, changes) end;
  else
    local iwLines1 = __diff_comparison_ByLineRt.convertMode(lines1, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES);
    local iwLines2 = __diff_comparison_ByLineRt.convertMode(lines2, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES);
    local iwChanges = __diff_comparison_ByLineRt.compareSmart(iwLines1, iwLines2);
    iwChanges = __diff_comparison_ByLineRt.optimizeLineChunks(lines1, lines2, iwChanges);
    do return __diff_comparison_ByLineRt.correctChangesSecondStep(lines1, lines2, iwChanges) end;
  end;
end
__diff_comparison_ByLineRt.doCompareB = function(lines1,lines2,lines3,policy,keepIgnoredChanges) 
  local iwLines1 = __diff_comparison_ByLineRt.convertMode(lines1, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES);
  local iwLines2 = __diff_comparison_ByLineRt.convertMode(lines2, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES);
  local iwLines3 = __diff_comparison_ByLineRt.convertMode(lines3, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES);
  local iwChanges1 = __diff_comparison_ByLineRt.compareSmart(iwLines2, iwLines1);
  iwChanges1 = __diff_comparison_ByLineRt.optimizeLineChunks(lines2, lines1, iwChanges1);
  local iterable1 = __diff_comparison_ByLineRt.correctChangesSecondStep(lines2, lines1, iwChanges1);
  local iwChanges2 = __diff_comparison_ByLineRt.compareSmart(iwLines2, iwLines3);
  iwChanges2 = __diff_comparison_ByLineRt.optimizeLineChunks(lines2, lines3, iwChanges2);
  local iterable2 = __diff_comparison_ByLineRt.correctChangesSecondStep(lines2, lines3, iwChanges2);
  if (keepIgnoredChanges and (policy ~= __diff_comparison_ComparisonPolicy.DEFAULT)) then 
    do return __diff_comparison_ComparisonMergeUtil.buildMerge(iterable1, iterable2, __diff_comparison_SideEquality.new(function(index1,index2,index3) 
      do return __diff_comparison_ByLineRt.equalsDefaultPolicy(lines1, lines2, lines3, index1, index2, index3) end;
    end)) end;
  else
    do return __diff_comparison_ComparisonMergeUtil.buildSimple(iterable1, iterable2) end;
  end;
end
__diff_comparison_ByLineRt.equalsDefaultPolicy = function(lines1,lines2,lines3,index1,index2,index3) 
  local content1 = lines1[index1]:getContent();
  local content2 = lines2[index2]:getContent();
  local content3 = lines3[index3]:getContent();
  if (__diff_comparison_ComparisonUtil.isEquals(content2, content1, __diff_comparison_ComparisonPolicy.DEFAULT)) then 
    do return __diff_comparison_ComparisonUtil.isEquals(content2, content3, __diff_comparison_ComparisonPolicy.DEFAULT) end;
  else
    do return false end;
  end;
end
__diff_comparison_ByLineRt.correctChangesSecondStep = function(lines1,lines2,changes) 
  local builder = __diff_comparison_iterables_ExpandChangeBuilder.new(lines1, lines2);
  __diff_comparison_BuilderRunner.new(builder, changes, lines1, lines2):run();
  do return __diff_comparison_iterables_DiffIterableUtil.fair(builder:finish()) end;
end
__diff_comparison_ByLineRt.getBestMatchingAlignment = function(subLines1,subLines2,lines1,lines2) 
  local size = subLines1.length;
  local comb = Array.new();
  local best = Array.new();
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    best[i] = i;
  end;
  __diff_comparison_AlignmentRunner.new(subLines1, subLines2, lines1, lines2, size, comb, best):run();
  do return best end;
end
__diff_comparison_ByLineRt.optimizeLineChunks = function(lines1,lines2,iterable) 
  do return __diff_comparison_LineChunkOptimizer.new(lines1, lines2, iterable):build() end;
end
__diff_comparison_ByLineRt.compareSmart = function(lines1,lines2) 
  local threshold = __diff_comparison_ComparisonUtil.getUnimportantLineCharCount();
  if (threshold == 0) then 
    do return __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_Line(lines1, lines2) end;
  end;
  local bigLines1 = __diff_comparison_ByLineRt.getBigLines(lines1, threshold);
  local bigLines2 = __diff_comparison_ByLineRt.getBigLines(lines2, threshold);
  local changes = __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_Line(bigLines1.first, bigLines2.first);
  do return __diff_comparison_SmartLineChangeCorrector.new(bigLines1.second, bigLines2.second, lines1, lines2, changes):build() end;
end
__diff_comparison_ByLineRt.getBigLines = function(lines,threshold) 
  local bigLines = Array.new();
  local indexes = Array.new();
  local _g = 0;
  local _g1 = lines.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local line = lines[i];
    if (line:getNonSpaceChars() > threshold) then 
      bigLines:push(line);
      indexes:push(i);
    end;
  end;
  do return __ds_Pair.create_Array_diff_comparison_Line_Array_Int(bigLines, indexes) end;
end
__diff_comparison_ByLineRt.expandRanges = function(lines1,lines2,iterable) 
  local changes = Array.new();
  local ch = iterable:iterateChanges():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    local expanded = __diff_comparison_TrimUtil.expandA(lines1, lines2, ch.start1, ch.start2, ch.end1, ch.end2);
    if (not expanded:isEmpty()) then 
      changes:push(expanded);
    end;
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createB(changes, lines1.length, lines2.length)) end;
end
__diff_comparison_ByLineRt.getLines = function(text,policy) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = text;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__diff_comparison_Line.new(i, policy));
  end;
  do return _g end;
end
__diff_comparison_ByLineRt.convertMode = function(original,policy) 
  local result = Array.new();
  local _g = 0;
  while (_g < original.length) do _hx_do_first_1 = false;
    
    local line = original[_g];
    _g = _g + 1;
    local newLine = (function() 
      local _hx_1
      if (line:getPolicy() ~= policy) then 
      _hx_1 = __diff_comparison_Line.new(line:getContent(), policy); else 
      _hx_1 = line; end
      return _hx_1
    end )();
    result:push(newLine);
  end;
  do return result end;
end
__diff_comparison_ByLineRt.convertIntoMergeLineFragments = function(conflicts) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = conflicts;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__diff_fragments_MergeLineFragment.new(i));
  end;
  do return _g end;
end

__diff_comparison_Line.new = function(text,policy) 
  local self = _hx_new(__diff_comparison_Line.prototype)
  __diff_comparison_Line.super(self,text,policy)
  return self
end
__diff_comparison_Line.super = function(self,text,policy) 
  self.myText = text;
  self.myPolicy = policy;
  self.myNonSpaceChars = __diff_comparison_Line.countNonSpaceChars(text);
end
__diff_comparison_Line.__name__ = "diff.comparison.Line"
__diff_comparison_Line.countNonSpaceChars = function(text) 
  local nonSpace = 0;
  local len = __lua_lib_luautf8_Utf8.len(text);
  local offset = 0;
  while (offset < len) do _hx_do_first_1 = false;
    
    local c = __lua_lib_luautf8_Utf8.sub(text, offset + 1, offset + 1);
    if (not __diff_comparison_TrimUtil.isWhiteSpace(c)) then 
      nonSpace = nonSpace + 1;
    end;
    offset = offset + 1;
  end;
  do return nonSpace end;
end
__diff_comparison_Line.prototype = _hx_e();
__diff_comparison_Line.prototype.myText= nil;
__diff_comparison_Line.prototype.myPolicy= nil;
__diff_comparison_Line.prototype.myHash= nil;
__diff_comparison_Line.prototype.myNonSpaceChars= nil;
__diff_comparison_Line.prototype.getPolicy = function(self) 
  do return self.myPolicy end
end
__diff_comparison_Line.prototype.getContent = function(self) 
  do return self.myText end
end
__diff_comparison_Line.prototype.getNonSpaceChars = function(self) 
  do return self.myNonSpaceChars end
end
__diff_comparison_Line.prototype.equals = function(self,l) 
  if (self == l) then 
    do return true end;
  end;
  local tmp;
  if (l ~= nil) then 
    local c = Type.getClass(l);
    local tmp1 = c.__name__;
    local c = Type.getClass(self);
    tmp = tmp1 ~= c.__name__;
  else
    tmp = true;
  end;
  if (tmp) then 
    do return false end;
  end;
  do return __diff_comparison_ComparisonUtil.isEquals(self:getContent(), l:getContent(), self.myPolicy) end
end
__diff_comparison_Line.prototype.hashCode = function(self) 
  do return self.myHash end
end

__diff_comparison_Line.prototype.__class__ =  __diff_comparison_Line

__diff_comparison_BuilderRunner.new = function(builder,changes,lines1,lines2) 
  local self = _hx_new(__diff_comparison_BuilderRunner.prototype)
  __diff_comparison_BuilderRunner.super(self,builder,changes,lines1,lines2)
  return self
end
__diff_comparison_BuilderRunner.super = function(self,builder,changes,lines1,lines2) 
  self.last2 = 0;
  self.last1 = 0;
  self.sample = nil;
  self.changes = changes;
  self.builder = builder;
  self.lines1 = lines1;
  self.lines2 = lines2;
end
__diff_comparison_BuilderRunner.__name__ = "diff.comparison.BuilderRunner"
__diff_comparison_BuilderRunner.prototype = _hx_e();
__diff_comparison_BuilderRunner.prototype.sample= nil;
__diff_comparison_BuilderRunner.prototype.last1= nil;
__diff_comparison_BuilderRunner.prototype.last2= nil;
__diff_comparison_BuilderRunner.prototype.builder= nil;
__diff_comparison_BuilderRunner.prototype.changes= nil;
__diff_comparison_BuilderRunner.prototype.lines1= nil;
__diff_comparison_BuilderRunner.prototype.lines2= nil;
__diff_comparison_BuilderRunner.prototype.run = function(self) 
  local range = self.changes:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    local count = range.end1 - range.start1;
    local _g = 0;
    local _g1 = count;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index1 = range.start1 + i;
      local index2 = range.start2 + i;
      local line1 = self.lines1[index1];
      local line2 = self.lines2[index2];
      if (not __diff_comparison_ComparisonUtil.isEquals(self.sample, line1:getContent(), __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES)) then 
        if (line1:equals(line2)) then 
          self:flush(index1, index2);
          self.builder:markEqualA(index1, index2);
        else
          self:flush(index1, index2);
          self.sample = line1:getContent();
        end;
      end;
    end;
  end;
  self:flush(self.changes:getLength1(), self.changes:getLength2());
end
__diff_comparison_BuilderRunner.prototype.flush = function(self,line1,line2) 
  if (self.sample == nil) then 
    do return end;
  end;
  local start1 = Std.int(Math.max(self.last1, self.builder:getIndex1()));
  local start2 = Std.int(Math.max(self.last2, self.builder:getIndex2()));
  local subLines1 = Array.new();
  local subLines2 = Array.new();
  local _g = start1;
  local _g1 = line1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (__diff_comparison_ComparisonUtil.isEquals(self.sample, self.lines1[i]:getContent(), __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES)) then 
      subLines1:push(i);
      self.last1 = i + 1;
    end;
  end;
  local _g = start2;
  local _g1 = line2;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (__diff_comparison_ComparisonUtil.isEquals(self.sample, self.lines2[i]:getContent(), __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES)) then 
      subLines2:push(i);
      self.last2 = i + 1;
    end;
  end;
  self:alignExactMatching(subLines1, subLines2);
  self.sample = nil;
end
__diff_comparison_BuilderRunner.prototype.alignExactMatching = function(self,subLines1,subLines2) 
  local n = Std.int(Math.max(subLines1.length, subLines2.length));
  local skipAligning = (n > 10) or (subLines1.length == subLines2.length);
  if (skipAligning) then 
    local count = Std.int(Math.min(subLines1.length, subLines2.length));
    local _g = 0;
    local _g1 = count;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index1 = subLines1[i];
      local index2 = subLines2[i];
      if (self.lines1[index1]:equals(self.lines2[index2])) then 
        self.builder:markEqualA(index1, index2);
      end;
    end;
    do return end;
  end;
  if (subLines1.length < subLines2.length) then 
    local matching = __diff_comparison_ByLineRt.getBestMatchingAlignment(subLines1, subLines2, self.lines1, self.lines2);
    local _g = 0;
    local _g1 = subLines1.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index1 = subLines1[i];
      local index2 = subLines2[matching[i]];
      if (self.lines1[index1]:equals(self.lines2[index2])) then 
        self.builder:markEqualA(index1, index2);
      end;
    end;
  else
    local matching = __diff_comparison_ByLineRt.getBestMatchingAlignment(subLines2, subLines1, self.lines2, self.lines1);
    local _g = 0;
    local _g1 = subLines2.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index1 = subLines1[matching[i]];
      local index2 = subLines2[i];
      if (self.lines1[index1]:equals(self.lines2[index2])) then 
        self.builder:markEqualA(index1, index2);
      end;
    end;
  end;
end

__diff_comparison_BuilderRunner.prototype.__class__ =  __diff_comparison_BuilderRunner

__diff_comparison_AlignmentRunner.new = function(subLines1,subLines2,lines1,lines2,size,comb,best) 
  local self = _hx_new(__diff_comparison_AlignmentRunner.prototype)
  __diff_comparison_AlignmentRunner.super(self,subLines1,subLines2,lines1,lines2,size,comb,best)
  return self
end
__diff_comparison_AlignmentRunner.super = function(self,subLines1,subLines2,lines1,lines2,size,comb,best) 
  self.bestWeight = 0;
  self.subLines1 = subLines1;
  self.subLines2 = subLines2;
  self.lines1 = lines1;
  self.lines2 = lines2;
  self.size = size;
  self.comb = comb;
  self.best = best;
end
__diff_comparison_AlignmentRunner.__name__ = "diff.comparison.AlignmentRunner"
__diff_comparison_AlignmentRunner.prototype = _hx_e();
__diff_comparison_AlignmentRunner.prototype.bestWeight= nil;
__diff_comparison_AlignmentRunner.prototype.subLines1= nil;
__diff_comparison_AlignmentRunner.prototype.subLines2= nil;
__diff_comparison_AlignmentRunner.prototype.lines1= nil;
__diff_comparison_AlignmentRunner.prototype.lines2= nil;
__diff_comparison_AlignmentRunner.prototype.size= nil;
__diff_comparison_AlignmentRunner.prototype.comb= nil;
__diff_comparison_AlignmentRunner.prototype.best= nil;
__diff_comparison_AlignmentRunner.prototype.run = function(self) 
  self:combinations(0, self.subLines2.length - 1, 0);
end
__diff_comparison_AlignmentRunner.prototype.combinations = function(self,start,n,k) 
  if (k == self.size) then 
    self:processCombination();
    do return end;
  end;
  local _g = start;
  local _g1 = n + 1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self.comb[k] = i;
    self:combinations(i + 1, n, k + 1);
  end;
end
__diff_comparison_AlignmentRunner.prototype.processCombination = function(self) 
  local weight = 0;
  local _g = 0;
  local _g1 = self.size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local index1 = self.subLines1[i];
    local index2 = self.subLines2[self.comb[i]];
    if (self.lines1[index1]:equals(self.lines2[index2])) then 
      weight = weight + 1;
    end;
  end;
  if (weight > self.bestWeight) then 
    self.bestWeight = weight;
    local array = self.comb;
    local length = array.length;
    local vec = ({length = length});
    local _g = 0;
    local _g1 = array.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      vec[i] = array[i];
    end;
    local c = vec;
    local array = self.best;
    local length = array.length;
    local vec = ({length = length});
    local _g = 0;
    local _g1 = array.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      vec[i] = array[i];
    end;
    local b = vec;
    __haxe_ds__Vector_Vector_Impl_.blit(c, 0, b, 0, c.length);
    self.comb = __haxe_ds__Vector_Vector_Impl_.toArray(c);
    self.best = __haxe_ds__Vector_Vector_Impl_.toArray(b);
  end;
end

__diff_comparison_AlignmentRunner.prototype.__class__ =  __diff_comparison_AlignmentRunner

__diff_comparison_ByWordRt.new = {}
__diff_comparison_ByWordRt.__name__ = "diff.comparison.ByWordRt"
__diff_comparison_ByWordRt.compareA = function(text1,text2,policy) 
  local words1 = __diff_comparison_ByWordRt.getInlineChunks(text1);
  local words2 = __diff_comparison_ByWordRt.getInlineChunks(text2);
  do return __diff_comparison_ByWordRt.compareB(text1, words1, text2, words2, policy) end;
end
__diff_comparison_ByWordRt.compareB = function(text1,words1,text2,words2,policy) 
  local wordChanges = __diff_comparison_iterables_DiffIterableUtil.diffB_diff_comparison_InlineChunk_Dynamic(words1, words2);
  wordChanges = __diff_comparison_ByWordRt.optimizeWordChunks(text1, text2, words1, words2, wordChanges);
  local delimitersIterable = __diff_comparison_ByWordRt.matchAdjustmentDelimitersA(text1, text2, words1, words2, wordChanges);
  local iterable = __diff_comparison_ByWordRt.matchAdjustmentWhitespacesA(text1, text2, delimitersIterable, policy);
  do return __diff_comparison_ByWordRt.convertIntoDiffFragments(iterable) end;
end
__diff_comparison_ByWordRt.compareC = function(text1,text2,text3,policy) 
  local words1 = __diff_comparison_ByWordRt.getInlineChunks(text1);
  local words2 = __diff_comparison_ByWordRt.getInlineChunks(text2);
  local words3 = __diff_comparison_ByWordRt.getInlineChunks(text3);
  local wordChanges1 = __diff_comparison_iterables_DiffIterableUtil.diffB_diff_comparison_InlineChunk_Dynamic(words2, words1);
  wordChanges1 = __diff_comparison_ByWordRt.optimizeWordChunks(text2, text1, words2, words1, wordChanges1);
  local iterable1 = __diff_comparison_ByWordRt.matchAdjustmentDelimitersA(text2, text1, words2, words1, wordChanges1);
  local wordChanges2 = __diff_comparison_iterables_DiffIterableUtil.diffB_diff_comparison_InlineChunk_Dynamic(words2, words3);
  wordChanges2 = __diff_comparison_ByWordRt.optimizeWordChunks(text2, text3, words2, words3, wordChanges2);
  local iterable2 = __diff_comparison_ByWordRt.matchAdjustmentDelimitersA(text2, text3, words2, words3, wordChanges2);
  local wordConflicts = __diff_comparison_ComparisonMergeUtil.buildSimple(iterable1, iterable2);
  local result = __diff_comparison_ByWordRt.matchAdjustmentWhitespacesB(text1, text2, text3, wordConflicts, policy);
  do return __diff_comparison_ByWordRt.convertIntoMergeWordFragments(result) end;
end
__diff_comparison_ByWordRt.compareX = function(text1,text2,text3,policy) 
  local words1 = __diff_comparison_ByWordRt.getInlineChunks(text1);
  local words2 = __diff_comparison_ByWordRt.getInlineChunks(text2);
  local words3 = __diff_comparison_ByWordRt.getInlineChunks(text3);
  local wordChanges1 = __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_InlineChunk_Dynamic(words2, words1);
  wordChanges1 = __diff_comparison_ByWordRt.optimizeWordChunks(text2, text1, words2, words1, wordChanges1);
  local iterable1 = __diff_comparison_ByWordRt.matchAdjustmentDelimitersA(text2, text1, words2, words1, wordChanges1);
  local wordChanges2 = __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_InlineChunk_Dynamic(words2, words3);
  wordChanges2 = __diff_comparison_ByWordRt.optimizeWordChunks(text2, text3, words2, words3, wordChanges2);
  local iterable2 = __diff_comparison_ByWordRt.matchAdjustmentDelimitersA(text2, text3, words2, words3, wordChanges2);
  local wordConflicts = __diff_comparison_ComparisonMergeUtil.buildSimple(iterable1, iterable2);
  local result = __diff_comparison_ByWordRt.matchAdjustmentWhitespacesB(text1, text2, text3, wordConflicts, policy);
  do return __diff_comparison_ByWordRt.convertIntoMergeWordFragments(result) end;
end
__diff_comparison_ByWordRt.compareY = function(text1,text2,policy) 
  local words1 = __diff_comparison_ByWordRt.getInlineChunks(text1);
  local words2 = __diff_comparison_ByWordRt.getInlineChunks(text2);
  do return __diff_comparison_ByWordRt.compareZ(text1, words1, text2, words2, policy) end;
end
__diff_comparison_ByWordRt.compareZ = function(text1,words1,text2,words2,policy) 
  local wordChanges = __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_InlineChunk_Dynamic(words1, words2);
  wordChanges = __diff_comparison_ByWordRt.optimizeWordChunks(text1, text2, words1, words2, wordChanges);
  local delimitersIterable = __diff_comparison_ByWordRt.matchAdjustmentDelimitersA(text1, text2, words1, words2, wordChanges);
  local iterable = __diff_comparison_ByWordRt.matchAdjustmentWhitespacesA(text1, text2, delimitersIterable, policy);
  do return __diff_comparison_ByWordRt.convertIntoDiffFragments(iterable) end;
end
__diff_comparison_ByWordRt.compareAndSplit = function(text1,text2,policy) 
  local words1 = __diff_comparison_ByWordRt.getInlineChunks(text1);
  local words2 = __diff_comparison_ByWordRt.getInlineChunks(text2);
  local wordChanges = __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_InlineChunk_Dynamic(words1, words2);
  wordChanges = __diff_comparison_ByWordRt.optimizeWordChunks(text1, text2, words1, words2, wordChanges);
  local wordBlocks = __diff_comparison_LineFragmentSplitter.new(text1, text2, words1, words2, wordChanges):run();
  local subIterables = __diff_comparison_ByWordRt.collectWordBlockSubIterables(wordChanges, wordBlocks);
  local lineBlocks = Array.new();
  local _g = 0;
  local _g1 = wordBlocks.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local block = wordBlocks[i];
    local offsets = block.offsets;
    local words = block.words;
    local subtext1 = String.prototype.substring(text1, offsets.start1, offsets.end1);
    local subtext2 = String.prototype.substring(text2, offsets.start2, offsets.end2);
    local subwords1 = words1:slice(words.start1, words.end1);
    local subwords2 = words2:slice(words.start2, words.end2);
    local subiterable = subIterables[i];
    local delimitersIterable = __diff_comparison_ByWordRt.matchAdjustmentDelimitersB(subtext1, subtext2, subwords1, subwords2, subiterable, offsets.start1, offsets.start2);
    local iterable = __diff_comparison_ByWordRt.matchAdjustmentWhitespacesA(subtext1, subtext2, delimitersIterable, policy);
    local fragments = __diff_comparison_ByWordRt.convertIntoDiffFragments(iterable);
    local newlines1 = __diff_comparison_ByWordRt.countNewlines(subwords1);
    local newlines2 = __diff_comparison_ByWordRt.countNewlines(subwords2);
    lineBlocks:push(__diff_comparison_LineBlock.new(fragments, offsets, newlines1, newlines2));
  end;
  do return lineBlocks end;
end
__diff_comparison_ByWordRt.collectWordBlockSubIterables = function(wordChanges,wordBlocks) 
  local changed = Array.new();
  local range = wordChanges:iterateChanges():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    changed:push(range);
  end;
  local index = 0;
  local subIterables = Array.new();
  local _g = 0;
  while (_g < wordBlocks.length) do _hx_do_first_1 = false;
    
    local block = wordBlocks[_g];
    _g = _g + 1;
    local words = block.words;
    local _hx_continue_2 = false;
    while (index < changed.length) do _hx_do_first_2 = false;
      repeat 
      local range = changed[index];
      if ((range.end1 < words.start1) or (range.end2 < words.start2)) then 
        index = index + 1;
        break;
      end;
      _hx_continue_2 = true;break;until true
      if _hx_continue_2 then 
      _hx_continue_2 = false;
      break;
      end;
      
    end;
    subIterables:push(__diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_SubiterableDiffIterable.new(changed, words.start1, words.end1, words.start2, words.end2, index)));
  end;
  do return subIterables end;
end
__diff_comparison_ByWordRt.optimizeWordChunks = function(text1,text2,words1,words2,iterable) 
  do return __diff_comparison_WordChunkOptimizer.new(words1, words2, text1, text2, iterable):build() end;
end
__diff_comparison_ByWordRt.matchAdjustmentDelimitersA = function(text1,text2,words1,words2,changes) 
  do return __diff_comparison_ByWordRt.matchAdjustmentDelimitersB(text1, text2, words1, words2, changes, 0, 0) end;
end
__diff_comparison_ByWordRt.matchAdjustmentDelimitersB = function(text1,text2,words1,words2,changes,startShift1,startShift2) 
  do return __diff_comparison_AdjustmentPunctuationMatcher.new(text1, text2, words1, words2, startShift1, startShift2, changes):build() end;
end
__diff_comparison_ByWordRt.matchAdjustmentWhitespacesA = function(text1,text2,iterable,policy) 
  local tmp = policy[1];
  if (tmp) == 0 then 
    do return __diff_comparison_DefaultCorrector.new(iterable, text1, text2):build() end;
  elseif (tmp) == 1 then 
    local defaultIterable = __diff_comparison_DefaultCorrector.new(iterable, text1, text2):build();
    do return __diff_comparison_TrimSpacesCorrector.new(defaultIterable, text1, text2):build() end;
  elseif (tmp) == 2 then 
    do return __diff_comparison_IgnoreSpacesCorrector.new(iterable, text1, text2):build() end; end;
end
__diff_comparison_ByWordRt.matchAdjustmentWhitespacesB = function(text1,text2,text3,conflicts,policy) 
  local tmp = policy[1];
  if (tmp) == 0 then 
    do return __diff_comparison_MergeDefaultCorrector.new(conflicts, text1, text2, text3):build() end;
  elseif (tmp) == 1 then 
    local defaultConflicts = __diff_comparison_MergeDefaultCorrector.new(conflicts, text1, text2, text3):build();
    do return __diff_comparison_MergeTrimSpacesCorrector.new(defaultConflicts, text1, text2, text3):build() end;
  elseif (tmp) == 2 then 
    do return __diff_comparison_MergeIgnoreSpacesCorrector.new(conflicts, text1, text2, text3):build() end; end;
end
__diff_comparison_ByWordRt.convertIntoMergeWordFragments = function(conflicts) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = conflicts;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__diff_fragments_MergeWordFragment.newFromRange(i));
  end;
  do return _g end;
end
__diff_comparison_ByWordRt.convertIntoDiffFragments = function(changes) 
  local fragments = Array.new();
  local ch = changes:iterateChanges():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    fragments:push(__diff_fragments_DiffFragmentImpl.new(ch.start1, ch.end1, ch.start2, ch.end2));
  end;
  do return fragments end;
end
__diff_comparison_ByWordRt.comparePunctuation2Side = function(text1,text21,text22) 
  local text2 = __ds__MergingCharSequence_MergingCharSequence_Impl_._new(text21, text22);
  local changes = __diff_comparison_ByCharRt.comparePunctuation(text1, text2);
  local ranges = __diff_comparison_ByWordRt.splitIterable2Side(changes, __lua_lib_luautf8_Utf8.len(text21));
  local iterable1 = __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createUnchanged(ranges.first, __lua_lib_luautf8_Utf8.len(text1), __lua_lib_luautf8_Utf8.len(text21)));
  local iterable2 = __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createUnchanged(ranges.second, __lua_lib_luautf8_Utf8.len(text1), __lua_lib_luautf8_Utf8.len(text22)));
  do return __ds_Couple.of_diff_comparison_iterables_FairDiffIterable(iterable1, iterable2) end;
end
__diff_comparison_ByWordRt.splitIterable2Side = function(changes,offset) 
  local ranges1 = Array.new();
  local ranges2 = Array.new();
  local ch = changes:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    if (ch.end2 <= offset) then 
      ranges1:push(__diff_util_Range.new(ch.start1, ch.end1, ch.start2, ch.end2));
    else
      if (ch.start2 >= offset) then 
        ranges2:push(__diff_util_Range.new(ch.start1, ch.end1, ch.start2 - offset, ch.end2 - offset));
      else
        local len2 = offset - ch.start2;
        ranges1:push(__diff_util_Range.new(ch.start1, ch.start1 + len2, ch.start2, offset));
        ranges2:push(__diff_util_Range.new(ch.start1 + len2, ch.end1, 0, ch.end2 - offset));
      end;
    end;
  end;
  do return __ds_Couple.of_Array_diff_util_Range(ranges1, ranges2) end;
end
__diff_comparison_ByWordRt.isWordChunk = function(chunk) 
  do return (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(chunk, __diff_comparison_WordChunk)) then 
    _hx_1 = chunk; else 
    _hx_1 = nil; end
    return _hx_1
  end )() ~= nil end;
end
__diff_comparison_ByWordRt.isLeadingTrailingSpace = function(text,start) 
  if (not __diff_comparison_ByWordRt.isLeadingSpace(text, start)) then 
    do return __diff_comparison_ByWordRt.isTrailingSpace(text, start) end;
  else
    do return true end;
  end;
end
__diff_comparison_ByWordRt.isLeadingSpace = function(text,start) 
  if (start < 0) then 
    do return false end;
  end;
  if (start == __lua_lib_luautf8_Utf8.len(text)) then 
    do return false end;
  end;
  if (not __diff_comparison_TrimUtil.isWhiteSpace(__lua_lib_luautf8_Utf8.sub(text, start + 1, start + 1))) then 
    do return false end;
  end;
  start = start - 1;
  while (start >= 0) do _hx_do_first_1 = false;
    
    local c = __lua_lib_luautf8_Utf8.sub(text, start + 1, start + 1);
    if (c == "\n") then 
      do return true end;
    end;
    if (not __diff_comparison_TrimUtil.isWhiteSpace(c)) then 
      do return false end;
    end;
    start = start - 1;
  end;
  do return true end;
end
__diff_comparison_ByWordRt.isTrailingSpace = function(text,_end) 
  if (_end < 0) then 
    do return false end;
  end;
  if (_end == __lua_lib_luautf8_Utf8.len(text)) then 
    do return false end;
  end;
  if (not __diff_comparison_TrimUtil.isWhiteSpace(__lua_lib_luautf8_Utf8.sub(text, _end + 1, _end + 1))) then 
    do return false end;
  end;
  while (_end < __lua_lib_luautf8_Utf8.len(text)) do _hx_do_first_1 = false;
    
    local c = __lua_lib_luautf8_Utf8.sub(text, _end + 1, _end + 1);
    if (c == "\n") then 
      do return true end;
    end;
    if (not __diff_comparison_TrimUtil.isWhiteSpace(c)) then 
      do return false end;
    end;
    _end = _end + 1;
  end;
  do return true end;
end
__diff_comparison_ByWordRt.countNewlines = function(words) 
  local count = 0;
  local _g = 0;
  while (_g < words.length) do _hx_do_first_1 = false;
    
    local word = words[_g];
    _g = _g + 1;
    if ((function() 
      local _hx_1
      if (__lua_Boot.__instanceof(word, __diff_comparison_NewlineChunk)) then 
      _hx_1 = word; else 
      _hx_1 = nil; end
      return _hx_1
    end )() ~= nil) then 
      count = count + 1;
    end;
  end;
  do return count end;
end
__diff_comparison_ByWordRt.getInlineChunks = function(text) 
  local chunks = Array.new();
  local len = __lua_lib_luautf8_Utf8.len(text);
  local offset = 0;
  local wordStart = -1;
  local wordHash = 0;
  while (offset < len) do _hx_do_first_1 = false;
    
    local ch = __lua_lib_luautf8_Utf8.byte(text, offset + 1);
    local characterCount = __diff_comparison__ByWordRt_ByWordRt_Fields_.charCount(ch);
    local isAlphaResult = __diff_comparison_TrimUtil.isAlpha(ch);
    local isWordPart = isAlphaResult and not __diff_comparison_TrimUtil.isContinuousScript(ch);
    if (isWordPart) then 
      if (wordStart == -1) then 
        wordStart = offset;
        wordHash = 0;
      end;
      wordHash = (wordHash * 31) + ch;
    else
      if (wordStart ~= -1) then 
        chunks:push(__diff_comparison_WordChunk.new(text, wordStart, offset, wordHash));
        wordStart = -1;
      end;
      if (isAlphaResult) then 
        chunks:push(__diff_comparison_WordChunk.new(text, offset, offset + characterCount, ch));
      else
        if (ch == 10) then 
          chunks:push(__diff_comparison_NewlineChunk.new(offset));
        end;
      end;
    end;
    offset = offset + characterCount;
  end;
  if (wordStart ~= -1) then 
    chunks:push(__diff_comparison_WordChunk.new(text, wordStart, len, wordHash));
  end;
  do return chunks end;
end

__util_Hashable.new = {}
__util_Hashable.__name__ = "util.Hashable"
__util_Hashable.prototype = _hx_e();
__util_Hashable.prototype.hashCode= nil;

__util_Hashable.prototype.__class__ =  __util_Hashable

__util_Equals.new = {}
__util_Equals.__name__ = "util.Equals"
__util_Equals.prototype = _hx_e();
__util_Equals.prototype.equals= nil;

__util_Equals.prototype.__class__ =  __util_Equals

__diff_comparison_InlineChunk.new = {}
__diff_comparison_InlineChunk.__name__ = "diff.comparison.InlineChunk"
__diff_comparison_InlineChunk.__interfaces__ = {__util_Hashable,__util_Equals}
__diff_comparison_InlineChunk.prototype = _hx_e();
__diff_comparison_InlineChunk.prototype.getOffset1= nil;
__diff_comparison_InlineChunk.prototype.getOffset2= nil;

__diff_comparison_InlineChunk.prototype.__class__ =  __diff_comparison_InlineChunk

__diff_comparison_WordChunk.new = function(text,offset1,offset2,hash) 
  local self = _hx_new(__diff_comparison_WordChunk.prototype)
  __diff_comparison_WordChunk.super(self,text,offset1,offset2,hash)
  return self
end
__diff_comparison_WordChunk.super = function(self,text,offset1,offset2,hash) 
  self.myText = text;
  self.myOffset1 = offset1;
  self.myOffset2 = offset2;
  self.myHash = hash;
end
__diff_comparison_WordChunk.__name__ = "diff.comparison.WordChunk"
__diff_comparison_WordChunk.__interfaces__ = {__diff_comparison_InlineChunk}
__diff_comparison_WordChunk.prototype = _hx_e();
__diff_comparison_WordChunk.prototype.myText= nil;
__diff_comparison_WordChunk.prototype.myOffset1= nil;
__diff_comparison_WordChunk.prototype.myOffset2= nil;
__diff_comparison_WordChunk.prototype.myHash= nil;
__diff_comparison_WordChunk.prototype.getContent = function(self) 
  do return String.prototype.substring(self.myText, self.myOffset1, self.myOffset2) end
end
__diff_comparison_WordChunk.prototype.getOffset1 = function(self) 
  do return self.myOffset1 end
end
__diff_comparison_WordChunk.prototype.getOffset2 = function(self) 
  do return self.myOffset2 end
end
__diff_comparison_WordChunk.prototype.equals = function(self,o) 
  if (self == o) then 
    do return true end;
  end;
  local tmp;
  if (o ~= nil) then 
    local c = Type.getClass(o);
    local tmp1 = c.__name__;
    local c = Type.getClass(self);
    tmp = tmp1 ~= c.__name__;
  else
    tmp = true;
  end;
  if (tmp) then 
    do return false end;
  end;
  do return __diff_comparison_ComparisonUtil.isEquals(self:getContent(), o:getContent(), __diff_comparison_ComparisonPolicy.DEFAULT) end
end
__diff_comparison_WordChunk.prototype.hashCode = function(self) 
  do return self.myHash end
end

__diff_comparison_WordChunk.prototype.__class__ =  __diff_comparison_WordChunk

__diff_comparison_NewlineChunk.new = function(offset) 
  local self = _hx_new(__diff_comparison_NewlineChunk.prototype)
  __diff_comparison_NewlineChunk.super(self,offset)
  return self
end
__diff_comparison_NewlineChunk.super = function(self,offset) 
  self.myOffset = offset;
end
__diff_comparison_NewlineChunk.__name__ = "diff.comparison.NewlineChunk"
__diff_comparison_NewlineChunk.__interfaces__ = {__diff_comparison_InlineChunk}
__diff_comparison_NewlineChunk.prototype = _hx_e();
__diff_comparison_NewlineChunk.prototype.myOffset= nil;
__diff_comparison_NewlineChunk.prototype.getOffset1 = function(self) 
  do return self.myOffset end
end
__diff_comparison_NewlineChunk.prototype.getOffset2 = function(self) 
  do return self.myOffset + 1 end
end
__diff_comparison_NewlineChunk.prototype.equals = function(self,o) 
  if (self == o) then 
    do return true end;
  end;
  local tmp;
  if (o ~= nil) then 
    local c = Type.getClass(o);
    local tmp1 = c.__name__;
    local c = Type.getClass(self);
    tmp = tmp1 ~= c.__name__;
  else
    tmp = true;
  end;
  if (tmp) then 
    do return false end;
  end;
  do return true end
end
__diff_comparison_NewlineChunk.prototype.hashCode = function(self) 
  local c = Type.getClass(self);
  local name = c.__name__;
  local hash = 7;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(name);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    hash = (hash * 31) + __lua_lib_luautf8_Utf8.byte(name, i + 1);
  end;
  do return hash end
end

__diff_comparison_NewlineChunk.prototype.__class__ =  __diff_comparison_NewlineChunk

__diff_comparison_LineBlock.new = function(fragments,offsets,newlines1,newlines2) 
  local self = _hx_new(__diff_comparison_LineBlock.prototype)
  __diff_comparison_LineBlock.super(self,fragments,offsets,newlines1,newlines2)
  return self
end
__diff_comparison_LineBlock.super = function(self,fragments,offsets,newlines1,newlines2) 
  self.fragments = fragments;
  self.offsets = offsets;
  self.newlines1 = newlines1;
  self.newlines2 = newlines2;
end
__diff_comparison_LineBlock.__name__ = "diff.comparison.LineBlock"
__diff_comparison_LineBlock.prototype = _hx_e();
__diff_comparison_LineBlock.prototype.fragments= nil;
__diff_comparison_LineBlock.prototype.offsets= nil;
__diff_comparison_LineBlock.prototype.newlines1= nil;
__diff_comparison_LineBlock.prototype.newlines2= nil;

__diff_comparison_LineBlock.prototype.__class__ =  __diff_comparison_LineBlock

__diff_comparison_DefaultCorrector.new = function(iterable,text1,text2) 
  local self = _hx_new(__diff_comparison_DefaultCorrector.prototype)
  __diff_comparison_DefaultCorrector.super(self,iterable,text1,text2)
  return self
end
__diff_comparison_DefaultCorrector.super = function(self,iterable,text1,text2) 
  self.myIterable = iterable;
  self.myText1 = text1;
  self.myText2 = text2;
  self.myChanges = Array.new();
end
__diff_comparison_DefaultCorrector.__name__ = "diff.comparison.DefaultCorrector"
__diff_comparison_DefaultCorrector.prototype = _hx_e();
__diff_comparison_DefaultCorrector.prototype.myIterable= nil;
__diff_comparison_DefaultCorrector.prototype.myText1= nil;
__diff_comparison_DefaultCorrector.prototype.myText2= nil;
__diff_comparison_DefaultCorrector.prototype.myChanges= nil;
__diff_comparison_DefaultCorrector.prototype.build = function(self) 
  local range = self.myIterable:iterateChanges():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    local endCut = __diff_comparison_TrimUtil.expandWhitespacesBackwardA(self.myText1, self.myText2, range.start1, range.start2, range.end1, range.end2);
    local startCut = __diff_comparison_TrimUtil.expandWhitespacesForwardA(self.myText1, self.myText2, range.start1, range.start2, range.end1 - endCut, range.end2 - endCut);
    local expand = __diff_util_Range.new(Std.int(range.start1 + startCut), Std.int(range.end1 - endCut), Std.int(range.start2 + startCut), Std.int(range.end2 - endCut));
    if (not expand:isEmpty()) then 
      self.myChanges:push(expand);
    end;
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.createB(self.myChanges, __lua_lib_luautf8_Utf8.len(self.myText1), __lua_lib_luautf8_Utf8.len(self.myText2)) end
end

__diff_comparison_DefaultCorrector.prototype.__class__ =  __diff_comparison_DefaultCorrector

__diff_comparison_MergeDefaultCorrector.new = function(iterable,text1,text2,text3) 
  local self = _hx_new(__diff_comparison_MergeDefaultCorrector.prototype)
  __diff_comparison_MergeDefaultCorrector.super(self,iterable,text1,text2,text3)
  return self
end
__diff_comparison_MergeDefaultCorrector.super = function(self,iterable,text1,text2,text3) 
  self.myIterable = iterable;
  self.myText1 = text1;
  self.myText2 = text2;
  self.myText3 = text3;
  self.myChanges = Array.new();
end
__diff_comparison_MergeDefaultCorrector.__name__ = "diff.comparison.MergeDefaultCorrector"
__diff_comparison_MergeDefaultCorrector.prototype = _hx_e();
__diff_comparison_MergeDefaultCorrector.prototype.myIterable= nil;
__diff_comparison_MergeDefaultCorrector.prototype.myText1= nil;
__diff_comparison_MergeDefaultCorrector.prototype.myText2= nil;
__diff_comparison_MergeDefaultCorrector.prototype.myText3= nil;
__diff_comparison_MergeDefaultCorrector.prototype.myChanges= nil;
__diff_comparison_MergeDefaultCorrector.prototype.build = function(self) 
  local _g = 0;
  local _g1 = self.myIterable;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local range = _g1[_g];
    _g = _g + 1;
    local endCut = __diff_comparison_TrimUtil.expandWhitespacesBackwardB(self.myText1, self.myText2, self.myText3, range.start1, range.start2, range.start3, range.end1, range.end2, range.end3);
    local startCut = __diff_comparison_TrimUtil.expandWhitespacesForwardB(self.myText1, self.myText2, self.myText3, range.start1, range.start2, range.start3, range.end1 - endCut, range.end2 - endCut, range.end3 - endCut);
    local expand = __diff_util_MergeRange.new(Std.int(range.start1 + startCut), Std.int(range.end1 - endCut), Std.int(range.start2 + startCut), Std.int(range.end2 - endCut), Std.int(range.start3 + startCut), Std.int(range.end3 - endCut));
    if (not expand:isEmpty()) then 
      self.myChanges:push(expand);
    end;
  end;
  do return self.myChanges end
end

__diff_comparison_MergeDefaultCorrector.prototype.__class__ =  __diff_comparison_MergeDefaultCorrector

__diff_comparison_IgnoreSpacesCorrector.new = function(iterable,text1,text2) 
  local self = _hx_new(__diff_comparison_IgnoreSpacesCorrector.prototype)
  __diff_comparison_IgnoreSpacesCorrector.super(self,iterable,text1,text2)
  return self
end
__diff_comparison_IgnoreSpacesCorrector.super = function(self,iterable,text1,text2) 
  self.myIterable = iterable;
  self.myText1 = text1;
  self.myText2 = text2;
  self.myChanges = Array.new();
end
__diff_comparison_IgnoreSpacesCorrector.__name__ = "diff.comparison.IgnoreSpacesCorrector"
__diff_comparison_IgnoreSpacesCorrector.prototype = _hx_e();
__diff_comparison_IgnoreSpacesCorrector.prototype.myIterable= nil;
__diff_comparison_IgnoreSpacesCorrector.prototype.myText1= nil;
__diff_comparison_IgnoreSpacesCorrector.prototype.myText2= nil;
__diff_comparison_IgnoreSpacesCorrector.prototype.myChanges= nil;
__diff_comparison_IgnoreSpacesCorrector.prototype.build = function(self) 
  local range = self.myIterable:iterateChanges():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    local expanded = __diff_comparison_TrimUtil.expandWhitespacesC(self.myText1, self.myText2, range);
    local trimmed = __diff_comparison_TrimUtil.trimE(self.myText1, self.myText2, expanded);
    if (not trimmed:isEmpty() and not __diff_comparison_TrimUtil.isEqualsIgnoreWhitespacesA(self.myText1, self.myText2, trimmed)) then 
      self.myChanges:push(trimmed);
    end;
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.createB(self.myChanges, __lua_lib_luautf8_Utf8.len(self.myText1), __lua_lib_luautf8_Utf8.len(self.myText2)) end
end

__diff_comparison_IgnoreSpacesCorrector.prototype.__class__ =  __diff_comparison_IgnoreSpacesCorrector

__diff_comparison_MergeIgnoreSpacesCorrector.new = function(iterable,text1,text2,text3) 
  local self = _hx_new(__diff_comparison_MergeIgnoreSpacesCorrector.prototype)
  __diff_comparison_MergeIgnoreSpacesCorrector.super(self,iterable,text1,text2,text3)
  return self
end
__diff_comparison_MergeIgnoreSpacesCorrector.super = function(self,iterable,text1,text2,text3) 
  self.myIterable = iterable;
  self.myText1 = text1;
  self.myText2 = text2;
  self.myText3 = text3;
  self.myChanges = Array.new();
end
__diff_comparison_MergeIgnoreSpacesCorrector.__name__ = "diff.comparison.MergeIgnoreSpacesCorrector"
__diff_comparison_MergeIgnoreSpacesCorrector.prototype = _hx_e();
__diff_comparison_MergeIgnoreSpacesCorrector.prototype.myIterable= nil;
__diff_comparison_MergeIgnoreSpacesCorrector.prototype.myText1= nil;
__diff_comparison_MergeIgnoreSpacesCorrector.prototype.myText2= nil;
__diff_comparison_MergeIgnoreSpacesCorrector.prototype.myText3= nil;
__diff_comparison_MergeIgnoreSpacesCorrector.prototype.myChanges= nil;
__diff_comparison_MergeIgnoreSpacesCorrector.prototype.build = function(self) 
  local _g = 0;
  local _g1 = self.myIterable;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local range = _g1[_g];
    _g = _g + 1;
    local expanded = __diff_comparison_TrimUtil.expandWhitespacesD(self.myText1, self.myText2, self.myText3, range);
    local trimmed = __diff_comparison_TrimUtil.trimF(self.myText1, self.myText2, self.myText3, expanded);
    if (not trimmed:isEmpty() and not __diff_comparison_TrimUtil.isEqualsIgnoreWhitespacesB(self.myText1, self.myText2, self.myText3, trimmed)) then 
      self.myChanges:push(trimmed);
    end;
  end;
  do return self.myChanges end
end

__diff_comparison_MergeIgnoreSpacesCorrector.prototype.__class__ =  __diff_comparison_MergeIgnoreSpacesCorrector

__diff_comparison_TrimSpacesCorrector.new = function(iterable,text1,text2) 
  local self = _hx_new(__diff_comparison_TrimSpacesCorrector.prototype)
  __diff_comparison_TrimSpacesCorrector.super(self,iterable,text1,text2)
  return self
end
__diff_comparison_TrimSpacesCorrector.super = function(self,iterable,text1,text2) 
  self.myIterable = iterable;
  self.myText1 = text1;
  self.myText2 = text2;
  self.myChanges = Array.new();
end
__diff_comparison_TrimSpacesCorrector.__name__ = "diff.comparison.TrimSpacesCorrector"
__diff_comparison_TrimSpacesCorrector.prototype = _hx_e();
__diff_comparison_TrimSpacesCorrector.prototype.myIterable= nil;
__diff_comparison_TrimSpacesCorrector.prototype.myText1= nil;
__diff_comparison_TrimSpacesCorrector.prototype.myText2= nil;
__diff_comparison_TrimSpacesCorrector.prototype.myChanges= nil;
__diff_comparison_TrimSpacesCorrector.prototype.build = function(self) 
  local range = self.myIterable:iterateChanges():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    local start1 = range.start1;
    local start2 = range.start2;
    local end1 = range.end1;
    local end2 = range.end2;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText1, start1)) then 
      start1 = __diff_comparison_TrimUtil.trimStart(self.myText1, start1, end1);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText1, end1 - 1)) then 
      end1 = __diff_comparison_TrimUtil.trimEnd(self.myText1, start1, end1);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText2, start2)) then 
      start2 = __diff_comparison_TrimUtil.trimStart(self.myText2, start2, end2);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText2, end2 - 1)) then 
      end2 = __diff_comparison_TrimUtil.trimEnd(self.myText2, start2, end2);
    end;
    local trimmed = __diff_util_Range.new(start1, end1, start2, end2);
    if (not trimmed:isEmpty() and not __diff_comparison_TrimUtil.isEqualsA(self.myText1, self.myText2, trimmed)) then 
      self.myChanges:push(trimmed);
    end;
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.createB(self.myChanges, __lua_lib_luautf8_Utf8.len(self.myText1), __lua_lib_luautf8_Utf8.len(self.myText2)) end
end

__diff_comparison_TrimSpacesCorrector.prototype.__class__ =  __diff_comparison_TrimSpacesCorrector

__diff_comparison_MergeTrimSpacesCorrector.new = function(iterable,text1,text2,text3) 
  local self = _hx_new(__diff_comparison_MergeTrimSpacesCorrector.prototype)
  __diff_comparison_MergeTrimSpacesCorrector.super(self,iterable,text1,text2,text3)
  return self
end
__diff_comparison_MergeTrimSpacesCorrector.super = function(self,iterable,text1,text2,text3) 
  self.myIterable = iterable;
  self.myText1 = text1;
  self.myText2 = text2;
  self.myText3 = text3;
  self.myChanges = Array.new();
end
__diff_comparison_MergeTrimSpacesCorrector.__name__ = "diff.comparison.MergeTrimSpacesCorrector"
__diff_comparison_MergeTrimSpacesCorrector.prototype = _hx_e();
__diff_comparison_MergeTrimSpacesCorrector.prototype.myIterable= nil;
__diff_comparison_MergeTrimSpacesCorrector.prototype.myText1= nil;
__diff_comparison_MergeTrimSpacesCorrector.prototype.myText2= nil;
__diff_comparison_MergeTrimSpacesCorrector.prototype.myText3= nil;
__diff_comparison_MergeTrimSpacesCorrector.prototype.myChanges= nil;
__diff_comparison_MergeTrimSpacesCorrector.prototype.build = function(self) 
  local _g = 0;
  local _g1 = self.myIterable;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local range = _g1[_g];
    _g = _g + 1;
    local start1 = range.start1;
    local start2 = range.start2;
    local start3 = range.start3;
    local end1 = range.end1;
    local end2 = range.end2;
    local end3 = range.end3;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText1, start1)) then 
      start1 = __diff_comparison_TrimUtil.trimStart(self.myText1, start1, end1);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText1, end1 - 1)) then 
      end1 = __diff_comparison_TrimUtil.trimEnd(self.myText1, start1, end1);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText2, start2)) then 
      start2 = __diff_comparison_TrimUtil.trimStart(self.myText2, start2, end2);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText2, end2 - 1)) then 
      end2 = __diff_comparison_TrimUtil.trimEnd(self.myText2, start2, end2);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText3, start3)) then 
      start3 = __diff_comparison_TrimUtil.trimStart(self.myText3, start3, end3);
    end;
    if (__diff_comparison_ByWordRt.isLeadingTrailingSpace(self.myText3, end3 - 1)) then 
      end3 = __diff_comparison_TrimUtil.trimEnd(self.myText3, start3, end3);
    end;
    local trimmed = __diff_util_MergeRange.new(start1, end1, start2, end2, start3, end3);
    if (not trimmed:isEmpty() and not __diff_comparison_TrimUtil.isEqualsB(self.myText1, self.myText2, self.myText3, trimmed)) then 
      self.myChanges:push(trimmed);
    end;
  end;
  do return self.myChanges end
end

__diff_comparison_MergeTrimSpacesCorrector.prototype.__class__ =  __diff_comparison_MergeTrimSpacesCorrector

__diff_comparison_AdjustmentPunctuationMatcher.new = function(text1,text2,words1,words2,startShift1,startShift2,changes) 
  local self = _hx_new(__diff_comparison_AdjustmentPunctuationMatcher.prototype)
  __diff_comparison_AdjustmentPunctuationMatcher.super(self,text1,text2,words1,words2,startShift1,startShift2,changes)
  return self
end
__diff_comparison_AdjustmentPunctuationMatcher.super = function(self,text1,text2,words1,words2,startShift1,startShift2,changes) 
  self.myText1 = text1;
  self.myText2 = text2;
  self.myWords1 = words1;
  self.myWords2 = words2;
  self.myStartShift1 = startShift1;
  self.myStartShift2 = startShift2;
  self.myChanges = changes;
  self.myLen1 = __lua_lib_luautf8_Utf8.len(text1);
  self.myLen2 = __lua_lib_luautf8_Utf8.len(text2);
  self.myBuilder = __diff_comparison_iterables_ChangeBuilder.new(self.myLen1, self.myLen2);
end
__diff_comparison_AdjustmentPunctuationMatcher.__name__ = "diff.comparison.AdjustmentPunctuationMatcher"
__diff_comparison_AdjustmentPunctuationMatcher.prototype = _hx_e();
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myText1= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myText2= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myWords1= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myWords2= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myChanges= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myStartShift1= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myStartShift2= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myLen1= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myLen2= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.myBuilder= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.build = function(self) 
  self:execute();
  do return __diff_comparison_iterables_DiffIterableUtil.fair(self.myBuilder:finish()) end
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.lastStart1= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.lastStart2= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.lastEnd1= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.lastEnd2= nil;
__diff_comparison_AdjustmentPunctuationMatcher.prototype.execute = function(self) 
  self:clearLastRange();
  self:matchForwardA(-1, -1);
  local ch = self.myChanges:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    local count = ch.end1 - ch.start1;
    local _g = 0;
    local _g1 = count;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index1 = ch.start1 + i;
      local index2 = ch.start2 + i;
      local start1 = self:getStartOffset1(index1);
      local start2 = self:getStartOffset2(index2);
      local end1 = self:getEndOffset1(index1);
      local end2 = self:getEndOffset2(index2);
      self:matchBackwardA(index1, index2);
      self.myBuilder:markEqualC(start1, start2, end1, end2);
      self:matchForwardA(index1, index2);
    end;
  end;
  self:matchBackwardA(self.myWords1.length, self.myWords2.length);
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.clearLastRange = function(self) 
  self.lastStart1 = -1;
  self.lastStart2 = -1;
  self.lastEnd1 = -1;
  self.lastEnd2 = -1;
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchBackwardA = function(self,index1,index2) 
  local start1 = (function() 
    local _hx_1
    if (index1 == 0) then 
    _hx_1 = 0; else 
    _hx_1 = self:getEndOffset1(index1 - 1); end
    return _hx_1
  end )();
  local start2 = (function() 
    local _hx_2
    if (index2 == 0) then 
    _hx_2 = 0; else 
    _hx_2 = self:getEndOffset2(index2 - 1); end
    return _hx_2
  end )();
  local end1 = (function() 
    local _hx_3
    if (index1 == self.myWords1.length) then 
    _hx_3 = self.myLen1; else 
    _hx_3 = self:getStartOffset1(index1); end
    return _hx_3
  end )();
  local end2 = (function() 
    local _hx_4
    if (index2 == self.myWords2.length) then 
    _hx_4 = self.myLen2; else 
    _hx_4 = self:getStartOffset2(index2); end
    return _hx_4
  end )();
  self:matchBackwardB(start1, start2, end1, end2);
  self:clearLastRange();
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchForwardA = function(self,index1,index2) 
  local start1 = (function() 
    local _hx_1
    if (index1 == -1) then 
    _hx_1 = 0; else 
    _hx_1 = self:getEndOffset1(index1); end
    return _hx_1
  end )();
  local start2 = (function() 
    local _hx_2
    if (index2 == -1) then 
    _hx_2 = 0; else 
    _hx_2 = self:getEndOffset2(index2); end
    return _hx_2
  end )();
  local end1 = (function() 
    local _hx_3
    if ((index1 + 1) == self.myWords1.length) then 
    _hx_3 = self.myLen1; else 
    _hx_3 = self:getStartOffset1(index1 + 1); end
    return _hx_3
  end )();
  local end2 = (function() 
    local _hx_4
    if ((index2 + 1) == self.myWords2.length) then 
    _hx_4 = self.myLen2; else 
    _hx_4 = self:getStartOffset2(index2 + 1); end
    return _hx_4
  end )();
  self:matchForwardB(start1, start2, end1, end2);
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchForwardB = function(self,start1,start2,end1,end2) 
  self.lastStart1 = start1;
  self.lastStart2 = start2;
  self.lastEnd1 = end1;
  self.lastEnd2 = end2;
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchBackwardB = function(self,start1,start2,end1,end2) 
  if ((self.lastStart1 == start1) and (self.lastStart2 == start2)) then 
    self:matchRange(start1, start2, end1, end2);
    do return end;
  end;
  if ((self.lastStart1 < start1) and (self.lastStart2 < start2)) then 
    self:matchRange(self.lastStart1, self.lastStart2, self.lastEnd1, self.lastEnd2);
    self:matchRange(start1, start2, end1, end2);
    do return end;
  end;
  self:matchComplexRange(self.lastStart1, self.lastStart2, self.lastEnd1, self.lastEnd2, start1, start2, end1, end2);
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchRange = function(self,start1,start2,end1,end2) 
  if ((start1 == end1) and (start2 == end2)) then 
    do return end;
  end;
  local sequence1 = String.prototype.substring(self.myText1, start1, end1);
  local sequence2 = String.prototype.substring(self.myText2, start2, end2);
  local changes = __diff_comparison_ByCharRt.comparePunctuation(sequence1, sequence2);
  local ch = changes:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    self.myBuilder:markEqualC(start1 + ch.start1, start2 + ch.start2, start1 + ch.end1, start2 + ch.end2);
  end;
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchComplexRange = function(self,start11,start12,end11,end12,start21,start22,end21,end22) 
  if ((start11 == start21) and (end11 == end21)) then 
    self:matchComplexRangeLeft(start11, end11, start12, end12, start22, end22);
  else
    if ((start12 == start22) and (end12 == end22)) then 
      self:matchComplexRangeRight(start12, end12, start11, end11, start21, end21);
    else
      _G.error(__exceptions_IllegalStateException.new(""),0);
    end;
  end;
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchComplexRangeLeft = function(self,start1,end1,start12,end12,start22,end22) 
  local sequence1 = String.prototype.substring(self.myText1, start1, end1);
  local sequence21 = String.prototype.substring(self.myText2, start12, end12);
  local sequence22 = String.prototype.substring(self.myText2, start22, end22);
  local changes = __diff_comparison_ByWordRt.comparePunctuation2Side(sequence1, sequence21, sequence22);
  local ch = changes.first:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    self.myBuilder:markEqualC(start1 + ch.start1, start12 + ch.start2, start1 + ch.end1, start12 + ch.end2);
  end;
  local ch = changes.second:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    self.myBuilder:markEqualC(start1 + ch.start1, start22 + ch.start2, start1 + ch.end1, start22 + ch.end2);
  end;
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.matchComplexRangeRight = function(self,start2,end2,start11,end11,start21,end21) 
  local sequence11 = String.prototype.substring(self.myText1, start11, end11);
  local sequence12 = String.prototype.substring(self.myText1, start21, end21);
  local sequence2 = String.prototype.substring(self.myText2, start2, end2);
  local changes = __diff_comparison_ByWordRt.comparePunctuation2Side(sequence2, sequence11, sequence12);
  local ch = changes.first:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    self.myBuilder:markEqualC(start11 + ch.start2, start2 + ch.start1, start11 + ch.end2, start2 + ch.end1);
  end;
  local ch = changes.second:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    self.myBuilder:markEqualC(start21 + ch.start2, start2 + ch.start1, start21 + ch.end2, start2 + ch.end1);
  end;
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.getStartOffset1 = function(self,index) 
  do return self.myWords1[index]:getOffset1() - self.myStartShift1 end
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.getStartOffset2 = function(self,index) 
  do return self.myWords2[index]:getOffset1() - self.myStartShift2 end
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.getEndOffset1 = function(self,index) 
  do return self.myWords1[index]:getOffset2() - self.myStartShift1 end
end
__diff_comparison_AdjustmentPunctuationMatcher.prototype.getEndOffset2 = function(self,index) 
  do return self.myWords2[index]:getOffset2() - self.myStartShift2 end
end

__diff_comparison_AdjustmentPunctuationMatcher.prototype.__class__ =  __diff_comparison_AdjustmentPunctuationMatcher

__diff_comparison__ByWordRt_ByWordRt_Fields_.new = {}
__diff_comparison__ByWordRt_ByWordRt_Fields_.__name__ = "diff.comparison._ByWordRt.ByWordRt_Fields_"
__diff_comparison__ByWordRt_ByWordRt_Fields_.charCount = function(ch) 
  if (ch >= 65536) then 
    do return 2 end;
  end;
  do return 1 end;
end

__diff_comparison_ChangeCorrector.new = function(length1,length2,changes) 
  local self = _hx_new(__diff_comparison_ChangeCorrector.prototype)
  __diff_comparison_ChangeCorrector.super(self,length1,length2,changes)
  return self
end
__diff_comparison_ChangeCorrector.super = function(self,length1,length2,changes) 
  self.myLength1 = length1;
  self.myLength2 = length2;
  self.myChanges = changes;
  self.myBuilder = __diff_comparison_iterables_ChangeBuilder.new(length1, length2);
end
__diff_comparison_ChangeCorrector.__name__ = "diff.comparison.ChangeCorrector"
__diff_comparison_ChangeCorrector.prototype = _hx_e();
__diff_comparison_ChangeCorrector.prototype.myLength1= nil;
__diff_comparison_ChangeCorrector.prototype.myLength2= nil;
__diff_comparison_ChangeCorrector.prototype.myChanges= nil;
__diff_comparison_ChangeCorrector.prototype.myBuilder= nil;
__diff_comparison_ChangeCorrector.prototype.build = function(self) 
  self:execute();
  do return __diff_comparison_iterables_DiffIterableUtil.fair(self.myBuilder:finish()) end
end
__diff_comparison_ChangeCorrector.prototype.execute = function(self) 
  local last1 = 0;
  local last2 = 0;
  local ch = self.myChanges:iterateUnchanged():iterator();
  while (ch:hasNext()) do _hx_do_first_1 = false;
    
    local ch = ch:next();
    local count = ch.end1 - ch.start1;
    local _g = 0;
    local _g1 = count;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local range1 = self:getOriginalRange1(ch.start1 + i);
      local range2 = self:getOriginalRange2(ch.start2 + i);
      local start1 = range1.first;
      local start2 = range2.first;
      local end1 = range1.second;
      local end2 = range2.second;
      self:matchGap(last1, start1, last2, start2);
      self.myBuilder:markEqualC(start1, start2, end1, end2);
      last1 = end1;
      last2 = end2;
    end;
  end;
  self:matchGap(last1, self.myLength1, last2, self.myLength2);
end
__diff_comparison_ChangeCorrector.prototype.matchGap= nil;
__diff_comparison_ChangeCorrector.prototype.getOriginalRange1= nil;
__diff_comparison_ChangeCorrector.prototype.getOriginalRange2= nil;

__diff_comparison_ChangeCorrector.prototype.__class__ =  __diff_comparison_ChangeCorrector

__diff_comparison_DefaultCharChangeCorrector.new = function(codePoints1,codePoints2,text1,text2,changes) 
  local self = _hx_new(__diff_comparison_DefaultCharChangeCorrector.prototype)
  __diff_comparison_DefaultCharChangeCorrector.super(self,codePoints1,codePoints2,text1,text2,changes)
  return self
end
__diff_comparison_DefaultCharChangeCorrector.super = function(self,codePoints1,codePoints2,text1,text2,changes) 
  __diff_comparison_ChangeCorrector.super(self,__lua_lib_luautf8_Utf8.len(text1),__lua_lib_luautf8_Utf8.len(text2),changes);
  self.myCodePoints1 = codePoints1;
  self.myCodePoints2 = codePoints2;
  self.myText1 = text1;
  self.myText2 = text2;
end
__diff_comparison_DefaultCharChangeCorrector.__name__ = "diff.comparison.DefaultCharChangeCorrector"
__diff_comparison_DefaultCharChangeCorrector.prototype = _hx_e();
__diff_comparison_DefaultCharChangeCorrector.prototype.myCodePoints1= nil;
__diff_comparison_DefaultCharChangeCorrector.prototype.myCodePoints2= nil;
__diff_comparison_DefaultCharChangeCorrector.prototype.myText1= nil;
__diff_comparison_DefaultCharChangeCorrector.prototype.myText2= nil;
__diff_comparison_DefaultCharChangeCorrector.prototype.matchGap = function(self,start1,end1,start2,end2) 
  local inner1 = String.prototype.substring(self.myText1, start1, end1);
  local inner2 = String.prototype.substring(self.myText2, start2, end2);
  local innerChanges = __diff_comparison_ByCharRt.compare(inner1, inner2);
  local chunk = innerChanges:iterateUnchanged():iterator();
  while (chunk:hasNext()) do _hx_do_first_1 = false;
    
    local chunk = chunk:next();
    self.myBuilder:markEqualB(start1 + chunk.start1, start2 + chunk.start2, chunk.end1 - chunk.start1);
  end;
end
__diff_comparison_DefaultCharChangeCorrector.prototype.getOriginalRange1 = function(self,index) 
  local startOffset = self.myCodePoints1:charOffset(index);
  local endOffset = self.myCodePoints1:charOffsetAfter(index);
  do return __ds_Pair.new(startOffset, endOffset) end
end
__diff_comparison_DefaultCharChangeCorrector.prototype.getOriginalRange2 = function(self,index) 
  local startOffset = self.myCodePoints2:charOffset(index);
  local endOffset = self.myCodePoints2:charOffsetAfter(index);
  do return __ds_Pair.new(startOffset, endOffset) end
end

__diff_comparison_DefaultCharChangeCorrector.prototype.__class__ =  __diff_comparison_DefaultCharChangeCorrector
__diff_comparison_DefaultCharChangeCorrector.__super__ = __diff_comparison_ChangeCorrector
setmetatable(__diff_comparison_DefaultCharChangeCorrector.prototype,{__index=__diff_comparison_ChangeCorrector.prototype})

__diff_comparison_SmartLineChangeCorrector.new = function(indexes1,indexes2,lines1,lines2,changes) 
  local self = _hx_new(__diff_comparison_SmartLineChangeCorrector.prototype)
  __diff_comparison_SmartLineChangeCorrector.super(self,indexes1,indexes2,lines1,lines2,changes)
  return self
end
__diff_comparison_SmartLineChangeCorrector.super = function(self,indexes1,indexes2,lines1,lines2,changes) 
  __diff_comparison_ChangeCorrector.super(self,lines1.length,lines2.length,changes);
  self.myIndexes1 = indexes1;
  self.myIndexes2 = indexes2;
  self.myLines1 = lines1;
  self.myLines2 = lines2;
end
__diff_comparison_SmartLineChangeCorrector.__name__ = "diff.comparison.SmartLineChangeCorrector"
__diff_comparison_SmartLineChangeCorrector.prototype = _hx_e();
__diff_comparison_SmartLineChangeCorrector.prototype.myIndexes1= nil;
__diff_comparison_SmartLineChangeCorrector.prototype.myIndexes2= nil;
__diff_comparison_SmartLineChangeCorrector.prototype.myLines1= nil;
__diff_comparison_SmartLineChangeCorrector.prototype.myLines2= nil;
__diff_comparison_SmartLineChangeCorrector.prototype.matchGap = function(self,start1,end1,start2,end2) 
  local expand = __diff_comparison_TrimUtil.expandA(self.myLines1, self.myLines2, start1, start2, end1, end2);
  local inner1 = self.myLines1:slice(expand.start1, expand.end1);
  local inner2 = self.myLines2:slice(expand.start2, expand.end2);
  local innerChanges = __diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_Line(inner1, inner2);
  self.myBuilder:markEqualC(start1, start2, expand.start1, expand.start2);
  local chunk = innerChanges:iterateUnchanged():iterator();
  while (chunk:hasNext()) do _hx_do_first_1 = false;
    
    local chunk = chunk:next();
    self.myBuilder:markEqualB(expand.start1 + chunk.start1, expand.start2 + chunk.start2, chunk.end1 - chunk.start1);
  end;
  self.myBuilder:markEqualC(expand.end1, expand.end2, end1, end2);
end
__diff_comparison_SmartLineChangeCorrector.prototype.getOriginalRange1 = function(self,index) 
  local offset = self.myIndexes1[index];
  do return __ds_Pair.new(offset, offset + 1) end
end
__diff_comparison_SmartLineChangeCorrector.prototype.getOriginalRange2 = function(self,index) 
  local offset = self.myIndexes2[index];
  do return __ds_Pair.new(offset, offset + 1) end
end

__diff_comparison_SmartLineChangeCorrector.prototype.__class__ =  __diff_comparison_SmartLineChangeCorrector
__diff_comparison_SmartLineChangeCorrector.__super__ = __diff_comparison_ChangeCorrector
setmetatable(__diff_comparison_SmartLineChangeCorrector.prototype,{__index=__diff_comparison_ChangeCorrector.prototype})

__diff_comparison_ChunkOptimizer.new = function(data1,data2,iterable) 
  local self = _hx_new(__diff_comparison_ChunkOptimizer.prototype)
  __diff_comparison_ChunkOptimizer.super(self,data1,data2,iterable)
  return self
end
__diff_comparison_ChunkOptimizer.super = function(self,data1,data2,iterable) 
  self.myData1 = data1;
  self.myData2 = data2;
  self.myIterable = iterable;
  self.myRanges = Array.new();
end
__diff_comparison_ChunkOptimizer.__name__ = "diff.comparison.ChunkOptimizer"
__diff_comparison_ChunkOptimizer.prototype = _hx_e();
__diff_comparison_ChunkOptimizer.prototype.myData1= nil;
__diff_comparison_ChunkOptimizer.prototype.myData2= nil;
__diff_comparison_ChunkOptimizer.prototype.myIterable= nil;
__diff_comparison_ChunkOptimizer.prototype.myRanges= nil;
__diff_comparison_ChunkOptimizer.prototype.build = function(self) 
  local range = self.myIterable:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    self.myRanges:push(range);
    self:processLastRanges();
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createUnchanged(self.myRanges, self.myData1.length, self.myData2.length)) end
end
__diff_comparison_ChunkOptimizer.prototype.processLastRanges = function(self) 
  if (self.myRanges.length < 2) then 
    do return end;
  end;
  local range1 = self.myRanges[self.myRanges.length - 2];
  local range2 = self.myRanges[self.myRanges.length - 1];
  if ((range1.end1 ~= range2.start1) and (range1.end2 ~= range2.start2)) then 
    do return end;
  end;
  local count1 = range1.end1 - range1.start1;
  local count2 = range2.end1 - range2.start1;
  local equalForward = __diff_comparison_TrimUtil.expandForwardA(self.myData1, self.myData2, range1.end1, range1.end2, range1.end1 + count2, range1.end2 + count2);
  local equalBackward = __diff_comparison_TrimUtil.expandBackwardA(self.myData1, self.myData2, range2.start1 - count1, range2.start2 - count1, range2.start1, range2.start2);
  if ((equalForward == 0) and (equalBackward == 0)) then 
    do return end;
  end;
  if (equalForward == count2) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range1.start1, range1.end1 + count2, range1.start2, range1.end2 + count2));
    self:processLastRanges();
    do return end;
  end;
  if (equalBackward == count1) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range2.start1 - count1, range2.end1, range2.start2 - count1, range2.end2));
    self:processLastRanges();
    do return end;
  end;
  local touchSide = __diff_util_Side.fromEnum(__diff_util_Side.fromLeft(range1.end1 == range2.start1));
  local shift = self:getShift(touchSide, equalForward, equalBackward, range1, range2);
  if (shift ~= 0) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range1.start1, range1.end1 + shift, range1.start2, range1.end2 + shift));
    self.myRanges:push(__diff_util_Range.new(range2.start1 + shift, range2.end1, range2.start2 + shift, range2.end2));
  end;
end
__diff_comparison_ChunkOptimizer.prototype.getShift= nil;

__diff_comparison_ChunkOptimizer.prototype.__class__ =  __diff_comparison_ChunkOptimizer

__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.new = function(data1,data2,iterable) 
  local self = _hx_new(__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype)
  __diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.super(self,data1,data2,iterable)
  return self
end
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.super = function(self,data1,data2,iterable) 
  self.myData1 = data1;
  self.myData2 = data2;
  self.myIterable = iterable;
  self.myRanges = Array.new();
end
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.__name__ = "diff.comparison.ChunkOptimizer_diff_comparison_InlineChunk_Dynamic"
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype = _hx_e();
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.myData1= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.myData2= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.myIterable= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.myRanges= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.build = function(self) 
  local range = self.myIterable:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    self.myRanges:push(range);
    self:processLastRanges();
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createUnchanged(self.myRanges, self.myData1.length, self.myData2.length)) end
end
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.processLastRanges = function(self) 
  if (self.myRanges.length < 2) then 
    do return end;
  end;
  local range1 = self.myRanges[self.myRanges.length - 2];
  local range2 = self.myRanges[self.myRanges.length - 1];
  if ((range1.end1 ~= range2.start1) and (range1.end2 ~= range2.start2)) then 
    do return end;
  end;
  local count1 = range1.end1 - range1.start1;
  local count2 = range2.end1 - range2.start1;
  local equalForward = __diff_comparison_TrimUtil.expandForwardA(self.myData1, self.myData2, range1.end1, range1.end2, range1.end1 + count2, range1.end2 + count2);
  local equalBackward = __diff_comparison_TrimUtil.expandBackwardA(self.myData1, self.myData2, range2.start1 - count1, range2.start2 - count1, range2.start1, range2.start2);
  if ((equalForward == 0) and (equalBackward == 0)) then 
    do return end;
  end;
  if (equalForward == count2) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range1.start1, range1.end1 + count2, range1.start2, range1.end2 + count2));
    self:processLastRanges();
    do return end;
  end;
  if (equalBackward == count1) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range2.start1 - count1, range2.end1, range2.start2 - count1, range2.end2));
    self:processLastRanges();
    do return end;
  end;
  local touchSide = __diff_util_Side.fromEnum(__diff_util_Side.fromLeft(range1.end1 == range2.start1));
  local shift = self:getShift(touchSide, equalForward, equalBackward, range1, range2);
  if (shift ~= 0) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range1.start1, range1.end1 + shift, range1.start2, range1.end2 + shift));
    self.myRanges:push(__diff_util_Range.new(range2.start1 + shift, range2.end1, range2.start2 + shift, range2.end2));
  end;
end
__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.getShift= nil;

__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype.__class__ =  __diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic

__diff_comparison_WordChunkOptimizer.new = function(words1,words2,text1,text2,changes) 
  local self = _hx_new(__diff_comparison_WordChunkOptimizer.prototype)
  __diff_comparison_WordChunkOptimizer.super(self,words1,words2,text1,text2,changes)
  return self
end
__diff_comparison_WordChunkOptimizer.super = function(self,words1,words2,text1,text2,changes) 
  __diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.super(self,words1,words2,changes);
  self.myText1 = text1;
  self.myText2 = text2;
end
__diff_comparison_WordChunkOptimizer.__name__ = "diff.comparison.WordChunkOptimizer"
__diff_comparison_WordChunkOptimizer.findSequenceEdgeShift = function(text,words,offset,count,leftToRight) 
  local _g = 0;
  local _g1 = count;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local word1;
    local word2;
    if (leftToRight) then 
      word1 = words[offset + i];
      word2 = words[(offset + i) + 1];
    else
      word1 = words[(offset - i) - 1];
      word2 = words[offset - i];
    end;
    if (__diff_comparison_WordChunkOptimizer.isSeparatedWithWhitespace(text, word1, word2)) then 
      do return i + 1 end;
    end;
  end;
  do return -1 end;
end
__diff_comparison_WordChunkOptimizer.isSeparatedWithWhitespace = function(text,word1,word2) 
  if (((function() 
    local _hx_1
    if (__lua_Boot.__instanceof(word1, __diff_comparison_NewlineChunk)) then 
    _hx_1 = word1; else 
    _hx_1 = nil; end
    return _hx_1
  end )() ~= nil) or ((function() 
    local _hx_2
    if (__lua_Boot.__instanceof(word2, __diff_comparison_NewlineChunk)) then 
    _hx_2 = word2; else 
    _hx_2 = nil; end
    return _hx_2
  end )() ~= nil)) then 
    do return true end;
  end;
  local offset1 = word1:getOffset2();
  local offset2 = word2:getOffset1();
  local _g = offset1;
  local _g1 = offset2;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (__diff_comparison_TrimUtil.isWhiteSpace(__lua_lib_luautf8_Utf8.sub(text, i + 1, i + 1))) then 
      do return true end;
    end;
  end;
  do return false end;
end
__diff_comparison_WordChunkOptimizer.prototype = _hx_e();
__diff_comparison_WordChunkOptimizer.prototype.myText1= nil;
__diff_comparison_WordChunkOptimizer.prototype.myText2= nil;
__diff_comparison_WordChunkOptimizer.prototype.getShift = function(self,touchSide,equalForward,equalBackward,range1,range2) 
  local touchWords = touchSide:selectA_Array_diff_comparison_InlineChunk_Dynamic(self.myData1, self.myData2);
  local touchText = touchSide:selectA_String(self.myText1, self.myText2);
  local touchStart = touchSide:selectA_Int(range2.start1, range2.start2);
  if (__diff_comparison_WordChunkOptimizer.isSeparatedWithWhitespace(touchText, touchWords[touchStart - 1], touchWords[touchStart])) then 
    do return 0 end;
  end;
  local leftShift = __diff_comparison_WordChunkOptimizer.findSequenceEdgeShift(touchText, touchWords, touchStart, equalForward, true);
  if (leftShift > 0) then 
    do return leftShift end;
  end;
  local rightShift = __diff_comparison_WordChunkOptimizer.findSequenceEdgeShift(touchText, touchWords, touchStart - 1, equalBackward, false);
  if (rightShift > 0) then 
    do return -rightShift end;
  end;
  do return 0 end
end

__diff_comparison_WordChunkOptimizer.prototype.__class__ =  __diff_comparison_WordChunkOptimizer
__diff_comparison_WordChunkOptimizer.__super__ = __diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic
setmetatable(__diff_comparison_WordChunkOptimizer.prototype,{__index=__diff_comparison_ChunkOptimizer_diff_comparison_InlineChunk_Dynamic.prototype})

__diff_comparison_ChunkOptimizer_diff_comparison_Line.new = function(data1,data2,iterable) 
  local self = _hx_new(__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype)
  __diff_comparison_ChunkOptimizer_diff_comparison_Line.super(self,data1,data2,iterable)
  return self
end
__diff_comparison_ChunkOptimizer_diff_comparison_Line.super = function(self,data1,data2,iterable) 
  self.myData1 = data1;
  self.myData2 = data2;
  self.myIterable = iterable;
  self.myRanges = Array.new();
end
__diff_comparison_ChunkOptimizer_diff_comparison_Line.__name__ = "diff.comparison.ChunkOptimizer_diff_comparison_Line"
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype = _hx_e();
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.myData1= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.myData2= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.myIterable= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.myRanges= nil;
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.build = function(self) 
  local range = self.myIterable:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    self.myRanges:push(range);
    self:processLastRanges();
  end;
  do return __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createUnchanged(self.myRanges, self.myData1.length, self.myData2.length)) end
end
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.processLastRanges = function(self) 
  if (self.myRanges.length < 2) then 
    do return end;
  end;
  local range1 = self.myRanges[self.myRanges.length - 2];
  local range2 = self.myRanges[self.myRanges.length - 1];
  if ((range1.end1 ~= range2.start1) and (range1.end2 ~= range2.start2)) then 
    do return end;
  end;
  local count1 = range1.end1 - range1.start1;
  local count2 = range2.end1 - range2.start1;
  local equalForward = __diff_comparison_TrimUtil.expandForwardA(self.myData1, self.myData2, range1.end1, range1.end2, range1.end1 + count2, range1.end2 + count2);
  local equalBackward = __diff_comparison_TrimUtil.expandBackwardA(self.myData1, self.myData2, range2.start1 - count1, range2.start2 - count1, range2.start1, range2.start2);
  if ((equalForward == 0) and (equalBackward == 0)) then 
    do return end;
  end;
  if (equalForward == count2) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range1.start1, range1.end1 + count2, range1.start2, range1.end2 + count2));
    self:processLastRanges();
    do return end;
  end;
  if (equalBackward == count1) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range2.start1 - count1, range2.end1, range2.start2 - count1, range2.end2));
    self:processLastRanges();
    do return end;
  end;
  local touchSide = __diff_util_Side.fromEnum(__diff_util_Side.fromLeft(range1.end1 == range2.start1));
  local shift = self:getShift(touchSide, equalForward, equalBackward, range1, range2);
  if (shift ~= 0) then 
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:splice(self.myRanges.length - 1, 1);
    self.myRanges:push(__diff_util_Range.new(range1.start1, range1.end1 + shift, range1.start2, range1.end2 + shift));
    self.myRanges:push(__diff_util_Range.new(range2.start1 + shift, range2.end1, range2.start2 + shift, range2.end2));
  end;
end
__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.getShift= nil;

__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype.__class__ =  __diff_comparison_ChunkOptimizer_diff_comparison_Line

__diff_comparison_LineChunkOptimizer.new = function(lines1,lines2,changes) 
  local self = _hx_new(__diff_comparison_LineChunkOptimizer.prototype)
  __diff_comparison_LineChunkOptimizer.super(self,lines1,lines2,changes)
  return self
end
__diff_comparison_LineChunkOptimizer.super = function(self,lines1,lines2,changes) 
  __diff_comparison_ChunkOptimizer_diff_comparison_Line.super(self,lines1,lines2,changes);
end
__diff_comparison_LineChunkOptimizer.__name__ = "diff.comparison.LineChunkOptimizer"
__diff_comparison_LineChunkOptimizer.getShiftB = function(shiftForward,shiftBackward) 
  if ((shiftForward == -1) and (shiftBackward == -1)) then 
    do return nil end;
  end;
  if ((shiftForward == 0) or (shiftBackward == 0)) then 
    do return 0 end;
  end;
  if (shiftForward ~= -1) then 
    do return shiftForward end;
  else
    do return -shiftBackward end;
  end;
end
__diff_comparison_LineChunkOptimizer.findNextUnimportantLine = function(lines,offset,count,threshold) 
  local _g = 0;
  local _g1 = count;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (lines[offset + i]:getNonSpaceChars() <= threshold) then 
      do return i end;
    end;
  end;
  do return -1 end;
end
__diff_comparison_LineChunkOptimizer.findPrevUnimportantLine = function(lines,offset,count,threshold) 
  local _g = 0;
  local _g1 = count;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (lines[offset - i]:getNonSpaceChars() <= threshold) then 
      do return i end;
    end;
  end;
  do return -1 end;
end
__diff_comparison_LineChunkOptimizer.prototype = _hx_e();
__diff_comparison_LineChunkOptimizer.prototype.getShift = function(self,touchSide,equalForward,equalBackward,range1,range2) 
  local threshold = __diff_comparison_ComparisonUtil.getUnimportantLineCharCount();
  local shift = self:getUnchangedBoundaryShift(touchSide, equalForward, equalBackward, range1, range2, 0);
  if (shift ~= nil) then 
    do return shift end;
  end;
  shift = self:getChangedBoundaryShift(touchSide, equalForward, equalBackward, range1, range2, 0);
  if (shift ~= nil) then 
    do return shift end;
  end;
  shift = self:getUnchangedBoundaryShift(touchSide, equalForward, equalBackward, range1, range2, threshold);
  if (shift ~= nil) then 
    do return shift end;
  end;
  shift = self:getChangedBoundaryShift(touchSide, equalForward, equalBackward, range1, range2, threshold);
  if (shift ~= nil) then 
    do return shift end;
  end;
  do return 0 end
end
__diff_comparison_LineChunkOptimizer.prototype.getUnchangedBoundaryShift = function(self,touchSide,equalForward,equalBackward,range1,range2,threshold) 
  local touchLines = touchSide:selectA_Array_diff_comparison_Line(self.myData1, self.myData2);
  local touchStart = touchSide:selectA_Int(range2.start1, range2.start2);
  local shiftForward = __diff_comparison_LineChunkOptimizer.findNextUnimportantLine(touchLines, touchStart, equalForward + 1, threshold);
  local shiftBackward = __diff_comparison_LineChunkOptimizer.findPrevUnimportantLine(touchLines, touchStart - 1, equalBackward + 1, threshold);
  do return __diff_comparison_LineChunkOptimizer.getShiftB(shiftForward, shiftBackward) end
end
__diff_comparison_LineChunkOptimizer.prototype.getChangedBoundaryShift = function(self,touchSide,equalForward,equalBackward,range1,range2,threshold) 
  local nonTouchSide = __diff_util_Side.fromEnum(touchSide:other());
  local nonTouchLines = nonTouchSide:selectA_Array_diff_comparison_Line(self.myData1, self.myData2);
  local changeStart = nonTouchSide:selectA_Int(range1.end1, range1.end2);
  local changeEnd = nonTouchSide:selectA_Int(range2.start1, range2.start2);
  local shiftForward = __diff_comparison_LineChunkOptimizer.findNextUnimportantLine(nonTouchLines, changeStart, equalForward + 1, threshold);
  local shiftBackward = __diff_comparison_LineChunkOptimizer.findPrevUnimportantLine(nonTouchLines, changeEnd - 1, equalBackward + 1, threshold);
  do return __diff_comparison_LineChunkOptimizer.getShiftB(shiftForward, shiftBackward) end
end

__diff_comparison_LineChunkOptimizer.prototype.__class__ =  __diff_comparison_LineChunkOptimizer
__diff_comparison_LineChunkOptimizer.__super__ = __diff_comparison_ChunkOptimizer_diff_comparison_Line
setmetatable(__diff_comparison_LineChunkOptimizer.prototype,{__index=__diff_comparison_ChunkOptimizer_diff_comparison_Line.prototype})

__diff_comparison_SideEquality.new = function(func) 
  local self = _hx_new(__diff_comparison_SideEquality.prototype)
  __diff_comparison_SideEquality.super(self,func)
  return self
end
__diff_comparison_SideEquality.super = function(self,func) 
  self.equals = func;
end
__diff_comparison_SideEquality.__name__ = "diff.comparison.SideEquality"
__diff_comparison_SideEquality.prototype = _hx_e();
__diff_comparison_SideEquality.prototype.equals= nil;

__diff_comparison_SideEquality.prototype.__class__ =  __diff_comparison_SideEquality

__diff_comparison_ComparisonMergeUtil.new = {}
__diff_comparison_ComparisonMergeUtil.__name__ = "diff.comparison.ComparisonMergeUtil"
__diff_comparison_ComparisonMergeUtil.buildSimple = function(fragments1,fragments2) 
  do return __diff_comparison_FairMergeBuilder.new():execute(fragments1, fragments2) end;
end
__diff_comparison_ComparisonMergeUtil.buildMerge = function(fragments1,fragments2,trueEquality) 
  do return __diff_comparison_FairMergeBuilder.new(trueEquality):execute(fragments1, fragments2) end;
end
__diff_comparison_ComparisonMergeUtil.tryResolveConflict = function(leftText,baseText,rightText) 
  if (__config_DiffConfig.USE_GREEDY_MERGE_MAGIC_RESOLVE) then 
    do return __diff_comparison_MergeResolveUtil.tryGreedyResolve(leftText, baseText, rightText) end;
  else
    do return __diff_comparison_MergeResolveUtil.tryResolve(leftText, baseText, rightText) end;
  end;
end

__diff_comparison_FairMergeBuilder.new = function(trueEquality) 
  local self = _hx_new(__diff_comparison_FairMergeBuilder.prototype)
  __diff_comparison_FairMergeBuilder.super(self,trueEquality)
  return self
end
__diff_comparison_FairMergeBuilder.super = function(self,trueEquality) 
  if (trueEquality ~= nil) then 
    self.myChangesBuilder = __diff_comparison_IgnoringChangeBuilder.new(trueEquality);
    do return end;
  end;
  self.myChangesBuilder = __diff_comparison_ChangeBuilder.new();
end
__diff_comparison_FairMergeBuilder.__name__ = "diff.comparison.FairMergeBuilder"
__diff_comparison_FairMergeBuilder.prototype = _hx_e();
__diff_comparison_FairMergeBuilder.prototype.myChangesBuilder= nil;
__diff_comparison_FairMergeBuilder.prototype.execute = function(self,fragments1,fragments2) 
  local unchanged1 = __iterators_PeekableIteratorWrapper.new(fragments1:iterateUnchanged());
  local unchanged2 = __iterators_PeekableIteratorWrapper.new(fragments2:iterateUnchanged());
  while (unchanged1:hasNext() and unchanged2:hasNext()) do _hx_do_first_1 = false;
    
    local sideEnum = self:add(unchanged1:peek(), unchanged2:peek());
    local side = __diff_util_Side.fromEnum(sideEnum);
    side:selectA_iterators_PeekableIteratorWrapper_diff_util_Range(unchanged1, unchanged2):next();
  end;
  do return self.myChangesBuilder:finish(fragments1:getLength2(), fragments1:getLength1(), fragments2:getLength2()) end
end
__diff_comparison_FairMergeBuilder.prototype.add = function(self,range1,range2) 
  local start1 = range1.start1;
  local end1 = range1.end1;
  local start2 = range2.start1;
  local end2 = range2.end1;
  if (end1 <= start2) then 
    do return __diff_util_SideEnum.LEFT end;
  end;
  if (end2 <= start1) then 
    do return __diff_util_SideEnum.RIGHT end;
  end;
  local startBase = Std.int(Math.max(start1, start2));
  local endBase = Std.int(Math.min(end1, end2));
  local count = endBase - startBase;
  local startShift1 = startBase - start1;
  local startShift2 = startBase - start2;
  local startLeft = range1.start2 + startShift1;
  local endLeft = startLeft + count;
  local startRight = range2.start2 + startShift2;
  local endRight = startRight + count;
  self.myChangesBuilder:markEqual(startLeft, startBase, startRight, endLeft, endBase, endRight);
  do return __diff_util_Side.fromLeft(end1 <= end2) end
end

__diff_comparison_FairMergeBuilder.prototype.__class__ =  __diff_comparison_FairMergeBuilder

__diff_comparison_ChangeBuilder.new = function() 
  local self = _hx_new(__diff_comparison_ChangeBuilder.prototype)
  __diff_comparison_ChangeBuilder.super(self)
  return self
end
__diff_comparison_ChangeBuilder.super = function(self) 
  self.myIndex3 = 0;
  self.myIndex2 = 0;
  self.myIndex1 = 0;
  self.myChanges = Array.new();
end
__diff_comparison_ChangeBuilder.__name__ = "diff.comparison.ChangeBuilder"
__diff_comparison_ChangeBuilder.prototype = _hx_e();
__diff_comparison_ChangeBuilder.prototype.myChanges= nil;
__diff_comparison_ChangeBuilder.prototype.myIndex1= nil;
__diff_comparison_ChangeBuilder.prototype.myIndex2= nil;
__diff_comparison_ChangeBuilder.prototype.myIndex3= nil;
__diff_comparison_ChangeBuilder.prototype.addChange = function(self,start1,start2,start3,end1,end2,end3) 
  if (((start1 == end1) and (start2 == end2)) and (start3 == end3)) then 
    do return end;
  end;
  self.myChanges:push(__diff_util_MergeRange.new(start1, end1, start2, end2, start3, end3));
end
__diff_comparison_ChangeBuilder.prototype.markEqual = function(self,start1,start2,start3,end1,end2,end3) 
  self:processChange(self.myIndex1, self.myIndex2, self.myIndex3, start1, start2, start3);
  self.myIndex1 = end1;
  self.myIndex2 = end2;
  self.myIndex3 = end3;
end
__diff_comparison_ChangeBuilder.prototype.finish = function(self,length1,length2,length3) 
  self:processChange(self.myIndex1, self.myIndex2, self.myIndex3, length1, length2, length3);
  do return self.myChanges end
end
__diff_comparison_ChangeBuilder.prototype.processChange = function(self,start1,start2,start3,end1,end2,end3) 
  self:addChange(start1, start2, start3, end1, end2, end3);
end

__diff_comparison_ChangeBuilder.prototype.__class__ =  __diff_comparison_ChangeBuilder

__diff_comparison_IgnoringChangeBuilder.new = function(trueEquality) 
  local self = _hx_new(__diff_comparison_IgnoringChangeBuilder.prototype)
  __diff_comparison_IgnoringChangeBuilder.super(self,trueEquality)
  return self
end
__diff_comparison_IgnoringChangeBuilder.super = function(self,trueEquality) 
  __diff_comparison_ChangeBuilder.super(self);
  self.myTrueEquality = trueEquality;
end
__diff_comparison_IgnoringChangeBuilder.__name__ = "diff.comparison.IgnoringChangeBuilder"
__diff_comparison_IgnoringChangeBuilder.prototype = _hx_e();
__diff_comparison_IgnoringChangeBuilder.prototype.myTrueEquality= nil;
__diff_comparison_IgnoringChangeBuilder.prototype.processChange = function(self,start1,start2,start3,end1,end2,end3) 
  local lastChange = (function() 
    local _hx_1
    if (self.myChanges.length == 0) then 
    _hx_1 = nil; else 
    _hx_1 = self.myChanges[self.myChanges.length - 1]; end
    return _hx_1
  end )();
  local unchangedStart1 = (function() 
    local _hx_2
    if (lastChange ~= nil) then 
    _hx_2 = lastChange.end1; else 
    _hx_2 = 0; end
    return _hx_2
  end )();
  local unchangedStart2 = (function() 
    local _hx_3
    if (lastChange ~= nil) then 
    _hx_3 = lastChange.end2; else 
    _hx_3 = 0; end
    return _hx_3
  end )();
  local unchangedStart3 = (function() 
    local _hx_4
    if (lastChange ~= nil) then 
    _hx_4 = lastChange.end3; else 
    _hx_4 = 0; end
    return _hx_4
  end )();
  self:addIgnoredChanges(unchangedStart1, unchangedStart2, unchangedStart3, start1, start2, start3);
  self:addChange(start1, start2, start3, end1, end2, end3);
end
__diff_comparison_IgnoringChangeBuilder.prototype.addIgnoredChanges = function(self,start1,start2,start3,end1,end2,end3) 
  local count = end2 - start2;
  local firstIgnoredCount = -1;
  local _g = 0;
  local _g1 = count;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local isIgnored = not self.myTrueEquality.equals(start1 + i, start2 + i, start3 + i);
    local previousAreIgnored = firstIgnoredCount ~= -1;
    if (isIgnored and not previousAreIgnored) then 
      firstIgnoredCount = i;
    end;
    if (not isIgnored and previousAreIgnored) then 
      self:addChange(start1 + firstIgnoredCount, start2 + firstIgnoredCount, start3 + firstIgnoredCount, start1 + i, start2 + i, start3 + i);
      firstIgnoredCount = -1;
    end;
  end;
  if (firstIgnoredCount ~= -1) then 
    self:addChange(start1 + firstIgnoredCount, start2 + firstIgnoredCount, start3 + firstIgnoredCount, start1 + count, start2 + count, start3 + count);
  end;
end

__diff_comparison_IgnoringChangeBuilder.prototype.__class__ =  __diff_comparison_IgnoringChangeBuilder
__diff_comparison_IgnoringChangeBuilder.__super__ = __diff_comparison_ChangeBuilder
setmetatable(__diff_comparison_IgnoringChangeBuilder.prototype,{__index=__diff_comparison_ChangeBuilder.prototype})
_hxClasses["diff.comparison.ComparisonPolicy"] = { __ename__ = "diff.comparison.ComparisonPolicy", __constructs__ = _hx_tab_array({[0]="DEFAULT","TRIM_WHITESPACES","IGNORE_WHITESPACES"},3)}
__diff_comparison_ComparisonPolicy = _hxClasses["diff.comparison.ComparisonPolicy"];
__diff_comparison_ComparisonPolicy.DEFAULT = _hx_tab_array({[0]="DEFAULT",0,__enum__ = __diff_comparison_ComparisonPolicy},2)

__diff_comparison_ComparisonPolicy.TRIM_WHITESPACES = _hx_tab_array({[0]="TRIM_WHITESPACES",1,__enum__ = __diff_comparison_ComparisonPolicy},2)

__diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES = _hx_tab_array({[0]="IGNORE_WHITESPACES",2,__enum__ = __diff_comparison_ComparisonPolicy},2)


__diff_comparison_ComparisonUtil.new = {}
__diff_comparison_ComparisonUtil.__name__ = "diff.comparison.ComparisonUtil"
__diff_comparison_ComparisonUtil.isEquals = function(text1,text2,policy) 
  if (text1 == text2) then 
    do return true end;
  end;
  if ((text1 == nil) or (text2 == nil)) then 
    do return false end;
  end;
  local tmp = policy[1];
  if (tmp) == 0 then 
    do return text1 == text2 end;
  elseif (tmp) == 1 then 
    do return StringTools.trim(text1) == StringTools.trim(text2) end;
  elseif (tmp) == 2 then 
    do return __diff_comparison__ComparisonUtil_ComparisonUtil_Fields_.equalsIgnoreWhitespaces(text1, text2) end; end;
end
__diff_comparison_ComparisonUtil.isEqualTexts = function(text1,text2,policy) 
  local tmp = policy[1];
  if (tmp) == 0 then 
    do return text1 == text2 end;
  elseif (tmp) == 1 then 
    do return StringTools.trim(text1) == StringTools.trim(text2) end;
  elseif (tmp) == 2 then 
    do return __diff_comparison__ComparisonUtil_ComparisonUtil_Fields_.equalsIgnoreWhitespaces(text1, text2) end; end;
end
__diff_comparison_ComparisonUtil.equalsTrimWhitespaces = function(s1,s2) 
  local index1 = 0;
  local index2 = 0;
  while (true) do _hx_do_first_1 = false;
    
    local lastLine1 = false;
    local lastLine2 = false;
    local end1 = String.prototype.indexOf(s1, "\n", index1) + 1;
    local end2 = String.prototype.indexOf(s2, "\n", index2) + 1;
    if (end1 == 0) then 
      end1 = __lua_lib_luautf8_Utf8.len(s1);
      lastLine1 = true;
    end;
    if (end2 == 0) then 
      end2 = __lua_lib_luautf8_Utf8.len(s2);
      lastLine2 = true;
    end;
    local x = (function() 
      local _hx_1
      if (lastLine1) then 
      _hx_1 = 1; else 
      _hx_1 = 0; end
      return _hx_1
    end )();
    local y = (function() 
      local _hx_2
      if (lastLine2) then 
      _hx_2 = 1; else 
      _hx_2 = 0; end
      return _hx_2
    end )();
    if ((_hx_bit.bxor(x,y)) == 1) then 
      do return false end;
    end;
    local line1 = String.prototype.substring(s1, index1, end1);
    local line2 = String.prototype.substring(s2, index2, end2);
    if (StringTools.trim(line1) ~= StringTools.trim(line2)) then 
      do return false end;
    end;
    index1 = end1;
    index2 = end2;
    if (lastLine1) then 
      do return true end;
    end;
  end;
end
__diff_comparison_ComparisonUtil.getUnimportantLineCharCount = function() 
  do return __config_DiffConfig.UNIMPORTANT_LINE_CHAR_COUNT end;
end

__diff_comparison__ComparisonUtil_ComparisonUtil_Fields_.new = {}
__diff_comparison__ComparisonUtil_ComparisonUtil_Fields_.__name__ = "diff.comparison._ComparisonUtil.ComparisonUtil_Fields_"
__diff_comparison__ComparisonUtil_ComparisonUtil_Fields_.equalsIgnoreWhitespaces = function(s1,s2) 
  local x = (function() 
    local _hx_1
    if (s2 == nil) then 
    _hx_1 = 1; else 
    _hx_1 = 0; end
    return _hx_1
  end )();
  local y = (function() 
    local _hx_2
    if (s1 == nil) then 
    _hx_2 = 1; else 
    _hx_2 = 0; end
    return _hx_2
  end )();
  if ((_hx_bit.bxor(x,y)) == 1) then 
    do return false end;
  end;
  if (s1 == nil) then 
    do return true end;
  end;
  local len1 = __lua_lib_luautf8_Utf8.len(s1);
  local len2 = __lua_lib_luautf8_Utf8.len(s2);
  local index1 = 0;
  local index2 = 0;
  local _hx_continue_1 = false;
  while ((index1 < len1) and (index2 < len2)) do _hx_do_first_1 = false;
    repeat 
    if (__lua_lib_luautf8_Utf8.byte(s1, index1 + 1) == __lua_lib_luautf8_Utf8.byte(s2, index2 + 1)) then 
      index1 = index1 + 1;
      index2 = index2 + 1;
      break;
    end;
    local skipped = false;
    while ((index1 ~= len1) and StringTools.isSpace(s1, index1)) do _hx_do_first_2 = false;
      
      skipped = true;
      index1 = index1 + 1;
    end;
    while ((index2 ~= len2) and StringTools.isSpace(s2, index2)) do _hx_do_first_2 = false;
      
      skipped = true;
      index2 = index2 + 1;
    end;
    if (not skipped) then 
      do return false end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  while (index1 ~= len1) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(s1, index1)) then 
      do return false end;
    end;
    index1 = index1 + 1;
  end;
  while (index2 ~= len2) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(s2, index2)) then 
      do return false end;
    end;
    index2 = index2 + 1;
  end;
  do return true end;
end

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
__haxe_Exception.__name__ = "haxe.Exception"
__haxe_Exception.caught = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value end;
  else
    do return __haxe_ValueException.new(value, nil, value) end;
  end;
end
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.__exceptionMessage= nil;
__haxe_Exception.prototype.__nativeStack= nil;
__haxe_Exception.prototype.__skipStack= nil;
__haxe_Exception.prototype.__nativeException= nil;
__haxe_Exception.prototype.__previousException= nil;
__haxe_Exception.prototype.unwrap = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.toString = function(self) 
  do return self:get_message() end
end
__haxe_Exception.prototype.get_message = function(self) 
  do return self.__exceptionMessage end
end
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__diff_comparison_DiffTooBigException.new = function(message,previous,native) 
  local self = _hx_new(__diff_comparison_DiffTooBigException.prototype)
  __diff_comparison_DiffTooBigException.super(self,message,previous,native)
  return self
end
__diff_comparison_DiffTooBigException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__diff_comparison_DiffTooBigException.__name__ = "diff.comparison.DiffTooBigException"
__diff_comparison_DiffTooBigException.prototype = _hx_e();

__diff_comparison_DiffTooBigException.prototype.__class__ =  __diff_comparison_DiffTooBigException
__diff_comparison_DiffTooBigException.__super__ = __haxe_Exception
setmetatable(__diff_comparison_DiffTooBigException.prototype,{__index=__haxe_Exception.prototype})

__diff_comparison_LineFragmentSplitter.new = function(text1,text2,words1,words2,iterable) 
  local self = _hx_new(__diff_comparison_LineFragmentSplitter.prototype)
  __diff_comparison_LineFragmentSplitter.super(self,text1,text2,words1,words2,iterable)
  return self
end
__diff_comparison_LineFragmentSplitter.super = function(self,text1,text2,words1,words2,iterable) 
  self.pendingChunk = nil;
  self.last2 = -1;
  self.last1 = -1;
  self.myResult = Array.new();
  self.myText1 = text1;
  self.myText2 = text2;
  self.myWords1 = words1;
  self.myWords2 = words2;
  self.myIterable = iterable;
end
__diff_comparison_LineFragmentSplitter.__name__ = "diff.comparison.LineFragmentSplitter"
__diff_comparison_LineFragmentSplitter.shouldMergeChunks = function(chunk1,chunk2) 
  if (not chunk1.hasEqualWords and not chunk2.hasEqualWords) then 
    do return true end;
  end;
  if (chunk1.isEqualIgnoreWhitespaces and chunk2.isEqualIgnoreWhitespaces) then 
    do return true end;
  end;
  if (not chunk1.hasWordsInside or not chunk2.hasWordsInside) then 
    do return true end;
  end;
  do return false end;
end
__diff_comparison_LineFragmentSplitter.mergeChunks = function(chunk1,chunk2) 
  local block1 = chunk1.block;
  local block2 = chunk2.block;
  local newBlock = __diff_comparison_WordBlock.new(__diff_util_Range.new(block1.words.start1, block2.words.end1, block1.words.start2, block2.words.end2), __diff_util_Range.new(block1.offsets.start1, block2.offsets.end1, block1.offsets.start2, block2.offsets.end2));
  do return __diff_comparison_PendingChunk.new(newBlock, chunk1.hasEqualWords or chunk2.hasEqualWords, chunk1.hasWordsInside or chunk2.hasWordsInside, chunk1.isEqualIgnoreWhitespaces and chunk2.isEqualIgnoreWhitespaces) end;
end
__diff_comparison_LineFragmentSplitter.getOffset = function(words,text,index) 
  if (index == -1) then 
    do return 0 end;
  end;
  if (index == words.length) then 
    do return __lua_lib_luautf8_Utf8.len(text) end;
  end;
  local chunk = words[index];
  do return chunk:getOffset2() end;
end
__diff_comparison_LineFragmentSplitter.isNewline = function(words1,index) 
  local value = words1[index];
  do return (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(value, __diff_comparison_NewlineChunk)) then 
    _hx_1 = value; else 
    _hx_1 = nil; end
    return _hx_1
  end )() ~= nil end;
end
__diff_comparison_LineFragmentSplitter.isFirstInLine = function(words1,index) 
  if (index == 0) then 
    do return true end;
  end;
  local value = words1[index - 1];
  do return (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(value, __diff_comparison_NewlineChunk)) then 
    _hx_1 = value; else 
    _hx_1 = nil; end
    return _hx_1
  end )() ~= nil end;
end
__diff_comparison_LineFragmentSplitter.prototype = _hx_e();
__diff_comparison_LineFragmentSplitter.prototype.myText1= nil;
__diff_comparison_LineFragmentSplitter.prototype.myText2= nil;
__diff_comparison_LineFragmentSplitter.prototype.myWords1= nil;
__diff_comparison_LineFragmentSplitter.prototype.myWords2= nil;
__diff_comparison_LineFragmentSplitter.prototype.myIterable= nil;
__diff_comparison_LineFragmentSplitter.prototype.myResult= nil;
__diff_comparison_LineFragmentSplitter.prototype.last1= nil;
__diff_comparison_LineFragmentSplitter.prototype.last2= nil;
__diff_comparison_LineFragmentSplitter.prototype.pendingChunk= nil;
__diff_comparison_LineFragmentSplitter.prototype.run = function(self) 
  local hasEqualWords = false;
  local range = self.myIterable:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
    local count = range.end1 - range.start1;
    local _g = 0;
    local _g1 = count;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index1 = range.start1 + i;
      local index2 = range.start2 + i;
      if (__diff_comparison_LineFragmentSplitter.isNewline(self.myWords1, index1) and __diff_comparison_LineFragmentSplitter.isNewline(self.myWords2, index2)) then 
        self:addLineChunk(index1, index2, hasEqualWords);
        hasEqualWords = false;
      else
        if (__diff_comparison_LineFragmentSplitter.isFirstInLine(self.myWords1, index1) and __diff_comparison_LineFragmentSplitter.isFirstInLine(self.myWords2, index2)) then 
          self:addLineChunk(index1 - 1, index2 - 1, hasEqualWords);
          hasEqualWords = false;
        end;
        hasEqualWords = true;
      end;
    end;
  end;
  self:addLineChunk(self.myWords1.length, self.myWords2.length, hasEqualWords);
  if (self.pendingChunk ~= nil) then 
    self.myResult:push(self.pendingChunk.block);
  end;
  do return self.myResult end
end
__diff_comparison_LineFragmentSplitter.prototype.addLineChunk = function(self,end1,end2,hasEqualWords) 
  if ((self.last1 > end1) or (self.last2 > end2)) then 
    do return end;
  end;
  local chunk = self:createChunk(self.last1, self.last2, end1, end2, hasEqualWords);
  if (chunk.block.offsets:isEmpty()) then 
    do return end;
  end;
  if ((self.pendingChunk ~= nil) and __diff_comparison_LineFragmentSplitter.shouldMergeChunks(self.pendingChunk, chunk)) then 
    self.pendingChunk = __diff_comparison_LineFragmentSplitter.mergeChunks(self.pendingChunk, chunk);
  else
    if (self.pendingChunk ~= nil) then 
      self.myResult:push(self.pendingChunk.block);
    end;
    self.pendingChunk = chunk;
  end;
  self.last1 = end1;
  self.last2 = end2;
end
__diff_comparison_LineFragmentSplitter.prototype.createChunk = function(self,start1,start2,end1,end2,hasEqualWords) 
  local startOffset1 = __diff_comparison_LineFragmentSplitter.getOffset(self.myWords1, self.myText1, start1);
  local startOffset2 = __diff_comparison_LineFragmentSplitter.getOffset(self.myWords2, self.myText2, start2);
  local endOffset1 = __diff_comparison_LineFragmentSplitter.getOffset(self.myWords1, self.myText1, end1);
  local endOffset2 = __diff_comparison_LineFragmentSplitter.getOffset(self.myWords2, self.myText2, end2);
  start1 = Std.int(Math.max(0, start1 + 1));
  start2 = Std.int(Math.max(0, start2 + 1));
  end1 = Std.int(Math.min(end1 + 1, self.myWords1.length));
  end2 = Std.int(Math.min(end2 + 1, self.myWords2.length));
  local block = __diff_comparison_WordBlock.new(__diff_util_Range.new(start1, end1, start2, end2), __diff_util_Range.new(startOffset1, endOffset1, startOffset2, endOffset2));
  do return __diff_comparison_PendingChunk.new(block, hasEqualWords, self:hasWordsInside(block), self:isEqualsIgnoreWhitespace(block)) end
end
__diff_comparison_LineFragmentSplitter.prototype.isEqualsIgnoreWhitespace = function(self,block) 
  local sequence1 = String.prototype.substring(self.myText1, block.offsets.start1, block.offsets.end1);
  local sequence2 = String.prototype.substring(self.myText2, block.offsets.start2, block.offsets.end2);
  do return __diff_comparison_ComparisonUtil.isEquals(sequence1, sequence2, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES) end
end
__diff_comparison_LineFragmentSplitter.prototype.hasWordsInside = function(self,block) 
  local _g = block.words.start1;
  local _g1 = block.words.end1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local value = self.myWords1[i];
    if ((function() 
      local _hx_1
      if (__lua_Boot.__instanceof(value, __diff_comparison_NewlineChunk)) then 
      _hx_1 = value; else 
      _hx_1 = nil; end
      return _hx_1
    end )() == nil) then 
      do return true end;
    end;
  end;
  local _g = block.words.start2;
  local _g1 = block.words.end2;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local value = self.myWords2[i];
    if ((function() 
      local _hx_2
      if (__lua_Boot.__instanceof(value, __diff_comparison_NewlineChunk)) then 
      _hx_2 = value; else 
      _hx_2 = nil; end
      return _hx_2
    end )() == nil) then 
      do return true end;
    end;
  end;
  do return false end
end

__diff_comparison_LineFragmentSplitter.prototype.__class__ =  __diff_comparison_LineFragmentSplitter

__diff_comparison_WordBlock.new = function(words,offsets) 
  local self = _hx_new(__diff_comparison_WordBlock.prototype)
  __diff_comparison_WordBlock.super(self,words,offsets)
  return self
end
__diff_comparison_WordBlock.super = function(self,words,offsets) 
  self.words = words;
  self.offsets = offsets;
end
__diff_comparison_WordBlock.__name__ = "diff.comparison.WordBlock"
__diff_comparison_WordBlock.prototype = _hx_e();
__diff_comparison_WordBlock.prototype.words= nil;
__diff_comparison_WordBlock.prototype.offsets= nil;

__diff_comparison_WordBlock.prototype.__class__ =  __diff_comparison_WordBlock

__diff_comparison_PendingChunk.new = function(block,hasEqualWords,hasWordsInside,isEqualIgnoreWhitespaces) 
  local self = _hx_new(__diff_comparison_PendingChunk.prototype)
  __diff_comparison_PendingChunk.super(self,block,hasEqualWords,hasWordsInside,isEqualIgnoreWhitespaces)
  return self
end
__diff_comparison_PendingChunk.super = function(self,block,hasEqualWords,hasWordsInside,isEqualIgnoreWhitespaces) 
  self.block = block;
  self.hasEqualWords = hasEqualWords;
  self.hasWordsInside = hasWordsInside;
  self.isEqualIgnoreWhitespaces = isEqualIgnoreWhitespaces;
end
__diff_comparison_PendingChunk.__name__ = "diff.comparison.PendingChunk"
__diff_comparison_PendingChunk.prototype = _hx_e();
__diff_comparison_PendingChunk.prototype.block= nil;
__diff_comparison_PendingChunk.prototype.hasEqualWords= nil;
__diff_comparison_PendingChunk.prototype.hasWordsInside= nil;
__diff_comparison_PendingChunk.prototype.isEqualIgnoreWhitespaces= nil;

__diff_comparison_PendingChunk.prototype.__class__ =  __diff_comparison_PendingChunk

__diff_comparison_MergeResolveUtil.new = {}
__diff_comparison_MergeResolveUtil.__name__ = "diff.comparison.MergeResolveUtil"
__diff_comparison_MergeResolveUtil.tryResolve = function(leftText,baseText,rightText) 
  local _hx_status, _hx_result = pcall(function() 
  
      local resolved = __diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.trySimpleResolveHelper(leftText, baseText, rightText, __diff_comparison_ComparisonPolicy.DEFAULT);
      if (resolved ~= nil) then 
        do return resolved end;
      end;
      do return __diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.trySimpleResolveHelper(leftText, baseText, rightText, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES) end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __diff_comparison_DiffTooBigException)) then 
      do return nil end;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__diff_comparison_MergeResolveUtil.tryGreedyResolve = function(leftText,baseText,rightText) 
  local _hx_status, _hx_result = pcall(function() 
  
      local resolved = __diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.tryGreedyResolveHelper(leftText, baseText, rightText, __diff_comparison_ComparisonPolicy.DEFAULT);
      if (resolved ~= nil) then 
        do return resolved end;
      end;
      do return __diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.tryGreedyResolveHelper(leftText, baseText, rightText, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES) end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __diff_comparison_DiffTooBigException)) then 
      do return nil end;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end

__diff_comparison_SimpleHelper.new = function(leftText,baseText,rightText) 
  local self = _hx_new(__diff_comparison_SimpleHelper.prototype)
  __diff_comparison_SimpleHelper.super(self,leftText,baseText,rightText)
  return self
end
__diff_comparison_SimpleHelper.super = function(self,leftText,baseText,rightText) 
  self.baseText = "";
  self.rightText = "";
  self.leftText = "";
  self.last3 = 0;
  self.last2 = 0;
  self.last1 = 0;
  self.newContent = StringBuf.new();
  self.leftText = leftText;
  self.rightText = rightText;
  self.baseText = baseText;
  self.texts = _hx_tab_array({[0]=leftText, baseText, rightText}, 3);
end
__diff_comparison_SimpleHelper.__name__ = "diff.comparison.SimpleHelper"
__diff_comparison_SimpleHelper.prototype = _hx_e();
__diff_comparison_SimpleHelper.prototype.newContent= nil;
__diff_comparison_SimpleHelper.prototype.last1= nil;
__diff_comparison_SimpleHelper.prototype.last2= nil;
__diff_comparison_SimpleHelper.prototype.last3= nil;
__diff_comparison_SimpleHelper.prototype.leftText= nil;
__diff_comparison_SimpleHelper.prototype.rightText= nil;
__diff_comparison_SimpleHelper.prototype.baseText= nil;
__diff_comparison_SimpleHelper.prototype.texts= nil;
__diff_comparison_SimpleHelper.prototype.execute = function(self,policy) 
  local changes = __diff_comparison_ByWordRt.compareX(self.leftText, self.baseText, self.rightText, policy);
  local _g = 0;
  while (_g < changes.length) do _hx_do_first_1 = false;
    
    local fragment = changes[_g];
    _g = _g + 1;
    local baseRange = self:nextMergeRange(fragment:getStartOffset(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT)), fragment:getStartOffset(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE)), fragment:getStartOffset(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT)));
    self:appendBase(baseRange);
    local conflictRange = self:nextMergeRange(fragment:getEndOffset(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT)), fragment:getEndOffset(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE)), fragment:getEndOffset(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT)));
    if (not self:appendConflict(conflictRange, policy)) then 
      do return nil end;
    end;
  end;
  local trailingRange = self:nextMergeRange(__lua_lib_luautf8_Utf8.len(self.leftText), __lua_lib_luautf8_Utf8.len(self.baseText), __lua_lib_luautf8_Utf8.len(self.rightText));
  self:appendBase(trailingRange);
  do return _G.table.concat(self.newContent.b) end
end
__diff_comparison_SimpleHelper.prototype.nextMergeRange = function(self,end1,end2,end3) 
  local range = __diff_util_MergeRange.new(self.last1, end1, self.last2, end2, self.last3, end3);
  self.last1 = end1;
  self.last2 = end2;
  self.last3 = end3;
  do return range end
end
__diff_comparison_SimpleHelper.prototype.appendBase = function(self,range) 
  if (range:isEmpty()) then 
    do return end;
  end;
  local policy = __diff_comparison_ComparisonPolicy.DEFAULT;
  if (self:isUnchangedRange(range, policy)) then 
    self:append(range, __diff_util_ThreeSideEnum.BASE);
  else
    local type = self:getConflictType(range, policy);
    if (type:isChangeA(__diff_util_Side.fromEnum(__diff_util_SideEnum.LEFT))) then 
      self:append(range, __diff_util_ThreeSideEnum.LEFT);
    else
      if (type:isChangeA(__diff_util_Side.fromEnum(__diff_util_SideEnum.RIGHT))) then 
        self:append(range, __diff_util_ThreeSideEnum.RIGHT);
      else
        self:append(range, __diff_util_ThreeSideEnum.BASE);
      end;
    end;
  end;
end
__diff_comparison_SimpleHelper.prototype.appendConflict = function(self,range,policy) 
  local type = self:getConflictType(range, policy);
  if (type:getType() == __diff_util_MergeConflictTypeEnum.CONFLICT) then 
    do return false end;
  end;
  if (type:isChangeA(__diff_util_Side.fromEnum(__diff_util_SideEnum.LEFT))) then 
    self:append(range, __diff_util_ThreeSideEnum.LEFT);
  else
    self:append(range, __diff_util_ThreeSideEnum.RIGHT);
  end;
  do return true end
end
__diff_comparison_SimpleHelper.prototype.append = function(self,range,side) 
  local tmp = side[1];
  if (tmp) == 0 then 
    local _this = self.newContent;
    local str = Std.string(String.prototype.substring(self.leftText, range.start1, range.end1));
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 1 then 
    local _this = self.newContent;
    local str = Std.string(String.prototype.substring(self.baseText, range.start2, range.end2));
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 2 then 
    local _this = self.newContent;
    local str = Std.string(String.prototype.substring(self.rightText, range.start3, range.end3));
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str); end;
end
__diff_comparison_SimpleHelper.prototype.getConflictType = function(self,range,policy) 
  do return __diff_util_MergeRangeUtil.getWordMergeType(__diff_fragments_MergeWordFragment.newFromRange(range), self.texts, policy) end
end
__diff_comparison_SimpleHelper.prototype.isUnchangedRange = function(self,range,policy) 
  if (__diff_util_MergeRangeUtil.compareWordMergeContents(__diff_fragments_MergeWordFragment.newFromRange(range), self.texts, policy, __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT))) then 
    do return __diff_util_MergeRangeUtil.compareWordMergeContents(__diff_fragments_MergeWordFragment.newFromRange(range), self.texts, policy, __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT)) end;
  else
    do return false end;
  end;
end

__diff_comparison_SimpleHelper.prototype.__class__ =  __diff_comparison_SimpleHelper

__diff_comparison_GreedyHelper.new = function(leftText,baseText,rightText) 
  local self = _hx_new(__diff_comparison_GreedyHelper.prototype)
  __diff_comparison_GreedyHelper.super(self,leftText,baseText,rightText)
  return self
end
__diff_comparison_GreedyHelper.super = function(self,leftText,baseText,rightText) 
  self.baseText = "";
  self.rightText = "";
  self.leftText = "";
  self.index2 = 0;
  self.index1 = 0;
  self.lastBaseOffset = 0;
  self.newContent = StringBuf.new();
  self.leftText = leftText;
  self.rightText = rightText;
  self.baseText = baseText;
end
__diff_comparison_GreedyHelper.__name__ = "diff.comparison.GreedyHelper"
__diff_comparison_GreedyHelper.prototype = _hx_e();
__diff_comparison_GreedyHelper.prototype.newContent= nil;
__diff_comparison_GreedyHelper.prototype.lastBaseOffset= nil;
__diff_comparison_GreedyHelper.prototype.index1= nil;
__diff_comparison_GreedyHelper.prototype.index2= nil;
__diff_comparison_GreedyHelper.prototype.leftText= nil;
__diff_comparison_GreedyHelper.prototype.rightText= nil;
__diff_comparison_GreedyHelper.prototype.baseText= nil;
__diff_comparison_GreedyHelper.prototype.execute = function(self,policy) 
  local fragments1 = __diff_comparison_ByWordRt.compareY(self.baseText, self.leftText, policy);
  local fragments2 = __diff_comparison_ByWordRt.compareY(self.baseText, self.rightText, policy);
  local _hx_continue_1 = false;
  while (true) do _hx_do_first_1 = false;
    repeat 
    local tmp = fragments1[self.index1];
    local fragIdx1 = (function() 
      local _hx_1
      if (tmp ~= nil) then 
      _hx_1 = tmp:getStartOffset1(); else 
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (fragIdx1 == nil) then 
      fragIdx1 = -1;
    end;
    local fragmentIndex1 = fragIdx1;
    local tmp = fragments2[self.index2];
    local fragIdx2 = (function() 
      local _hx_2
      if (tmp ~= nil) then 
      _hx_2 = tmp:getStartOffset1(); else 
      _hx_2 = nil; end
      return _hx_2
    end )();
    if (fragIdx2 == nil) then 
      fragIdx2 = -1;
    end;
    local fragmentIndex2 = fragIdx2;
    local changeStart1 = -1;
    local changeStart2 = -1;
    if (fragmentIndex1 ~= nil) then 
      changeStart1 = fragmentIndex1;
    end;
    if (fragmentIndex2 ~= nil) then 
      changeStart2 = fragmentIndex2;
    end;
    if ((changeStart1 == -1) and (changeStart2 == -1)) then 
      self:appendBase(__lua_lib_luautf8_Utf8.len(self.baseText));
      _hx_continue_1 = true;break;
    end;
    if ((changeStart1 ~= -1) and (changeStart2 ~= -1)) then 
      self:appendBase(Std.int(Math.min(changeStart1, changeStart2)));
    else
      if (changeStart1 ~= -1) then 
        self:appendBase(changeStart1);
      else
        self:appendBase(changeStart2);
      end;
    end;
    local baseOffsetEnd = self.lastBaseOffset;
    local end1 = self.index1;
    local end2 = self.index2;
    local _hx_continue_2 = false;
    while (true) do _hx_do_first_2 = false;
      repeat 
      local next1 = fragments1[end1];
      local next2 = fragments2[end2];
      if ((next1 ~= nil) and (next1:getStartOffset1() <= baseOffsetEnd)) then 
        baseOffsetEnd = Std.int(Math.max(baseOffsetEnd, next1:getEndOffset1()));
        end1 = end1 + 1;
        break;
      end;
      if ((next2 ~= nil) and (next2:getStartOffset1() <= baseOffsetEnd)) then 
        baseOffsetEnd = Std.int(Math.max(baseOffsetEnd, next2:getEndOffset1()));
        end2 = end2 + 1;
        break;
      end;
      _hx_continue_2 = true;break;until true
      if _hx_continue_2 then 
      _hx_continue_2 = false;
      break;
      end;
      
    end;
    local inserted1 = self:getInsertedContent(fragments1, self.index1, end1, __diff_util_Side.fromEnum(__diff_util_SideEnum.LEFT));
    local inserted2 = self:getInsertedContent(fragments2, self.index2, end2, __diff_util_Side.fromEnum(__diff_util_SideEnum.RIGHT));
    self.index1 = end1;
    self.index2 = end2;
    self.lastBaseOffset = baseOffsetEnd;
    if ((inserted1 == "") and (inserted2 == "")) then 
      break;
    end;
    if (inserted2 == "") then 
      local _this = self.newContent;
      local str = Std.string(inserted1);
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str);
      break;
    end;
    if (inserted1 == "") then 
      local _this = self.newContent;
      local str = Std.string(inserted2);
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str);
      break;
    end;
    if (__diff_comparison_ComparisonUtil.isEqualTexts(inserted1, inserted2, policy)) then 
      local inserted = (function() 
        local _hx_3
        if (__lua_lib_luautf8_Utf8.len(inserted1) <= __lua_lib_luautf8_Utf8.len(inserted2)) then 
        _hx_3 = inserted1; else 
        _hx_3 = inserted2; end
        return _hx_3
      end )();
      local _this = self.newContent;
      local str = Std.string(inserted);
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str);
      break;
    end;
    do return nil end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return _G.table.concat(self.newContent.b) end
end
__diff_comparison_GreedyHelper.prototype.appendBase = function(self,endOffset) 
  if (self.lastBaseOffset == endOffset) then 
    do return end;
  end;
  local _this = self.newContent;
  local str = Std.string(String.prototype.substring(self.baseText, self.lastBaseOffset, endOffset));
  _G.table.insert(_this.b, str);
  local _this = _this;
  _this.length = _this.length + __lua_lib_luautf8_Utf8.len(str);
  self.lastBaseOffset = endOffset;
end
__diff_comparison_GreedyHelper.prototype.getInsertedContent = function(self,fragments,start,_end,side) 
  local text = side:selectA_String(self.leftText, self.rightText);
  local empty = "";
  local subArray = _hx_tab_array({}, 0);
  local _g = start;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    subArray:push(fragments[i]);
  end;
  do return Lambda.fold(subArray, function(fragment,prefix) 
    do return __ds__MergingCharSequence_MergingCharSequence_Impl_._new(prefix, String.prototype.substring(text, fragment:getStartOffset2(), fragment:getEndOffset2())) end;
  end, empty) end
end

__diff_comparison_GreedyHelper.prototype.__class__ =  __diff_comparison_GreedyHelper

__diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.new = {}
__diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.__name__ = "diff.comparison._MergeResolveUtil.MergeResolveUtil_Fields_"
__diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.trySimpleResolveHelper = function(leftText,baseText,rightText,policy) 
  do return __diff_comparison_SimpleHelper.new(leftText, baseText, rightText):execute(policy) end;
end
__diff_comparison__MergeResolveUtil_MergeResolveUtil_Fields_.tryGreedyResolveHelper = function(leftText,baseText,rightText,policy) 
  do return __diff_comparison_GreedyHelper.new(leftText, baseText, rightText):execute(policy) end;
end

__diff_comparison_TrimUtil.new = {}
__diff_comparison_TrimUtil.__name__ = "diff.comparison.TrimUtil"
__diff_comparison_TrimUtil.isPunctuationA = function(c) 
  do return __diff_comparison_TrimUtil.isPunctuationB(__lua_lib_luautf8_Utf8.byte(c, 1)) end;
end
__diff_comparison_TrimUtil.isPunctuationB = function(b) 
  if (b == 95) then 
    do return false end;
  end;
  if (not ((((b >= 33) and (b <= 47)) or ((b >= 58) and (b <= 64))) or ((b >= 91) and (b <= 96)))) then 
    if (b >= 123) then 
      do return b <= 126 end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
__diff_comparison_TrimUtil.isAlpha = function(c) 
  if (__diff_comparison_TrimUtil.isWhiteSpaceCodePoint(c)) then 
    do return false end;
  end;
  do return not __diff_comparison_TrimUtil.isPunctuationB(c) end;
end
__diff_comparison_TrimUtil.isWhiteSpace = function(s) 
  do return __diff_comparison_TrimUtil.isWhiteSpaceCodePoint(__lua_lib_luautf8_Utf8.byte(s, 1)) end;
end
__diff_comparison_TrimUtil.isWhiteSpaceCodePoint = function(c) 
  if (c < 128) then 
    do return StringTools.isSpace(__lua_lib_luautf8_Utf8.char(c), 0) end;
  else
    do return false end;
  end;
end
__diff_comparison_TrimUtil.isContinuousScript = function(c) 
  if (c < 128) then 
    do return false end;
  end;
  if (Std.parseInt(__lua_lib_luautf8_Utf8.char(c)) ~= nil) then 
    do return false end;
  end;
  do return true end;
end
__diff_comparison_TrimUtil.trimA = function(text,start,_end) 
  local start = start;
  local _end = _end;
  local start1 = start;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text, start1)) then 
      break;
    end;
    start1 = start1 + 1;
  end;
  start = start1;
  local end1 = _end;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text, end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
  end;
  _end = end1;
  do return __ds_Pair.new(start, _end) end;
end
__diff_comparison_TrimUtil.trimB = function(start,_end,ignored) 
  local start = start;
  local _end = _end;
  local start1 = start;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not __thx__BitSet_BitSet_Impl_.at(ignored, start1)) then 
      break;
    end;
    start1 = start1 + 1;
  end;
  start = start1;
  local end1 = _end;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not __thx__BitSet_BitSet_Impl_.at(ignored, end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
  end;
  _end = end1;
  do return __ds_Pair.new(start, _end) end;
end
__diff_comparison_TrimUtil.trimStart = function(text,start,_end) 
  local start = start;
  while (start < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text, start)) then 
      break;
    end;
    start = start + 1;
  end;
  do return start end;
end
__diff_comparison_TrimUtil.trimEnd = function(text,start,_end) 
  local _end = _end;
  while (start < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  do return _end end;
end
__diff_comparison_TrimUtil.trimC = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start = start1;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text1, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start1 = start;
  local _end = end1;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text1, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end1 = _end;
  local start = start2;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text2, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start2 = start;
  local _end = end2;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text2, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end2 = _end;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.trimD = function(text1,text2,text3,start1,start2,start3,end1,end2,end3) 
  local start1 = start1;
  local start2 = start2;
  local start3 = start3;
  local end1 = end1;
  local end2 = end2;
  local end3 = end3;
  local start = start1;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text1, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start1 = start;
  local _end = end1;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text1, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end1 = _end;
  local start = start2;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text2, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start2 = start;
  local _end = end2;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text2, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end2 = _end;
  local start = start3;
  while (start < end3) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text3, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start3 = start;
  local _end = end3;
  while (start3 < _end) do _hx_do_first_1 = false;
    
    if (not StringTools.isSpace(text3, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end3 = _end;
  do return __diff_util_MergeRange.new(start1, end1, start2, end2, start3, end3) end;
end
__diff_comparison_TrimUtil.expandA = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local oldStart1 = start11;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    
    if (text1[start11] ~= text2[start21]) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  local end11 = end1;
  local end21 = end2;
  local oldEnd1 = end11;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    
    if (text1[end11 - 1] ~= text2[end21 - 1]) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.expandForwardA = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local oldStart1 = start1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (text1[start1] ~= text2[start2]) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.expandBackwardA = function(text1,text2,start1,start2,end1,end2) 
  local end1 = end1;
  local end2 = end2;
  local oldEnd1 = end1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (text1[end1 - 1] ~= text2[end2 - 1]) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.expandC = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local oldStart1 = start11;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    
    if (__lua_lib_luautf8_Utf8.sub(text1, start11 + 1, start11 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, start21 + 1, start21 + 1)) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  local end11 = end1;
  local end21 = end2;
  local oldEnd1 = end11;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    
    local index1 = end11 - 1;
    local index2 = end21 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.expandForwardB = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local oldStart1 = start1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (__lua_lib_luautf8_Utf8.sub(text1, start1 + 1, start1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, start2 + 1, start2 + 1)) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.expandBackwardB = function(text1,text2,start1,start2,end1,end2) 
  local end1 = end1;
  local end2 = end2;
  local oldEnd1 = end1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    local index1 = end1 - 1;
    local index2 = end2 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.expandWhitespacesA = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local oldStart1 = start11;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    
    if (__lua_lib_luautf8_Utf8.sub(text1, start11 + 1, start11 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, start21 + 1, start21 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, start11)) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  local end11 = end1;
  local end21 = end2;
  local oldEnd1 = end11;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    
    local index1 = end11 - 1;
    local index2 = end21 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, end11 - 1)) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.expandWhitespacesForwardA = function(text1,text2,start1,start2,end1,end2) 
  local start1 = start1;
  local start2 = start2;
  local oldStart1 = start1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (__lua_lib_luautf8_Utf8.sub(text1, start1 + 1, start1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, start2 + 1, start2 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, start1)) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.expandWhitespacesBackwardA = function(text1,text2,start1,start2,end1,end2) 
  local end1 = end1;
  local end2 = end2;
  local oldEnd1 = end1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    local index1 = end1 - 1;
    local index2 = end2 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.expandWhitespacesB = function(text1,text2,text3,start1,start2,start3,end1,end2,end3) 
  local start1 = start1;
  local start2 = start2;
  local start3 = start3;
  local end1 = end1;
  local end2 = end2;
  local end3 = end3;
  local start11 = start1;
  local start21 = start2;
  local start31 = start3;
  local oldStart1 = start11;
  while (((start11 < end1) and (start21 < end2)) and (start31 < end3)) do _hx_do_first_1 = false;
    
    if (__lua_lib_luautf8_Utf8.sub(text1, start11 + 1, start11 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, start21 + 1, start21 + 1)) then 
      break;
    end;
    if (__lua_lib_luautf8_Utf8.sub(text1, start11 + 1, start11 + 1) ~= __lua_lib_luautf8_Utf8.sub(text3, start31 + 1, start31 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, start11)) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
    start31 = start31 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  start3 = start3 + count1;
  local end11 = end1;
  local end21 = end2;
  local end31 = end3;
  local oldEnd1 = end11;
  while (((start1 < end11) and (start2 < end21)) and (start3 < end31)) do _hx_do_first_1 = false;
    
    local index1 = end11 - 1;
    local index2 = end21 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      break;
    end;
    local index1 = end11 - 1;
    local index3 = end31 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text3, index3 + 1, index3 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, end11 - 1)) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
    end31 = end31 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  end3 = end3 - count2;
  do return __diff_util_MergeRange.new(start1, end1, start2, end2, start3, end3) end;
end
__diff_comparison_TrimUtil.expandWhitespacesForwardB = function(text1,text2,text3,start1,start2,start3,end1,end2,end3) 
  local start1 = start1;
  local start2 = start2;
  local start3 = start3;
  local oldStart1 = start1;
  while (((start1 < end1) and (start2 < end2)) and (start3 < end3)) do _hx_do_first_1 = false;
    
    if (__lua_lib_luautf8_Utf8.sub(text1, start1 + 1, start1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, start2 + 1, start2 + 1)) then 
      break;
    end;
    if (__lua_lib_luautf8_Utf8.sub(text1, start1 + 1, start1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text3, start3 + 1, start3 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, start1)) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
    start3 = start3 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.expandWhitespacesBackwardB = function(text1,text2,text3,start1,start2,start3,end1,end2,end3) 
  local end1 = end1;
  local end2 = end2;
  local end3 = end3;
  local oldEnd1 = end1;
  while (((start1 < end1) and (start2 < end2)) and (start3 < end3)) do _hx_do_first_1 = false;
    
    local index1 = end1 - 1;
    local index2 = end2 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      break;
    end;
    local index1 = end1 - 1;
    local index3 = end3 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) ~= __lua_lib_luautf8_Utf8.sub(text3, index3 + 1, index3 + 1)) then 
      break;
    end;
    if (not StringTools.isSpace(text1, end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
    end3 = end3 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.trimExpandRange = function(start1,start2,end1,end2,equals,ignored1,ignored2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local _hx_continue_1 = false;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    repeat 
    if (equals(start11, start21)) then 
      start11 = start11 + 1;
      start21 = start21 + 1;
      break;
    end;
    local skipped = false;
    if (ignored1(start11)) then 
      skipped = true;
      start11 = start11 + 1;
    end;
    if (ignored2(start21)) then 
      skipped = true;
      start21 = start21 + 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local start = start11;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not ignored1(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start11 = start;
  local start = start21;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not ignored2(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start21 = start;
  local starts = __ds_Pair.new(start11, start21);
  start1 = starts.first;
  start2 = starts.second;
  local end11 = end1;
  local end21 = end2;
  local _hx_continue_1 = false;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    repeat 
    if (equals(end11 - 1, end21 - 1)) then 
      end11 = end11 - 1;
      end21 = end21 - 1;
      break;
    end;
    local skipped = false;
    if (ignored1(end11 - 1)) then 
      skipped = true;
      end11 = end11 - 1;
    end;
    if (ignored2(end21 - 1)) then 
      skipped = true;
      end21 = end21 - 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _end = end11;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not ignored1(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end11 = _end;
  local _end = end21;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not ignored2(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end21 = _end;
  local ends = __ds_Pair.new(end11, end21);
  end1 = ends.first;
  end2 = ends.second;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.trimExpandText = function(text1,text2,start1,start2,end1,end2,ignored1,ignored2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local _hx_continue_1 = false;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    repeat 
    if (__lua_lib_luautf8_Utf8.sub(text1, start11 + 1, start11 + 1) == __lua_lib_luautf8_Utf8.sub(text2, start21 + 1, start21 + 1)) then 
      start11 = start11 + 1;
      start21 = start21 + 1;
      break;
    end;
    local skipped = false;
    if (__thx__BitSet_BitSet_Impl_.at(ignored1, start11)) then 
      skipped = true;
      start11 = start11 + 1;
    end;
    if (__thx__BitSet_BitSet_Impl_.at(ignored2, start21)) then 
      skipped = true;
      start21 = start21 + 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local start = start11;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not __thx__BitSet_BitSet_Impl_.at(ignored1, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start11 = start;
  local start = start21;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not __thx__BitSet_BitSet_Impl_.at(ignored2, start)) then 
      break;
    end;
    start = start + 1;
  end;
  start21 = start;
  local starts = __ds_Pair.new(start11, start21);
  start1 = starts.first;
  start2 = starts.second;
  local end11 = end1;
  local end21 = end2;
  local _hx_continue_1 = false;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    repeat 
    local index1 = end11 - 1;
    local index2 = end21 - 1;
    if (__lua_lib_luautf8_Utf8.sub(text1, index1 + 1, index1 + 1) == __lua_lib_luautf8_Utf8.sub(text2, index2 + 1, index2 + 1)) then 
      end11 = end11 - 1;
      end21 = end21 - 1;
      break;
    end;
    local skipped = false;
    if (__thx__BitSet_BitSet_Impl_.at(ignored1, end11 - 1)) then 
      skipped = true;
      end11 = end11 - 1;
    end;
    if (__thx__BitSet_BitSet_Impl_.at(ignored2, end21 - 1)) then 
      skipped = true;
      end21 = end21 - 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _end = end11;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not __thx__BitSet_BitSet_Impl_.at(ignored1, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end11 = _end;
  local _end = end21;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not __thx__BitSet_BitSet_Impl_.at(ignored2, _end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end21 = _end;
  local ends = __ds_Pair.new(end11, end21);
  end1 = ends.first;
  end2 = ends.second;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.trimE = function(text1,text2,range) 
  do return __diff_comparison_TrimUtil.trimC(text1, text2, range.start1, range.start2, range.end1, range.end2) end;
end
__diff_comparison_TrimUtil.trimF = function(text1,text2,text3,range) 
  do return __diff_comparison_TrimUtil.trimD(text1, text2, text3, range.start1, range.start2, range.start3, range.end1, range.end2, range.end3) end;
end
__diff_comparison_TrimUtil.expandD = function(text1,text2,range) 
  do return __diff_comparison_TrimUtil.expandC(text1, text2, range.start1, range.start2, range.end1, range.end2) end;
end
__diff_comparison_TrimUtil.expandWhitespacesC = function(text1,text2,range) 
  do return __diff_comparison_TrimUtil.expandWhitespacesA(text1, text2, range.start1, range.start2, range.end1, range.end2) end;
end
__diff_comparison_TrimUtil.expandWhitespacesD = function(text1,text2,text3,range) 
  do return __diff_comparison_TrimUtil.expandWhitespacesB(text1, text2, text3, range.start1, range.start2, range.start3, range.end1, range.end2, range.end3) end;
end
__diff_comparison_TrimUtil.isEqualsA = function(text1,text2,range) 
  local sequence1 = String.prototype.substring(text1, range.start1, range.end1);
  local sequence2 = String.prototype.substring(text2, range.start2, range.end2);
  do return __diff_comparison_ComparisonUtil.isEqualTexts(sequence1, sequence2, __diff_comparison_ComparisonPolicy.DEFAULT) end;
end
__diff_comparison_TrimUtil.isEqualsIgnoreWhitespacesA = function(text1,text2,range) 
  local sequence1 = String.prototype.substring(text1, range.start1, range.end1);
  local sequence2 = String.prototype.substring(text2, range.start2, range.end2);
  do return __diff_comparison_ComparisonUtil.isEqualTexts(sequence1, sequence2, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES) end;
end
__diff_comparison_TrimUtil.isEqualsB = function(text1,text2,text3,range) 
  local sequence1 = String.prototype.substring(text1, range.start1, range.end1);
  local sequence2 = String.prototype.substring(text2, range.start2, range.end2);
  local sequence3 = String.prototype.substring(text3, range.start3, range.end3);
  if (__diff_comparison_ComparisonUtil.isEqualTexts(sequence2, sequence1, __diff_comparison_ComparisonPolicy.DEFAULT)) then 
    do return __diff_comparison_ComparisonUtil.isEqualTexts(sequence2, sequence3, __diff_comparison_ComparisonPolicy.DEFAULT) end;
  else
    do return false end;
  end;
end
__diff_comparison_TrimUtil.isEqualsIgnoreWhitespacesB = function(text1,text2,text3,range) 
  local sequence1 = String.prototype.substring(text1, range.start1, range.end1);
  local sequence2 = String.prototype.substring(text2, range.start2, range.end2);
  local sequence3 = String.prototype.substring(text3, range.start3, range.end3);
  if (__diff_comparison_ComparisonUtil.isEqualTexts(sequence2, sequence1, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES)) then 
    do return __diff_comparison_ComparisonUtil.isEqualTexts(sequence2, sequence3, __diff_comparison_ComparisonPolicy.IGNORE_WHITESPACES) end;
  else
    do return false end;
  end;
end
__diff_comparison_TrimUtil.inlineTrimA = function(start1,start2,end1,end2,ignored1,ignored2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start = start1;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not ignored1(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start1 = start;
  local _end = end1;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not ignored1(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end1 = _end;
  local start = start2;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not ignored2(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start2 = start;
  local _end = end2;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not ignored2(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end2 = _end;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.inlineTrimB = function(start1,start2,start3,end1,end2,end3,ignored1,ignored2,ignored3) 
  local start1 = start1;
  local start2 = start2;
  local start3 = start3;
  local end1 = end1;
  local end2 = end2;
  local end3 = end3;
  local start = start1;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not ignored1(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start1 = start;
  local _end = end1;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not ignored1(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end1 = _end;
  local start = start2;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not ignored2(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start2 = start;
  local _end = end2;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not ignored2(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end2 = _end;
  local start = start3;
  while (start < end3) do _hx_do_first_1 = false;
    
    if (not ignored3(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start3 = start;
  local _end = end3;
  while (start3 < _end) do _hx_do_first_1 = false;
    
    if (not ignored3(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end3 = _end;
  do return __diff_util_MergeRange.new(start1, end1, start2, end2, start3, end3) end;
end
__diff_comparison_TrimUtil.inlineTrimC = function(start,_end,ignored) 
  local start = start;
  local _end = _end;
  local start1 = start;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not ignored(start1)) then 
      break;
    end;
    start1 = start1 + 1;
  end;
  start = start1;
  local end1 = _end;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not ignored(end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
  end;
  _end = end1;
  do return __ds_Pair.new(start, _end) end;
end
__diff_comparison_TrimUtil.inlineTrimStartA = function(start,_end,ignored) 
  local start = start;
  while (start < _end) do _hx_do_first_1 = false;
    
    if (not ignored(start)) then 
      break;
    end;
    start = start + 1;
  end;
  do return start end;
end
__diff_comparison_TrimUtil.inlineTrimEndA = function(start,_end,ignored) 
  local _end = _end;
  while (start < _end) do _hx_do_first_1 = false;
    
    if (not ignored(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  do return _end end;
end
__diff_comparison_TrimUtil.inlineExpand = function(start1,start2,end1,end2,equals) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local oldStart1 = start11;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    
    if (not equals(start11, start21)) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  local end11 = end1;
  local end21 = end2;
  local oldEnd1 = end11;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    
    if (not equals(end11 - 1, end21 - 1)) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.inlineExpandForwardA = function(start1,start2,end1,end2,equals) 
  local start1 = start1;
  local start2 = start2;
  local oldStart1 = start1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (not equals(start1, start2)) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.inlineExpandBackwardA = function(start1,start2,end1,end2,equals) 
  local end1 = end1;
  local end2 = end2;
  local oldEnd1 = end1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (not equals(end1 - 1, end2 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.inlineExpandIgnoredA = function(start1,start2,end1,end2,equals,ignored1) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local oldStart1 = start11;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    
    if (not equals(start11, start21)) then 
      break;
    end;
    if (not ignored1(start11)) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  local end11 = end1;
  local end21 = end2;
  local oldEnd1 = end11;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    
    if (not equals(end11 - 1, end21 - 1)) then 
      break;
    end;
    if (not ignored1(end11 - 1)) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.inlineExpandIgnoredForwardA = function(start1,start2,end1,end2,equals,ignored1) 
  local start1 = start1;
  local start2 = start2;
  local oldStart1 = start1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (not equals(start1, start2)) then 
      break;
    end;
    if (not ignored1(start1)) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.inlineExpandIgnoredBackwardA = function(start1,start2,end1,end2,equals,ignored1) 
  local end1 = end1;
  local end2 = end2;
  local oldEnd1 = end1;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    
    if (not equals(end1 - 1, end2 - 1)) then 
      break;
    end;
    if (not ignored1(end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.inlineExpandIgnoredB = function(start1,start2,start3,end1,end2,end3,equals12,equals13,ignored1) 
  local start1 = start1;
  local start2 = start2;
  local start3 = start3;
  local end1 = end1;
  local end2 = end2;
  local end3 = end3;
  local start11 = start1;
  local start21 = start2;
  local start31 = start3;
  local oldStart1 = start11;
  while (((start11 < end1) and (start21 < end2)) and (start31 < end3)) do _hx_do_first_1 = false;
    
    if (not equals12(start11, start21)) then 
      break;
    end;
    if (not equals13(start11, start31)) then 
      break;
    end;
    if (not ignored1(start11)) then 
      break;
    end;
    start11 = start11 + 1;
    start21 = start21 + 1;
    start31 = start31 + 1;
  end;
  local count1 = start11 - oldStart1;
  start1 = start1 + count1;
  start2 = start2 + count1;
  start3 = start3 + count1;
  local end11 = end1;
  local end21 = end2;
  local end31 = end3;
  local oldEnd1 = end11;
  while (((start1 < end11) and (start2 < end21)) and (start3 < end31)) do _hx_do_first_1 = false;
    
    if (not equals12(end11 - 1, end21 - 1)) then 
      break;
    end;
    if (not equals13(end11 - 1, end31 - 1)) then 
      break;
    end;
    if (not ignored1(end11 - 1)) then 
      break;
    end;
    end11 = end11 - 1;
    end21 = end21 - 1;
    end31 = end31 - 1;
  end;
  local count2 = oldEnd1 - end11;
  end1 = end1 - count2;
  end2 = end2 - count2;
  end3 = end3 - count2;
  do return __diff_util_MergeRange.new(start1, end1, start2, end2, start3, end3) end;
end
__diff_comparison_TrimUtil.inlineExpandIgnoredForwardB = function(start1,start2,start3,end1,end2,end3,equals12,equals13,ignored1) 
  local start1 = start1;
  local start2 = start2;
  local start3 = start3;
  local oldStart1 = start1;
  while (((start1 < end1) and (start2 < end2)) and (start3 < end3)) do _hx_do_first_1 = false;
    
    if (not equals12(start1, start2)) then 
      break;
    end;
    if (not equals13(start1, start3)) then 
      break;
    end;
    if (not ignored1(start1)) then 
      break;
    end;
    start1 = start1 + 1;
    start2 = start2 + 1;
    start3 = start3 + 1;
  end;
  do return start1 - oldStart1 end;
end
__diff_comparison_TrimUtil.inlineExpandIgnoredBackwardB = function(start1,start2,start3,end1,end2,end3,equals12,equals13,ignored1) 
  local end1 = end1;
  local end2 = end2;
  local end3 = end3;
  local oldEnd1 = end1;
  while (((start1 < end1) and (start2 < end2)) and (start3 < end3)) do _hx_do_first_1 = false;
    
    if (not equals12(end1 - 1, end2 - 1)) then 
      break;
    end;
    if (not equals13(end1 - 1, end3 - 1)) then 
      break;
    end;
    if (not ignored1(end1 - 1)) then 
      break;
    end;
    end1 = end1 - 1;
    end2 = end2 - 1;
    end3 = end3 - 1;
  end;
  do return oldEnd1 - end1 end;
end
__diff_comparison_TrimUtil.inlineTrimExpandA = function(start1,start2,end1,end2,equals,ignored1,ignored2) 
  local start1 = start1;
  local start2 = start2;
  local end1 = end1;
  local end2 = end2;
  local start11 = start1;
  local start21 = start2;
  local _hx_continue_1 = false;
  while ((start11 < end1) and (start21 < end2)) do _hx_do_first_1 = false;
    repeat 
    if (equals(start11, start21)) then 
      start11 = start11 + 1;
      start21 = start21 + 1;
      break;
    end;
    local skipped = false;
    if (ignored1(start11)) then 
      skipped = true;
      start11 = start11 + 1;
    end;
    if (ignored2(start21)) then 
      skipped = true;
      start21 = start21 + 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local start = start11;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not ignored1(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start11 = start;
  local start = start21;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not ignored2(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start21 = start;
  local starts = __ds_Pair.new(start11, start21);
  start1 = starts.first;
  start2 = starts.second;
  local end11 = end1;
  local end21 = end2;
  local _hx_continue_1 = false;
  while ((start1 < end11) and (start2 < end21)) do _hx_do_first_1 = false;
    repeat 
    if (equals(end11 - 1, end21 - 1)) then 
      end11 = end11 - 1;
      end21 = end21 - 1;
      break;
    end;
    local skipped = false;
    if (ignored1(end11 - 1)) then 
      skipped = true;
      end11 = end11 - 1;
    end;
    if (ignored2(end21 - 1)) then 
      skipped = true;
      end21 = end21 - 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _end = end11;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not ignored1(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end11 = _end;
  local _end = end21;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not ignored2(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end21 = _end;
  local ends = __ds_Pair.new(end11, end21);
  end1 = ends.first;
  end2 = ends.second;
  do return __diff_util_Range.new(start1, end1, start2, end2) end;
end
__diff_comparison_TrimUtil.inlineTrimExpandForwardA = function(start1,start2,end1,end2,equals,ignored1,ignored2) 
  local start1 = start1;
  local start2 = start2;
  local _hx_continue_1 = false;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    repeat 
    if (equals(start1, start2)) then 
      start1 = start1 + 1;
      start2 = start2 + 1;
      break;
    end;
    local skipped = false;
    if (ignored1(start1)) then 
      skipped = true;
      start1 = start1 + 1;
    end;
    if (ignored2(start2)) then 
      skipped = true;
      start2 = start2 + 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local start = start1;
  while (start < end1) do _hx_do_first_1 = false;
    
    if (not ignored1(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start1 = start;
  local start = start2;
  while (start < end2) do _hx_do_first_1 = false;
    
    if (not ignored2(start)) then 
      break;
    end;
    start = start + 1;
  end;
  start2 = start;
  do return __ds_Pair.new(start1, start2) end;
end
__diff_comparison_TrimUtil.inlineTrimExpandBackwardA = function(start1,start2,end1,end2,equals,ignored1,ignored2) 
  local end1 = end1;
  local end2 = end2;
  local _hx_continue_1 = false;
  while ((start1 < end1) and (start2 < end2)) do _hx_do_first_1 = false;
    repeat 
    if (equals(end1 - 1, end2 - 1)) then 
      end1 = end1 - 1;
      end2 = end2 - 1;
      break;
    end;
    local skipped = false;
    if (ignored1(end1 - 1)) then 
      skipped = true;
      end1 = end1 - 1;
    end;
    if (ignored2(end2 - 1)) then 
      skipped = true;
      end2 = end2 - 1;
    end;
    if (not skipped) then 
      _hx_continue_1 = true;break;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _end = end1;
  while (start1 < _end) do _hx_do_first_1 = false;
    
    if (not ignored1(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end1 = _end;
  local _end = end2;
  while (start2 < _end) do _hx_do_first_1 = false;
    
    if (not ignored2(_end - 1)) then 
      break;
    end;
    _end = _end - 1;
  end;
  end2 = _end;
  do return __ds_Pair.new(end1, end2) end;
end

__diff_comparison_iterables_ChangeIterable.new = {}
__diff_comparison_iterables_ChangeIterable.__name__ = "diff.comparison.iterables.ChangeIterable"
__diff_comparison_iterables_ChangeIterable.prototype = _hx_e();
__diff_comparison_iterables_ChangeIterable.prototype.valid= nil;
__diff_comparison_iterables_ChangeIterable.prototype.next= nil;
__diff_comparison_iterables_ChangeIterable.prototype.getStart1= nil;
__diff_comparison_iterables_ChangeIterable.prototype.getStart2= nil;
__diff_comparison_iterables_ChangeIterable.prototype.getEnd1= nil;
__diff_comparison_iterables_ChangeIterable.prototype.getEnd2= nil;

__diff_comparison_iterables_ChangeIterable.prototype.__class__ =  __diff_comparison_iterables_ChangeIterable

__diff_comparison_iterables_DiffIterable.new = {}
__diff_comparison_iterables_DiffIterable.__name__ = "diff.comparison.iterables.DiffIterable"
__diff_comparison_iterables_DiffIterable.prototype = _hx_e();
__diff_comparison_iterables_DiffIterable.prototype.getLength1= nil;
__diff_comparison_iterables_DiffIterable.prototype.getLength2= nil;
__diff_comparison_iterables_DiffIterable.prototype.changes= nil;
__diff_comparison_iterables_DiffIterable.prototype.unchanged= nil;
__diff_comparison_iterables_DiffIterable.prototype.iterateChanges = function(self) 
  do return __diff_comparison_iterables_GenericIterable_diff_util_Range.new(self:changes()) end
end
__diff_comparison_iterables_DiffIterable.prototype.iterateUnchanged = function(self) 
  do return __diff_comparison_iterables_GenericIterable_diff_util_Range.new(self:unchanged()) end
end

__diff_comparison_iterables_DiffIterable.prototype.__class__ =  __diff_comparison_iterables_DiffIterable

__diff_comparison_iterables_ChangeDiffIterableBase.new = function(length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_ChangeDiffIterableBase.prototype)
  __diff_comparison_iterables_ChangeDiffIterableBase.super(self,length1,length2)
  return self
end
__diff_comparison_iterables_ChangeDiffIterableBase.super = function(self,length1,length2) 
  self.myLength1 = length1;
  self.myLength2 = length2;
end
__diff_comparison_iterables_ChangeDiffIterableBase.__name__ = "diff.comparison.iterables.ChangeDiffIterableBase"
__diff_comparison_iterables_ChangeDiffIterableBase.prototype = _hx_e();
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.myLength1= nil;
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.myLength2= nil;
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.getLength1 = function(self) 
  do return self.myLength1 end
end
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.getLength2 = function(self) 
  do return self.myLength2 end
end
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.changes = function(self) 
  do return __diff_comparison_iterables_ChangedIterator.new(self:createChangeIterable()) end
end
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.unchanged = function(self) 
  do return __diff_comparison_iterables_UnchangedIterator.new(self:createChangeIterable(), self.myLength1, self.myLength2) end
end
__diff_comparison_iterables_ChangeDiffIterableBase.prototype.createChangeIterable= nil;

__diff_comparison_iterables_ChangeDiffIterableBase.prototype.__class__ =  __diff_comparison_iterables_ChangeDiffIterableBase
__diff_comparison_iterables_ChangeDiffIterableBase.__super__ = __diff_comparison_iterables_DiffIterable
setmetatable(__diff_comparison_iterables_ChangeDiffIterableBase.prototype,{__index=__diff_comparison_iterables_DiffIterable.prototype})

__diff_comparison_iterables_ChangedIterator.new = function(iterable) 
  local self = _hx_new(__diff_comparison_iterables_ChangedIterator.prototype)
  __diff_comparison_iterables_ChangedIterator.super(self,iterable)
  return self
end
__diff_comparison_iterables_ChangedIterator.super = function(self,iterable) 
  self.myIterable = iterable;
end
__diff_comparison_iterables_ChangedIterator.__name__ = "diff.comparison.iterables.ChangedIterator"
__diff_comparison_iterables_ChangedIterator.prototype = _hx_e();
__diff_comparison_iterables_ChangedIterator.prototype.myIterable= nil;
__diff_comparison_iterables_ChangedIterator.prototype.hasNext = function(self) 
  do return self.myIterable:valid() end
end
__diff_comparison_iterables_ChangedIterator.prototype.next = function(self) 
  local range = __diff_util_Range.new(self.myIterable:getStart1(), self.myIterable:getEnd1(), self.myIterable:getStart2(), self.myIterable:getEnd2());
  self.myIterable:next();
  do return range end
end

__diff_comparison_iterables_ChangedIterator.prototype.__class__ =  __diff_comparison_iterables_ChangedIterator

__diff_comparison_iterables_UnchangedIterator.new = function(iterable,length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_UnchangedIterator.prototype)
  __diff_comparison_iterables_UnchangedIterator.super(self,iterable,length1,length2)
  return self
end
__diff_comparison_iterables_UnchangedIterator.super = function(self,iterable,length1,length2) 
  self.lastIndex2 = 0;
  self.lastIndex1 = 0;
  self.myIterable = iterable;
  self.myLength1 = length1;
  self.myLength2 = length2;
  if (self.myIterable:valid()) then 
    if ((self.myIterable:getStart1() == 0) and (self.myIterable:getStart2() == 0)) then 
      self.lastIndex1 = self.myIterable:getEnd1();
      self.lastIndex2 = self.myIterable:getEnd2();
      self.myIterable:next();
    end;
  end;
end
__diff_comparison_iterables_UnchangedIterator.__name__ = "diff.comparison.iterables.UnchangedIterator"
__diff_comparison_iterables_UnchangedIterator.prototype = _hx_e();
__diff_comparison_iterables_UnchangedIterator.prototype.myIterable= nil;
__diff_comparison_iterables_UnchangedIterator.prototype.myLength1= nil;
__diff_comparison_iterables_UnchangedIterator.prototype.myLength2= nil;
__diff_comparison_iterables_UnchangedIterator.prototype.lastIndex1= nil;
__diff_comparison_iterables_UnchangedIterator.prototype.lastIndex2= nil;
__diff_comparison_iterables_UnchangedIterator.prototype.hasNext = function(self) 
  if (not self.myIterable:valid()) then 
    if (self.lastIndex1 == self.myLength1) then 
      do return self.lastIndex2 ~= self.myLength2 end;
    else
      do return true end;
    end;
  else
    do return true end;
  end;
end
__diff_comparison_iterables_UnchangedIterator.prototype.next = function(self) 
  if (self.myIterable:valid()) then 
    local chunk = __diff_util_Range.new(self.lastIndex1, self.myIterable:getStart1(), self.lastIndex2, self.myIterable:getStart2());
    self.lastIndex1 = self.myIterable:getEnd1();
    self.lastIndex2 = self.myIterable:getEnd2();
    self.myIterable:next();
    do return chunk end;
  else
    local chunk = __diff_util_Range.new(self.lastIndex1, self.myLength1, self.lastIndex2, self.myLength2);
    self.lastIndex1 = self.myLength1;
    self.lastIndex2 = self.myLength2;
    do return chunk end;
  end;
end

__diff_comparison_iterables_UnchangedIterator.prototype.__class__ =  __diff_comparison_iterables_UnchangedIterator

__diff_comparison_iterables_DiffChangeDiffIterable.new = function(change,length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_DiffChangeDiffIterable.prototype)
  __diff_comparison_iterables_DiffChangeDiffIterable.super(self,change,length1,length2)
  return self
end
__diff_comparison_iterables_DiffChangeDiffIterable.super = function(self,change,length1,length2) 
  __diff_comparison_iterables_ChangeDiffIterableBase.super(self,length1,length2);
  self.myChange = change;
end
__diff_comparison_iterables_DiffChangeDiffIterable.__name__ = "diff.comparison.iterables.DiffChangeDiffIterable"
__diff_comparison_iterables_DiffChangeDiffIterable.prototype = _hx_e();
__diff_comparison_iterables_DiffChangeDiffIterable.prototype.myChange= nil;
__diff_comparison_iterables_DiffChangeDiffIterable.prototype.createChangeIterable = function(self) 
  do return __diff_comparison_iterables_DiffChangeChangeIterable.new(self.myChange) end
end

__diff_comparison_iterables_DiffChangeDiffIterable.prototype.__class__ =  __diff_comparison_iterables_DiffChangeDiffIterable
__diff_comparison_iterables_DiffChangeDiffIterable.__super__ = __diff_comparison_iterables_ChangeDiffIterableBase
setmetatable(__diff_comparison_iterables_DiffChangeDiffIterable.prototype,{__index=__diff_comparison_iterables_ChangeDiffIterableBase.prototype})

__diff_comparison_iterables_DiffChangeChangeIterable.new = function(change) 
  local self = _hx_new(__diff_comparison_iterables_DiffChangeChangeIterable.prototype)
  __diff_comparison_iterables_DiffChangeChangeIterable.super(self,change)
  return self
end
__diff_comparison_iterables_DiffChangeChangeIterable.super = function(self,change) 
  self.myChange = change;
end
__diff_comparison_iterables_DiffChangeChangeIterable.__name__ = "diff.comparison.iterables.DiffChangeChangeIterable"
__diff_comparison_iterables_DiffChangeChangeIterable.__interfaces__ = {__diff_comparison_iterables_ChangeIterable}
__diff_comparison_iterables_DiffChangeChangeIterable.prototype = _hx_e();
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.myChange= nil;
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.valid = function(self) 
  do return self.myChange ~= nil end
end
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.next = function(self) 
  self.myChange = self.myChange.link;
end
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.getStart1 = function(self) 
  do return self.myChange.line0 end
end
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.getStart2 = function(self) 
  do return self.myChange.line1 end
end
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.getEnd1 = function(self) 
  do return self.myChange.line0 + self.myChange.deleted end
end
__diff_comparison_iterables_DiffChangeChangeIterable.prototype.getEnd2 = function(self) 
  do return self.myChange.line1 + self.myChange.inserted end
end

__diff_comparison_iterables_DiffChangeChangeIterable.prototype.__class__ =  __diff_comparison_iterables_DiffChangeChangeIterable

__diff_comparison_iterables_DiffFragmentsDiffIterable.new = function(ranges,length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_DiffFragmentsDiffIterable.prototype)
  __diff_comparison_iterables_DiffFragmentsDiffIterable.super(self,ranges,length1,length2)
  return self
end
__diff_comparison_iterables_DiffFragmentsDiffIterable.super = function(self,ranges,length1,length2) 
  __diff_comparison_iterables_ChangeDiffIterableBase.super(self,length1,length2);
  self.myFragments = ranges;
end
__diff_comparison_iterables_DiffFragmentsDiffIterable.__name__ = "diff.comparison.iterables.DiffFragmentsDiffIterable"
__diff_comparison_iterables_DiffFragmentsDiffIterable.prototype = _hx_e();
__diff_comparison_iterables_DiffFragmentsDiffIterable.prototype.myFragments= nil;
__diff_comparison_iterables_DiffFragmentsDiffIterable.prototype.createChangeIterable = function(self) 
  do return __diff_comparison_iterables_FragmentsChangeIterable.new(self.myFragments) end
end

__diff_comparison_iterables_DiffFragmentsDiffIterable.prototype.__class__ =  __diff_comparison_iterables_DiffFragmentsDiffIterable
__diff_comparison_iterables_DiffFragmentsDiffIterable.__super__ = __diff_comparison_iterables_ChangeDiffIterableBase
setmetatable(__diff_comparison_iterables_DiffFragmentsDiffIterable.prototype,{__index=__diff_comparison_iterables_ChangeDiffIterableBase.prototype})

__diff_comparison_iterables_FragmentsChangeIterable.new = function(fragments) 
  local self = _hx_new(__diff_comparison_iterables_FragmentsChangeIterable.prototype)
  __diff_comparison_iterables_FragmentsChangeIterable.super(self,fragments)
  return self
end
__diff_comparison_iterables_FragmentsChangeIterable.super = function(self,fragments) 
  self.myIterator = __haxe_iterators_ArrayIterator.new(fragments);
  self:next();
end
__diff_comparison_iterables_FragmentsChangeIterable.__name__ = "diff.comparison.iterables.FragmentsChangeIterable"
__diff_comparison_iterables_FragmentsChangeIterable.__interfaces__ = {__diff_comparison_iterables_ChangeIterable}
__diff_comparison_iterables_FragmentsChangeIterable.prototype = _hx_e();
__diff_comparison_iterables_FragmentsChangeIterable.prototype.myIterator= nil;
__diff_comparison_iterables_FragmentsChangeIterable.prototype.myLast= nil;
__diff_comparison_iterables_FragmentsChangeIterable.prototype.valid = function(self) 
  do return self.myLast ~= nil end
end
__diff_comparison_iterables_FragmentsChangeIterable.prototype.next = function(self) 
  self.myLast = (function() 
    local _hx_1
    if (self.myIterator:hasNext()) then 
    _hx_1 = self.myIterator:next(); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
end
__diff_comparison_iterables_FragmentsChangeIterable.prototype.getStart1 = function(self) 
  do return self.myLast:getStartOffset1() end
end
__diff_comparison_iterables_FragmentsChangeIterable.prototype.getStart2 = function(self) 
  do return self.myLast:getStartOffset2() end
end
__diff_comparison_iterables_FragmentsChangeIterable.prototype.getEnd1 = function(self) 
  do return self.myLast:getEndOffset1() end
end
__diff_comparison_iterables_FragmentsChangeIterable.prototype.getEnd2 = function(self) 
  do return self.myLast:getEndOffset2() end
end

__diff_comparison_iterables_FragmentsChangeIterable.prototype.__class__ =  __diff_comparison_iterables_FragmentsChangeIterable

__diff_comparison_iterables_GenericIterable.new = function(data) 
  local self = _hx_new(__diff_comparison_iterables_GenericIterable.prototype)
  __diff_comparison_iterables_GenericIterable.super(self,data)
  return self
end
__diff_comparison_iterables_GenericIterable.super = function(self,data) 
  self.data = data;
end
__diff_comparison_iterables_GenericIterable.__name__ = "diff.comparison.iterables.GenericIterable"
__diff_comparison_iterables_GenericIterable.prototype = _hx_e();
__diff_comparison_iterables_GenericIterable.prototype.data= nil;
__diff_comparison_iterables_GenericIterable.prototype.iterator = function(self) 
  do return self.data end
end

__diff_comparison_iterables_GenericIterable.prototype.__class__ =  __diff_comparison_iterables_GenericIterable

__diff_comparison_iterables_DiffIterableUtil.new = {}
__diff_comparison_iterables_DiffIterableUtil.__name__ = "diff.comparison.iterables.DiffIterableUtil"
__diff_comparison_iterables_DiffIterableUtil.diffB_diff_comparison_InlineChunk_Dynamic = function(data1,data2) 
  local fairIter;
  local _hx_status, _hx_result = pcall(function() 
  
      local change = __util_diff_Diff.buildChangesB_diffB_T(data1, data2);
      fairIter = __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createA(change, data1.length, data2.length));
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
      _G.error(__diff_comparison_DiffTooBigException.new(""),0);
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return fairIter end;
end
__diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_Line = function(data1,data2) 
  local fairIter;
  local _hx_status, _hx_result = pcall(function() 
  
      local change = __util_diff_Diff.buildChangesX_diffX_T(data1, data2);
      fairIter = __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createA(change, data1.length, data2.length));
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
      _G.error(__diff_comparison_DiffTooBigException.new(""),0);
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return fairIter end;
end
__diff_comparison_iterables_DiffIterableUtil.diffX_diff_comparison_InlineChunk_Dynamic = function(data1,data2) 
  local fairIter;
  local _hx_status, _hx_result = pcall(function() 
  
      local change = __util_diff_Diff.buildChangesX_diffX_T(data1, data2);
      fairIter = __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createA(change, data1.length, data2.length));
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
      _G.error(__diff_comparison_DiffTooBigException.new(""),0);
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return fairIter end;
end
__diff_comparison_iterables_DiffIterableUtil.diffA = function(data1,data2) 
  local fair;
  local _hx_status, _hx_result = pcall(function() 
  
      local change = __util_diff_Diff.buildChangesC(data1, data2);
      fair = __diff_comparison_iterables_DiffIterableUtil.fair(__diff_comparison_iterables_DiffIterableUtil.createA(change, data1.length, data2.length));
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
      _G.error(__diff_comparison_DiffTooBigException.new(""),0);
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return fair end;
end
__diff_comparison_iterables_DiffIterableUtil.createA = function(change,length1,length2) 
  local iterable = __diff_comparison_iterables_DiffChangeDiffIterable.new(change, length1, length2);
  __diff_comparison_iterables_DiffIterableUtil.verifyA(iterable);
  do return iterable end;
end
__diff_comparison_iterables_DiffIterableUtil.createB = function(ranges,length1,length2) 
  local iterable = __diff_comparison_iterables_RangesDiffIterable.new(ranges, length1, length2);
  __diff_comparison_iterables_DiffIterableUtil.verifyA(iterable);
  do return iterable end;
end
__diff_comparison_iterables_DiffIterableUtil.createFragments = function(fragments,length1,length2) 
  local iterable = __diff_comparison_iterables_DiffFragmentsDiffIterable.new(fragments, length1, length2);
  __diff_comparison_iterables_DiffIterableUtil.verifyA(iterable);
  do return iterable end;
end
__diff_comparison_iterables_DiffIterableUtil.createUnchanged = function(ranges,length1,length2) 
  local invert = __diff_comparison_iterables_DiffIterableUtil.invert(__diff_comparison_iterables_DiffIterableUtil.createB(ranges, length1, length2));
  __diff_comparison_iterables_DiffIterableUtil.verifyA(invert);
  do return invert end;
end
__diff_comparison_iterables_DiffIterableUtil.invert = function(iterable) 
  local wrapper = __diff_comparison_iterables_InvertedDiffIterableWrapper.new(iterable);
  __diff_comparison_iterables_DiffIterableUtil.verifyA(wrapper);
  do return wrapper end;
end
__diff_comparison_iterables_DiffIterableUtil.fair = function(iterable) 
  if ((function() 
    local _hx_1
    if (__lua_Boot.__instanceof(iterable, __diff_comparison_iterables_FairDiffIterable)) then 
    _hx_1 = iterable; else 
    _hx_1 = nil; end
    return _hx_1
  end )() ~= nil) then 
    do return __lua_Boot.__cast(iterable , __diff_comparison_iterables_FairDiffIterable) end;
  end;
  local wrapper = __diff_comparison_iterables_FairDiffIterableWrapper.new(iterable);
  __diff_comparison_iterables_DiffIterableUtil.verifyFair(wrapper);
  do return wrapper end;
end
__diff_comparison_iterables_DiffIterableUtil.expandedIterable = function(iterable,offset1,offset2,length1,length2) 
  do return __diff_comparison_iterables_ExpandedDiffIterable.new(iterable, offset1, offset2, length1, length2) end;
end
__diff_comparison_iterables_DiffIterableUtil.iterateAll = function(iterable) 
  do return __diff_comparison_iterables_IterateAllIterator.new(iterable) end;
end
__diff_comparison_iterables_DiffIterableUtil.getRangeDelta = function(range) 
  local deleted = range.end1 - range.start1;
  local inserted = range.end2 - range.start2;
  do return inserted - deleted end;
end
__diff_comparison_iterables_DiffIterableUtil.setVerifyEnabled = function(value) 
  __diff_comparison_iterables_DiffIterableUtil.SHOULD_VERIFY_ITERABLE = value;
end
__diff_comparison_iterables_DiffIterableUtil.isVerifyEnabled = function() 
  do return __diff_comparison_iterables_DiffIterableUtil.SHOULD_VERIFY_ITERABLE end;
end
__diff_comparison_iterables_DiffIterableUtil.verifyA = function(iterable) 
  if (not __diff_comparison_iterables_DiffIterableUtil.isVerifyEnabled()) then 
    do return end;
  end;
  __diff_comparison_iterables_DiffIterableUtil.verifyB(iterable:iterateChanges());
  __diff_comparison_iterables_DiffIterableUtil.verifyB(iterable:iterateUnchanged());
  __diff_comparison_iterables_DiffIterableUtil.verifyFullCover(iterable);
end
__diff_comparison_iterables_DiffIterableUtil.verifyB = function(iterable) 
  local range = iterable:iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
  end;
end
__diff_comparison_iterables_DiffIterableUtil.verifyFair = function(iterable) 
  if (not __diff_comparison_iterables_DiffIterableUtil.isVerifyEnabled()) then 
    do return end;
  end;
  __diff_comparison_iterables_DiffIterableUtil.verifyA(iterable);
  local range = iterable:iterateUnchanged():iterator();
  while (range:hasNext()) do _hx_do_first_1 = false;
    
    local range = range:next();
  end;
end
__diff_comparison_iterables_DiffIterableUtil.verifyFullCover = function(iterable) 
  local last1 = 0;
  local last2 = 0;
  local lastEquals = nil;
  local pair = __diff_comparison_iterables_DiffIterableUtil.iterateAll(iterable);
  while (pair:hasNext()) do _hx_do_first_1 = false;
    
    local pair = pair:next();
    local range = pair.first;
    local equal = pair.second;
    last1 = range.end1;
    last2 = range.end2;
    lastEquals = equal;
  end;
end

__diff_comparison_iterables_ChangeBuilderBase.new = function(length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_ChangeBuilderBase.prototype)
  __diff_comparison_iterables_ChangeBuilderBase.super(self,length1,length2)
  return self
end
__diff_comparison_iterables_ChangeBuilderBase.super = function(self,length1,length2) 
  self.myIndex2 = 0;
  self.myIndex1 = 0;
  self.myLength1 = length1;
  self.myLength2 = length2;
end
__diff_comparison_iterables_ChangeBuilderBase.__name__ = "diff.comparison.iterables.ChangeBuilderBase"
__diff_comparison_iterables_ChangeBuilderBase.prototype = _hx_e();
__diff_comparison_iterables_ChangeBuilderBase.prototype.myLength1= nil;
__diff_comparison_iterables_ChangeBuilderBase.prototype.myLength2= nil;
__diff_comparison_iterables_ChangeBuilderBase.prototype.myIndex1= nil;
__diff_comparison_iterables_ChangeBuilderBase.prototype.myIndex2= nil;
__diff_comparison_iterables_ChangeBuilderBase.prototype.getIndex1 = function(self) 
  do return self.myIndex1 end
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.getIndex2 = function(self) 
  do return self.myIndex2 end
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.getLength1 = function(self) 
  do return self.myLength1 end
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.getLength2 = function(self) 
  do return self.myLength2 end
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.markEqualA = function(self,index1,index2) 
  self:markEqualB(index1, index2, 1);
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.markEqualB = function(self,index1,index2,count) 
  self:markEqualC(index1, index2, index1 + count, index2 + count);
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.markEqualC = function(self,index1,index2,end1,end2) 
  if ((index1 == end1) and (index2 == end2)) then 
    do return end;
  end;
  if ((self.myIndex1 ~= index1) or (self.myIndex2 ~= index2)) then 
    self:addChange(self.myIndex1, self.myIndex2, index1, index2);
  end;
  self.myIndex1 = end1;
  self.myIndex2 = end2;
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.doFinish = function(self) 
  if ((self.myLength1 ~= self.myIndex1) or (self.myLength2 ~= self.myIndex2)) then 
    self:addChange(self.myIndex1, self.myIndex2, self.myLength1, self.myLength2);
    self.myIndex1 = self.myLength1;
    self.myIndex2 = self.myLength2;
  end;
end
__diff_comparison_iterables_ChangeBuilderBase.prototype.addChange= nil;

__diff_comparison_iterables_ChangeBuilderBase.prototype.__class__ =  __diff_comparison_iterables_ChangeBuilderBase

__diff_comparison_iterables_ChangeBuilder.new = function(length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_ChangeBuilder.prototype)
  __diff_comparison_iterables_ChangeBuilder.super(self,length1,length2)
  return self
end
__diff_comparison_iterables_ChangeBuilder.super = function(self,length1,length2) 
  __diff_comparison_iterables_ChangeBuilderBase.super(self,length1,length2);
end
__diff_comparison_iterables_ChangeBuilder.__name__ = "diff.comparison.iterables.ChangeBuilder"
__diff_comparison_iterables_ChangeBuilder.prototype = _hx_e();
__diff_comparison_iterables_ChangeBuilder.prototype.myFirstChange= nil;
__diff_comparison_iterables_ChangeBuilder.prototype.myLastChange= nil;
__diff_comparison_iterables_ChangeBuilder.prototype.addChange = function(self,start1,start2,end1,end2) 
  local change = __util_diff_Change.new(start1, start2, end1 - start1, end2 - start2, nil);
  if (self.myLastChange ~= nil) then 
    self.myLastChange.link = change;
  else
    self.myFirstChange = change;
  end;
  self.myLastChange = change;
end
__diff_comparison_iterables_ChangeBuilder.prototype.finish = function(self) 
  self:doFinish();
  do return __diff_comparison_iterables_DiffIterableUtil.createA(self.myFirstChange, self:getLength1(), self:getLength2()) end
end

__diff_comparison_iterables_ChangeBuilder.prototype.__class__ =  __diff_comparison_iterables_ChangeBuilder
__diff_comparison_iterables_ChangeBuilder.__super__ = __diff_comparison_iterables_ChangeBuilderBase
setmetatable(__diff_comparison_iterables_ChangeBuilder.prototype,{__index=__diff_comparison_iterables_ChangeBuilderBase.prototype})

__diff_comparison_iterables_ExpandChangeBuilder.new = function(objects1,objects2) 
  local self = _hx_new(__diff_comparison_iterables_ExpandChangeBuilder.prototype)
  __diff_comparison_iterables_ExpandChangeBuilder.super(self,objects1,objects2)
  return self
end
__diff_comparison_iterables_ExpandChangeBuilder.super = function(self,objects1,objects2) 
  __diff_comparison_iterables_ChangeBuilder.super(self,objects1.length,objects2.length);
  self.myObjects1 = objects1;
  self.myObjects2 = objects2;
end
__diff_comparison_iterables_ExpandChangeBuilder.__name__ = "diff.comparison.iterables.ExpandChangeBuilder"
__diff_comparison_iterables_ExpandChangeBuilder.prototype = _hx_e();
__diff_comparison_iterables_ExpandChangeBuilder.prototype.myObjects1= nil;
__diff_comparison_iterables_ExpandChangeBuilder.prototype.myObjects2= nil;
__diff_comparison_iterables_ExpandChangeBuilder.prototype.addChange = function(self,start1,start2,end1,end2) 
  local range = __diff_comparison_TrimUtil.expandA(self.myObjects1, self.myObjects2, start1, start2, end1, end2);
  if (not range:isEmpty()) then 
    __diff_comparison_iterables_ChangeBuilder.prototype.addChange(self,range.start1,range.start2,range.end1,range.end2);
  end;
end

__diff_comparison_iterables_ExpandChangeBuilder.prototype.__class__ =  __diff_comparison_iterables_ExpandChangeBuilder
__diff_comparison_iterables_ExpandChangeBuilder.__super__ = __diff_comparison_iterables_ChangeBuilder
setmetatable(__diff_comparison_iterables_ExpandChangeBuilder.prototype,{__index=__diff_comparison_iterables_ChangeBuilder.prototype})

__diff_comparison_iterables_LineRangeData.new = function(objects1,objects2,equals) 
  local self = _hx_new(__diff_comparison_iterables_LineRangeData.prototype)
  __diff_comparison_iterables_LineRangeData.super(self,objects1,objects2,equals)
  return self
end
__diff_comparison_iterables_LineRangeData.super = function(self,objects1,objects2,equals) 
  self.equals = equals;
  self.objects1 = objects1;
  self.objects2 = objects2;
end
__diff_comparison_iterables_LineRangeData.__name__ = "diff.comparison.iterables.LineRangeData"
__diff_comparison_iterables_LineRangeData.prototype = _hx_e();
__diff_comparison_iterables_LineRangeData.prototype.equals= nil;
__diff_comparison_iterables_LineRangeData.prototype.objects1= nil;
__diff_comparison_iterables_LineRangeData.prototype.objects2= nil;

__diff_comparison_iterables_LineRangeData.prototype.__class__ =  __diff_comparison_iterables_LineRangeData

__diff_comparison_iterables_IterateAllIterator.new = function(iterable) 
  local self = _hx_new(__diff_comparison_iterables_IterateAllIterator.prototype)
  __diff_comparison_iterables_IterateAllIterator.super(self,iterable)
  return self
end
__diff_comparison_iterables_IterateAllIterator.super = function(self,iterable) 
  self.myChanges = iterable:changes();
  self.myUnchanged = iterable:unchanged();
  self.lastChanged = (function() 
    local _hx_1
    if (self.myChanges:hasNext()) then 
    _hx_1 = self.myChanges:next(); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  self.lastUnchanged = (function() 
    local _hx_2
    if (self.myUnchanged:hasNext()) then 
    _hx_2 = self.myUnchanged:next(); else 
    _hx_2 = nil; end
    return _hx_2
  end )();
end
__diff_comparison_iterables_IterateAllIterator.__name__ = "diff.comparison.iterables.IterateAllIterator"
__diff_comparison_iterables_IterateAllIterator.prototype = _hx_e();
__diff_comparison_iterables_IterateAllIterator.prototype.myChanges= nil;
__diff_comparison_iterables_IterateAllIterator.prototype.myUnchanged= nil;
__diff_comparison_iterables_IterateAllIterator.prototype.lastChanged= nil;
__diff_comparison_iterables_IterateAllIterator.prototype.lastUnchanged= nil;
__diff_comparison_iterables_IterateAllIterator.prototype.hasNext = function(self) 
  if (self.lastChanged == nil) then 
    do return self.lastUnchanged ~= nil end;
  else
    do return true end;
  end;
end
__diff_comparison_iterables_IterateAllIterator.prototype.next = function(self) 
  local equals;
  if (self.lastChanged == nil) then 
    equals = true;
  else
    if (self.lastUnchanged == nil) then 
      equals = false;
    else
      equals = (self.lastUnchanged.start1 < self.lastChanged.start1) or (self.lastUnchanged.start2 < self.lastChanged.start2);
    end;
  end;
  if (equals) then 
    local range = self.lastUnchanged;
    self.lastUnchanged = (function() 
      local _hx_1
      if (self.myUnchanged:hasNext()) then 
      _hx_1 = self.myUnchanged:next(); else 
      _hx_1 = nil; end
      return _hx_1
    end )();
    do return __ds_Pair.create_diff_util_Range_Bool(range, true) end;
  else
    local range = self.lastChanged;
    self.lastChanged = (function() 
      local _hx_2
      if (self.myChanges:hasNext()) then 
      _hx_2 = self.myChanges:next(); else 
      _hx_2 = nil; end
      return _hx_2
    end )();
    do return __ds_Pair.create_diff_util_Range_Bool(range, false) end;
  end;
end
__diff_comparison_iterables_IterateAllIterator.prototype.remove = function(self) 
  _G.error(__exceptions_UnsupportedOperationException.new(""),0);
end

__diff_comparison_iterables_IterateAllIterator.prototype.__class__ =  __diff_comparison_iterables_IterateAllIterator

__diff_comparison_iterables_ExpandedDiffIterable.new = function(iterable,offset1,offset2,length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_ExpandedDiffIterable.prototype)
  __diff_comparison_iterables_ExpandedDiffIterable.super(self,iterable,offset1,offset2,length1,length2)
  return self
end
__diff_comparison_iterables_ExpandedDiffIterable.super = function(self,iterable,offset1,offset2,length1,length2) 
  __diff_comparison_iterables_ChangeDiffIterableBase.super(self,length1,length2);
  self.myIterable = iterable;
  self.myOffset1 = offset1;
  self.myOffset2 = offset2;
end
__diff_comparison_iterables_ExpandedDiffIterable.__name__ = "diff.comparison.iterables.ExpandedDiffIterable"
__diff_comparison_iterables_ExpandedDiffIterable.prototype = _hx_e();
__diff_comparison_iterables_ExpandedDiffIterable.prototype.myIterable= nil;
__diff_comparison_iterables_ExpandedDiffIterable.prototype.myOffset1= nil;
__diff_comparison_iterables_ExpandedDiffIterable.prototype.myOffset2= nil;
__diff_comparison_iterables_ExpandedDiffIterable.prototype.createChangeIterable = function(self) 
  do return __diff_comparison_iterables_ShiftedChangeIterable.new(self.myIterable, self.myOffset1, self.myOffset2) end
end

__diff_comparison_iterables_ExpandedDiffIterable.prototype.__class__ =  __diff_comparison_iterables_ExpandedDiffIterable
__diff_comparison_iterables_ExpandedDiffIterable.__super__ = __diff_comparison_iterables_ChangeDiffIterableBase
setmetatable(__diff_comparison_iterables_ExpandedDiffIterable.prototype,{__index=__diff_comparison_iterables_ChangeDiffIterableBase.prototype})

__diff_comparison_iterables_ShiftedChangeIterable.new = function(iterable,offset1,offset2) 
  local self = _hx_new(__diff_comparison_iterables_ShiftedChangeIterable.prototype)
  __diff_comparison_iterables_ShiftedChangeIterable.super(self,iterable,offset1,offset2)
  return self
end
__diff_comparison_iterables_ShiftedChangeIterable.super = function(self,iterable,offset1,offset2) 
  self.myIterator = iterable:changes();
  self.myOffset1 = offset1;
  self.myOffset2 = offset2;
  self:next();
end
__diff_comparison_iterables_ShiftedChangeIterable.__name__ = "diff.comparison.iterables.ShiftedChangeIterable"
__diff_comparison_iterables_ShiftedChangeIterable.__interfaces__ = {__diff_comparison_iterables_ChangeIterable}
__diff_comparison_iterables_ShiftedChangeIterable.prototype = _hx_e();
__diff_comparison_iterables_ShiftedChangeIterable.prototype.myIterator= nil;
__diff_comparison_iterables_ShiftedChangeIterable.prototype.myOffset1= nil;
__diff_comparison_iterables_ShiftedChangeIterable.prototype.myOffset2= nil;
__diff_comparison_iterables_ShiftedChangeIterable.prototype.myLast= nil;
__diff_comparison_iterables_ShiftedChangeIterable.prototype.valid = function(self) 
  do return self.myLast ~= nil end
end
__diff_comparison_iterables_ShiftedChangeIterable.prototype.next = function(self) 
  self.myLast = (function() 
    local _hx_1
    if (self.myIterator:hasNext()) then 
    _hx_1 = self.myIterator:next(); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
end
__diff_comparison_iterables_ShiftedChangeIterable.prototype.getStart1 = function(self) 
  do return self.myLast.start1 + self.myOffset1 end
end
__diff_comparison_iterables_ShiftedChangeIterable.prototype.getStart2 = function(self) 
  do return self.myLast.start2 + self.myOffset2 end
end
__diff_comparison_iterables_ShiftedChangeIterable.prototype.getEnd1 = function(self) 
  do return self.myLast.end1 + self.myOffset1 end
end
__diff_comparison_iterables_ShiftedChangeIterable.prototype.getEnd2 = function(self) 
  do return self.myLast.end2 + self.myOffset2 end
end

__diff_comparison_iterables_ShiftedChangeIterable.prototype.__class__ =  __diff_comparison_iterables_ShiftedChangeIterable

__diff_comparison_iterables_FairDiffIterable.new = {}
__diff_comparison_iterables_FairDiffIterable.__name__ = "diff.comparison.iterables.FairDiffIterable"
__diff_comparison_iterables_FairDiffIterable.prototype = _hx_e();

__diff_comparison_iterables_FairDiffIterable.prototype.__class__ =  __diff_comparison_iterables_FairDiffIterable
__diff_comparison_iterables_FairDiffIterable.__super__ = __diff_comparison_iterables_DiffIterable
setmetatable(__diff_comparison_iterables_FairDiffIterable.prototype,{__index=__diff_comparison_iterables_DiffIterable.prototype})

__diff_comparison_iterables_FairDiffIterableWrapper.new = function(iterable) 
  local self = _hx_new(__diff_comparison_iterables_FairDiffIterableWrapper.prototype)
  __diff_comparison_iterables_FairDiffIterableWrapper.super(self,iterable)
  return self
end
__diff_comparison_iterables_FairDiffIterableWrapper.super = function(self,iterable) 
  self.myIterable = iterable;
end
__diff_comparison_iterables_FairDiffIterableWrapper.__name__ = "diff.comparison.iterables.FairDiffIterableWrapper"
__diff_comparison_iterables_FairDiffIterableWrapper.prototype = _hx_e();
__diff_comparison_iterables_FairDiffIterableWrapper.prototype.myIterable= nil;
__diff_comparison_iterables_FairDiffIterableWrapper.prototype.getLength1 = function(self) 
  do return self.myIterable:getLength1() end
end
__diff_comparison_iterables_FairDiffIterableWrapper.prototype.getLength2 = function(self) 
  do return self.myIterable:getLength2() end
end
__diff_comparison_iterables_FairDiffIterableWrapper.prototype.changes = function(self) 
  do return self.myIterable:changes() end
end
__diff_comparison_iterables_FairDiffIterableWrapper.prototype.unchanged = function(self) 
  do return self.myIterable:unchanged() end
end

__diff_comparison_iterables_FairDiffIterableWrapper.prototype.__class__ =  __diff_comparison_iterables_FairDiffIterableWrapper
__diff_comparison_iterables_FairDiffIterableWrapper.__super__ = __diff_comparison_iterables_FairDiffIterable
setmetatable(__diff_comparison_iterables_FairDiffIterableWrapper.prototype,{__index=__diff_comparison_iterables_FairDiffIterable.prototype})

__diff_comparison_iterables_GenericIterable_diff_util_Range.new = function(data) 
  local self = _hx_new(__diff_comparison_iterables_GenericIterable_diff_util_Range.prototype)
  __diff_comparison_iterables_GenericIterable_diff_util_Range.super(self,data)
  return self
end
__diff_comparison_iterables_GenericIterable_diff_util_Range.super = function(self,data) 
  self.data = data;
end
__diff_comparison_iterables_GenericIterable_diff_util_Range.__name__ = "diff.comparison.iterables.GenericIterable_diff_util_Range"
__diff_comparison_iterables_GenericIterable_diff_util_Range.prototype = _hx_e();
__diff_comparison_iterables_GenericIterable_diff_util_Range.prototype.data= nil;
__diff_comparison_iterables_GenericIterable_diff_util_Range.prototype.iterator = function(self) 
  do return self.data end
end

__diff_comparison_iterables_GenericIterable_diff_util_Range.prototype.__class__ =  __diff_comparison_iterables_GenericIterable_diff_util_Range

__diff_comparison_iterables_InvertedDiffIterableWrapper.new = function(iterable) 
  local self = _hx_new(__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype)
  __diff_comparison_iterables_InvertedDiffIterableWrapper.super(self,iterable)
  return self
end
__diff_comparison_iterables_InvertedDiffIterableWrapper.super = function(self,iterable) 
  self.myIterable = iterable;
end
__diff_comparison_iterables_InvertedDiffIterableWrapper.__name__ = "diff.comparison.iterables.InvertedDiffIterableWrapper"
__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype = _hx_e();
__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype.myIterable= nil;
__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype.getLength1 = function(self) 
  do return self.myIterable:getLength1() end
end
__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype.getLength2 = function(self) 
  do return self.myIterable:getLength2() end
end
__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype.changes = function(self) 
  do return self.myIterable:unchanged() end
end
__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype.unchanged = function(self) 
  do return self.myIterable:changes() end
end

__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype.__class__ =  __diff_comparison_iterables_InvertedDiffIterableWrapper
__diff_comparison_iterables_InvertedDiffIterableWrapper.__super__ = __diff_comparison_iterables_DiffIterable
setmetatable(__diff_comparison_iterables_InvertedDiffIterableWrapper.prototype,{__index=__diff_comparison_iterables_DiffIterable.prototype})

__diff_comparison_iterables_RangesDiffIterable.new = function(ranges,length1,length2) 
  local self = _hx_new(__diff_comparison_iterables_RangesDiffIterable.prototype)
  __diff_comparison_iterables_RangesDiffIterable.super(self,ranges,length1,length2)
  return self
end
__diff_comparison_iterables_RangesDiffIterable.super = function(self,ranges,length1,length2) 
  __diff_comparison_iterables_ChangeDiffIterableBase.super(self,length1,length2);
  self.myRanges = ranges;
end
__diff_comparison_iterables_RangesDiffIterable.__name__ = "diff.comparison.iterables.RangesDiffIterable"
__diff_comparison_iterables_RangesDiffIterable.prototype = _hx_e();
__diff_comparison_iterables_RangesDiffIterable.prototype.myRanges= nil;
__diff_comparison_iterables_RangesDiffIterable.prototype.createChangeIterable = function(self) 
  do return __diff_comparison_iterables_RangesChangeIterable.new(self.myRanges) end
end

__diff_comparison_iterables_RangesDiffIterable.prototype.__class__ =  __diff_comparison_iterables_RangesDiffIterable
__diff_comparison_iterables_RangesDiffIterable.__super__ = __diff_comparison_iterables_ChangeDiffIterableBase
setmetatable(__diff_comparison_iterables_RangesDiffIterable.prototype,{__index=__diff_comparison_iterables_ChangeDiffIterableBase.prototype})

__diff_comparison_iterables_RangesChangeIterable.new = function(ranges) 
  local self = _hx_new(__diff_comparison_iterables_RangesChangeIterable.prototype)
  __diff_comparison_iterables_RangesChangeIterable.super(self,ranges)
  return self
end
__diff_comparison_iterables_RangesChangeIterable.super = function(self,ranges) 
  self.myIterator = __haxe_iterators_ArrayIterator.new(ranges);
  self:next();
end
__diff_comparison_iterables_RangesChangeIterable.__name__ = "diff.comparison.iterables.RangesChangeIterable"
__diff_comparison_iterables_RangesChangeIterable.__interfaces__ = {__diff_comparison_iterables_ChangeIterable}
__diff_comparison_iterables_RangesChangeIterable.prototype = _hx_e();
__diff_comparison_iterables_RangesChangeIterable.prototype.myIterator= nil;
__diff_comparison_iterables_RangesChangeIterable.prototype.myLast= nil;
__diff_comparison_iterables_RangesChangeIterable.prototype.valid = function(self) 
  do return self.myLast ~= nil end
end
__diff_comparison_iterables_RangesChangeIterable.prototype.next = function(self) 
  self.myLast = (function() 
    local _hx_1
    if (self.myIterator:hasNext()) then 
    _hx_1 = self.myIterator:next(); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
end
__diff_comparison_iterables_RangesChangeIterable.prototype.getStart1 = function(self) 
  do return self.myLast.start1 end
end
__diff_comparison_iterables_RangesChangeIterable.prototype.getStart2 = function(self) 
  do return self.myLast.start2 end
end
__diff_comparison_iterables_RangesChangeIterable.prototype.getEnd1 = function(self) 
  do return self.myLast.end1 end
end
__diff_comparison_iterables_RangesChangeIterable.prototype.getEnd2 = function(self) 
  do return self.myLast.end2 end
end

__diff_comparison_iterables_RangesChangeIterable.prototype.__class__ =  __diff_comparison_iterables_RangesChangeIterable

__diff_comparison_iterables_SubiterableDiffIterable.new = function(changed,start1,end1,start2,end2,firstIndex) 
  local self = _hx_new(__diff_comparison_iterables_SubiterableDiffIterable.prototype)
  __diff_comparison_iterables_SubiterableDiffIterable.super(self,changed,start1,end1,start2,end2,firstIndex)
  return self
end
__diff_comparison_iterables_SubiterableDiffIterable.super = function(self,changed,start1,end1,start2,end2,firstIndex) 
  __diff_comparison_iterables_ChangeDiffIterableBase.super(self,end1 - start1,end2 - start2);
  self.myChanged = changed;
  self.myStart1 = start1;
  self.myStart2 = start2;
  self.myEnd1 = end1;
  self.myEnd2 = end2;
  self.myFirstIndex = firstIndex;
end
__diff_comparison_iterables_SubiterableDiffIterable.__name__ = "diff.comparison.iterables.SubiterableDiffIterable"
__diff_comparison_iterables_SubiterableDiffIterable.prototype = _hx_e();
__diff_comparison_iterables_SubiterableDiffIterable.prototype.myChanged= nil;
__diff_comparison_iterables_SubiterableDiffIterable.prototype.myStart1= nil;
__diff_comparison_iterables_SubiterableDiffIterable.prototype.myStart2= nil;
__diff_comparison_iterables_SubiterableDiffIterable.prototype.myEnd1= nil;
__diff_comparison_iterables_SubiterableDiffIterable.prototype.myEnd2= nil;
__diff_comparison_iterables_SubiterableDiffIterable.prototype.myFirstIndex= nil;
__diff_comparison_iterables_SubiterableDiffIterable.prototype.createChangeIterable = function(self) 
  do return __diff_comparison_iterables_SubiterableChangeIterable.new(self.myChanged, self.myStart1, self.myEnd1, self.myStart2, self.myEnd2, self.myFirstIndex) end
end

__diff_comparison_iterables_SubiterableDiffIterable.prototype.__class__ =  __diff_comparison_iterables_SubiterableDiffIterable
__diff_comparison_iterables_SubiterableDiffIterable.__super__ = __diff_comparison_iterables_ChangeDiffIterableBase
setmetatable(__diff_comparison_iterables_SubiterableDiffIterable.prototype,{__index=__diff_comparison_iterables_ChangeDiffIterableBase.prototype})

__diff_comparison_iterables_SubiterableChangeIterable.new = function(changed,start1,end1,start2,end2,firstIndex) 
  local self = _hx_new(__diff_comparison_iterables_SubiterableChangeIterable.prototype)
  __diff_comparison_iterables_SubiterableChangeIterable.super(self,changed,start1,end1,start2,end2,firstIndex)
  return self
end
__diff_comparison_iterables_SubiterableChangeIterable.super = function(self,changed,start1,end1,start2,end2,firstIndex) 
  self.myChanged = changed;
  self.myStart1 = start1;
  self.myEnd1 = end1;
  self.myStart2 = start2;
  self.myEnd2 = end2;
  self.myIndex = firstIndex;
  self:next();
end
__diff_comparison_iterables_SubiterableChangeIterable.__name__ = "diff.comparison.iterables.SubiterableChangeIterable"
__diff_comparison_iterables_SubiterableChangeIterable.__interfaces__ = {__diff_comparison_iterables_ChangeIterable}
__diff_comparison_iterables_SubiterableChangeIterable.prototype = _hx_e();
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myChanged= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myStart1= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myEnd1= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myStart2= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myEnd2= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myIndex= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.myLast= nil;
__diff_comparison_iterables_SubiterableChangeIterable.prototype.valid = function(self) 
  do return self.myLast ~= nil end
end
__diff_comparison_iterables_SubiterableChangeIterable.prototype.next = function(self) 
  self.myLast = nil;
  local _hx_continue_1 = false;
  while (self.myIndex < self.myChanged.length) do _hx_do_first_1 = false;
    repeat 
    local range = self.myChanged[self.myIndex];
    self.myIndex = self.myIndex + 1;
    if ((range.end1 < self.myStart1) or (range.end2 < self.myStart2)) then 
      break;
    end;
    if ((range.start1 > self.myEnd1) or (range.start2 > self.myEnd2)) then 
      _hx_continue_1 = true;break;
    end;
    local newRange = __diff_util_Range.new(Std.int(Math.max(self.myStart1, range.start1)) - self.myStart1, Std.int(Math.min(self.myEnd1, range.end1)) - self.myStart1, Std.int(Math.max(self.myStart2, range.start2)) - self.myStart2, Std.int(Math.min(self.myEnd2, range.end2)) - self.myStart2);
    if (newRange:isEmpty()) then 
      break;
    end;
    self.myLast = newRange;
    _hx_continue_1 = true;break;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__diff_comparison_iterables_SubiterableChangeIterable.prototype.getStart1 = function(self) 
  do return self.myLast.start1 end
end
__diff_comparison_iterables_SubiterableChangeIterable.prototype.getStart2 = function(self) 
  do return self.myLast.start2 end
end
__diff_comparison_iterables_SubiterableChangeIterable.prototype.getEnd1 = function(self) 
  do return self.myLast.end1 end
end
__diff_comparison_iterables_SubiterableChangeIterable.prototype.getEnd2 = function(self) 
  do return self.myLast.end2 end
end

__diff_comparison_iterables_SubiterableChangeIterable.prototype.__class__ =  __diff_comparison_iterables_SubiterableChangeIterable

__diff_fragments_DiffFragment.new = {}
__diff_fragments_DiffFragment.__name__ = "diff.fragments.DiffFragment"
__diff_fragments_DiffFragment.prototype = _hx_e();
__diff_fragments_DiffFragment.prototype.getStartOffset1= nil;
__diff_fragments_DiffFragment.prototype.getEndOffset1= nil;
__diff_fragments_DiffFragment.prototype.getStartOffset2= nil;
__diff_fragments_DiffFragment.prototype.getEndOffset2= nil;

__diff_fragments_DiffFragment.prototype.__class__ =  __diff_fragments_DiffFragment

__diff_fragments_DiffFragmentImpl.new = function(startOffset1,endOffset1,startOffset2,endOffset2) 
  local self = _hx_new(__diff_fragments_DiffFragmentImpl.prototype)
  __diff_fragments_DiffFragmentImpl.super(self,startOffset1,endOffset1,startOffset2,endOffset2)
  return self
end
__diff_fragments_DiffFragmentImpl.super = function(self,startOffset1,endOffset1,startOffset2,endOffset2) 
  self.myStartOffset1 = startOffset1;
  self.myEndOffset1 = endOffset1;
  self.myStartOffset2 = startOffset2;
  self.myEndOffset2 = endOffset2;
  if ((self.myStartOffset1 == self.myEndOffset1) and (self.myStartOffset2 == self.myEndOffset2)) then 
    __haxe_Log.trace(Std.string("DiffFragmentImpl should not be empty: ") .. Std.string(self:toString()), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/diff/fragments/DiffFragment.hx",lineNumber=30,className="diff.fragments.DiffFragmentImpl",methodName="new"}));
  end;
  if ((self.myStartOffset1 > self.myEndOffset1) or (self.myStartOffset2 > self.myEndOffset2)) then 
    __haxe_Log.trace(Std.string("DiffFragmentImpl is invalid: ") .. Std.string(self:toString()), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/diff/fragments/DiffFragment.hx",lineNumber=33,className="diff.fragments.DiffFragmentImpl",methodName="new"}));
  end;
end
__diff_fragments_DiffFragmentImpl.__name__ = "diff.fragments.DiffFragmentImpl"
__diff_fragments_DiffFragmentImpl.__interfaces__ = {__diff_fragments_DiffFragment}
__diff_fragments_DiffFragmentImpl.prototype = _hx_e();
__diff_fragments_DiffFragmentImpl.prototype.myStartOffset1= nil;
__diff_fragments_DiffFragmentImpl.prototype.myEndOffset1= nil;
__diff_fragments_DiffFragmentImpl.prototype.myStartOffset2= nil;
__diff_fragments_DiffFragmentImpl.prototype.myEndOffset2= nil;
__diff_fragments_DiffFragmentImpl.prototype.getStartOffset1 = function(self) 
  do return self.myStartOffset1 end
end
__diff_fragments_DiffFragmentImpl.prototype.getEndOffset1 = function(self) 
  do return self.myEndOffset1 end
end
__diff_fragments_DiffFragmentImpl.prototype.getStartOffset2 = function(self) 
  do return self.myStartOffset2 end
end
__diff_fragments_DiffFragmentImpl.prototype.getEndOffset2 = function(self) 
  do return self.myEndOffset2 end
end
__diff_fragments_DiffFragmentImpl.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("DiffFragmentImpl [") .. Std.string(self.myStartOffset1)) .. Std.string(", ")) .. Std.string(self.myEndOffset1)) .. Std.string(") - [")) .. Std.string(self.myStartOffset2)) .. Std.string(", ")) .. Std.string(self.myEndOffset2)) .. Std.string(")") end
end

__diff_fragments_DiffFragmentImpl.prototype.__class__ =  __diff_fragments_DiffFragmentImpl

__diff_fragments_LineFragment.new = {}
__diff_fragments_LineFragment.__name__ = "diff.fragments.LineFragment"
__diff_fragments_LineFragment.dropWholeChangedFragments = function(fragments,length1,length2) 
  if ((fragments ~= nil) and (fragments.length == 1)) then 
    local diffFragment = fragments[0];
    if ((((diffFragment:getStartOffset1() == 0) and (diffFragment:getStartOffset2() == 0)) and (diffFragment:getEndOffset1() == length1)) and (diffFragment:getEndOffset2() == length2)) then 
      do return nil end;
    end;
  end;
  do return fragments end;
end
__diff_fragments_LineFragment.prototype = _hx_e();
__diff_fragments_LineFragment.prototype.myStartLine1= nil;
__diff_fragments_LineFragment.prototype.myEndLine1= nil;
__diff_fragments_LineFragment.prototype.myStartLine2= nil;
__diff_fragments_LineFragment.prototype.myEndLine2= nil;
__diff_fragments_LineFragment.prototype.myStartOffset1= nil;
__diff_fragments_LineFragment.prototype.myEndOffset1= nil;
__diff_fragments_LineFragment.prototype.myStartOffset2= nil;
__diff_fragments_LineFragment.prototype.myEndOffset2= nil;
__diff_fragments_LineFragment.prototype.myInnerFragments= nil;
__diff_fragments_LineFragment.prototype.newFromExpanded = function(self,startLine1,endLine1,startLine2,endLine2,startOffset1,endOffset1,startOffset2,endOffset2) 
  self:newFromSomethingDifferent(startLine1, endLine1, startLine2, endLine2, startOffset1, endOffset1, startOffset2, endOffset2, nil);
end
__diff_fragments_LineFragment.prototype.newFromFragment = function(self,fragment,fragments) 
  self:newFromSomethingDifferent(fragment:getStartLine1(), fragment:getEndLine1(), fragment:getStartLine2(), fragment:getEndLine2(), fragment:getStartOffset1(), fragment:getEndOffset1(), fragment:getStartOffset2(), fragment:getEndOffset2(), fragments);
end
__diff_fragments_LineFragment.prototype.newFromSomethingDifferent = function(self,startLine1,endLine1,startLine2,endLine2,startOffset1,endOffset1,startOffset2,endOffset2,innerFragments) 
  self.myStartLine1 = startLine1;
  self.myEndLine1 = endLine1;
  self.myStartLine2 = startLine2;
  self.myEndLine2 = endLine2;
  self.myStartOffset1 = startOffset1;
  self.myEndOffset1 = endOffset1;
  self.myStartOffset2 = startOffset2;
  self.myEndOffset2 = endOffset2;
  self.myInnerFragments = __diff_fragments_LineFragment.dropWholeChangedFragments(innerFragments, endOffset1 - startOffset1, endOffset2 - startOffset2);
  if ((self.myStartLine1 == self.myEndLine1) and (self.myStartLine2 == self.myEndLine2)) then 
    __haxe_Log.trace(Std.string("LineFragmentImpl should not be empty: ") .. Std.string(self:toString()), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/diff/fragments/LineFragment.hx",lineNumber=41,className="diff.fragments.LineFragment",methodName="newFromSomethingDifferent"}));
  end;
  if ((((self.myStartLine1 > self.myEndLine1) or (self.myStartLine2 > self.myEndLine2)) or (self.myStartOffset1 > self.myEndOffset1)) or (self.myStartOffset2 > self.myEndOffset2)) then 
    __haxe_Log.trace(Std.string("LineFragmentImpl is invalid: ") .. Std.string(self:toString()), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/diff/fragments/LineFragment.hx",lineNumber=44,className="diff.fragments.LineFragment",methodName="newFromSomethingDifferent"}));
  end;
end
__diff_fragments_LineFragment.prototype.getStartLine1 = function(self) 
  do return self.myStartLine1 end
end
__diff_fragments_LineFragment.prototype.getEndLine1 = function(self) 
  do return self.myEndLine1 end
end
__diff_fragments_LineFragment.prototype.getStartLine2 = function(self) 
  do return self.myStartLine2 end
end
__diff_fragments_LineFragment.prototype.getEndLine2 = function(self) 
  do return self.myEndLine2 end
end
__diff_fragments_LineFragment.prototype.getStartOffset1 = function(self) 
  do return self.myStartOffset1 end
end
__diff_fragments_LineFragment.prototype.getEndOffset1 = function(self) 
  do return self.myEndOffset1 end
end
__diff_fragments_LineFragment.prototype.getStartOffset2 = function(self) 
  do return self.myStartOffset2 end
end
__diff_fragments_LineFragment.prototype.getEndOffset2 = function(self) 
  do return self.myEndOffset2 end
end
__diff_fragments_LineFragment.prototype.getInnerFragments = function(self) 
  do return self.myInnerFragments end
end
__diff_fragments_LineFragment.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("LineFragmentImpl: Lines [") .. Std.string(self.myStartLine1)) .. Std.string(", ")) .. Std.string(self.myEndLine1)) .. Std.string(") - [")) .. Std.string(self.myStartLine2)) .. Std.string(", ")) .. Std.string(self.myEndLine2)) .. Std.string("); ")) .. Std.string("Offsets [")) .. Std.string(self.myStartOffset1)) .. Std.string(", ")) .. Std.string(self.myEndOffset1)) .. Std.string(") - [")) .. Std.string(self.myStartOffset2)) .. Std.string(", ")) .. Std.string(self.myEndOffset2)) .. Std.string("); ")) .. Std.string("Inner ")) .. Std.string(((function() 
    local _hx_1
    if (self.myInnerFragments ~= nil) then 
    _hx_1 = self.myInnerFragments.length; else 
    _hx_1 = nil; end
    return _hx_1
  end )())) end
end

__diff_fragments_LineFragment.prototype.__class__ =  __diff_fragments_LineFragment

__diff_fragments_MergeLineFragment.new = function(range) 
  local self = _hx_new(__diff_fragments_MergeLineFragment.prototype)
  __diff_fragments_MergeLineFragment.super(self,range)
  return self
end
__diff_fragments_MergeLineFragment.super = function(self,range) 
  self.myStartLine1 = range.start1;
  self.myEndLine1 = range.end1;
  self.myStartLine2 = range.start2;
  self.myEndLine2 = range.end2;
  self.myStartLine3 = range.start3;
  self.myEndLine3 = range.end3;
end
__diff_fragments_MergeLineFragment.__name__ = "diff.fragments.MergeLineFragment"
__diff_fragments_MergeLineFragment.prototype = _hx_e();
__diff_fragments_MergeLineFragment.prototype.myStartLine1= nil;
__diff_fragments_MergeLineFragment.prototype.myEndLine1= nil;
__diff_fragments_MergeLineFragment.prototype.myStartLine2= nil;
__diff_fragments_MergeLineFragment.prototype.myEndLine2= nil;
__diff_fragments_MergeLineFragment.prototype.myStartLine3= nil;
__diff_fragments_MergeLineFragment.prototype.myEndLine3= nil;
__diff_fragments_MergeLineFragment.prototype.hopefullyUnused = function(self,startLine1,endLine1,startLine2,endLine2,startLine3,endLine3) 
  self.myStartLine1 = startLine1;
  self.myEndLine1 = endLine1;
  self.myStartLine2 = startLine2;
  self.myEndLine2 = endLine2;
  self.myStartLine3 = startLine3;
  self.myEndLine3 = endLine3;
end
__diff_fragments_MergeLineFragment.prototype.alsoHopefullyUnused = function(self,fragment) 
  self.myStartLine1 = fragment:getStartLine(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT));
  self.myEndLine1 = fragment:getEndLine(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT));
  self.myStartLine2 = fragment:getStartLine(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE));
  self.myEndLine2 = fragment:getEndLine(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE));
  self.myStartLine3 = fragment:getStartLine(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
  self.myEndLine3 = fragment:getEndLine(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
end
__diff_fragments_MergeLineFragment.prototype.getStartLine = function(self,side) 
  do return side:selectA_Int(self.myStartLine1, self.myStartLine2, self.myStartLine3) end
end
__diff_fragments_MergeLineFragment.prototype.getEndLine = function(self,side) 
  do return side:selectA_Int(self.myEndLine1, self.myEndLine2, self.myEndLine3) end
end

__diff_fragments_MergeLineFragment.prototype.__class__ =  __diff_fragments_MergeLineFragment

__diff_fragments_MergeWordFragment.new = function(startOffset1,endOffset1,startOffset2,endOffset2,startOffset3,endOffset3) 
  local self = _hx_new(__diff_fragments_MergeWordFragment.prototype)
  __diff_fragments_MergeWordFragment.super(self,startOffset1,endOffset1,startOffset2,endOffset2,startOffset3,endOffset3)
  return self
end
__diff_fragments_MergeWordFragment.super = function(self,startOffset1,endOffset1,startOffset2,endOffset2,startOffset3,endOffset3) 
  self.myStartOffset1 = startOffset1;
  self.myEndOffset1 = endOffset1;
  self.myStartOffset2 = startOffset2;
  self.myEndOffset2 = endOffset2;
  self.myStartOffset3 = startOffset3;
  self.myEndOffset3 = endOffset3;
end
__diff_fragments_MergeWordFragment.__name__ = "diff.fragments.MergeWordFragment"
__diff_fragments_MergeWordFragment.newFromRange = function(range) 
  do return __diff_fragments_MergeWordFragment.new(range.start1, range.end1, range.start2, range.end2, range.start3, range.end3) end;
end
__diff_fragments_MergeWordFragment.prototype = _hx_e();
__diff_fragments_MergeWordFragment.prototype.myStartOffset1= nil;
__diff_fragments_MergeWordFragment.prototype.myEndOffset1= nil;
__diff_fragments_MergeWordFragment.prototype.myStartOffset2= nil;
__diff_fragments_MergeWordFragment.prototype.myEndOffset2= nil;
__diff_fragments_MergeWordFragment.prototype.myStartOffset3= nil;
__diff_fragments_MergeWordFragment.prototype.myEndOffset3= nil;
__diff_fragments_MergeWordFragment.prototype.getStartOffset = function(self,side) 
  do return side:selectA_Int(self.myStartOffset1, self.myStartOffset2, self.myStartOffset3) end
end
__diff_fragments_MergeWordFragment.prototype.getEndOffset = function(self,side) 
  do return side:selectA_Int(self.myEndOffset1, self.myEndOffset2, self.myEndOffset3) end
end

__diff_fragments_MergeWordFragment.prototype.__class__ =  __diff_fragments_MergeWordFragment

__diff_tools_util_text_LineOffsets.new = {}
__diff_tools_util_text_LineOffsets.__name__ = "diff.tools.util.text.LineOffsets"
__diff_tools_util_text_LineOffsets.prototype = _hx_e();
__diff_tools_util_text_LineOffsets.prototype.getLineStart= nil;
__diff_tools_util_text_LineOffsets.prototype.getLineEndA= nil;
__diff_tools_util_text_LineOffsets.prototype.getLineEndB= nil;
__diff_tools_util_text_LineOffsets.prototype.getLineNumber= nil;
__diff_tools_util_text_LineOffsets.prototype.getLineCount= nil;
__diff_tools_util_text_LineOffsets.prototype.getTextLength= nil;

__diff_tools_util_text_LineOffsets.prototype.__class__ =  __diff_tools_util_text_LineOffsets

__diff_util_DiffRangeUtil.new = {}
__diff_util_DiffRangeUtil.__name__ = "diff.util.DiffRangeUtil"
__diff_util_DiffRangeUtil.getLinesContent = function(sequence,lineOffsets,line1,line2,includeNewline) 
  if (includeNewline == nil) then 
    includeNewline = false;
  end;
  do return __diff_util_DiffRangeUtil.getLinesRange(lineOffsets, line1, line2, includeNewline):subSequence(sequence) end;
end
__diff_util_DiffRangeUtil.getLinesRange = function(lineOffsets,line1,line2,includeNewline) 
  if (line1 == line2) then 
    local lineStartOffset = (function() 
      local _hx_1
      if (line1 < lineOffsets:getLineCount()) then 
      _hx_1 = lineOffsets:getLineStart(line1); else 
      _hx_1 = lineOffsets:getTextLength(); end
      return _hx_1
    end )();
    do return __ds_TextRange.new(lineStartOffset, lineStartOffset) end;
  else
    local startOffset = lineOffsets:getLineStart(line1);
    local endOffset = lineOffsets:getLineEndA(line2 - 1);
    if (includeNewline and (endOffset < lineOffsets:getTextLength())) then 
      endOffset = endOffset + 1;
    end;
    do return __ds_TextRange.new(startOffset, endOffset) end;
  end;
end
__diff_util_DiffRangeUtil.getLines = function(text,lineOffsets,sl,el) 
  local startLine = (function() 
    local _hx_1
    if (sl == nil) then 
    _hx_1 = 0; else 
    _hx_1 = sl; end
    return _hx_1
  end )();
  local endLine = (function() 
    local _hx_2
    if (el == nil) then 
    _hx_2 = 0; else 
    _hx_2 = el; end
    return _hx_2
  end )();
  if (((startLine < 0) or (startLine > endLine)) or (endLine > lineOffsets:getLineCount())) then 
    _G.error(__exceptions_IndexOutOfBoundsException.new(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Wrong line range: [") .. Std.string(startLine)) .. Std.string(", ")) .. Std.string(endLine)) .. Std.string("; lineCount: \"")) .. Std.string(Std.string(lineOffsets))) .. Std.string(".getLineCount()\"")),0);
  end;
  local result = Array.new();
  local _g = startLine;
  local _g1 = endLine;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local start = lineOffsets:getLineStart(i);
    local _end = lineOffsets:getLineEndA(i);
    result:push(String.prototype.substring(text, start, _end));
  end;
  do return result end;
end
_hxClasses["diff.util.MergeConflictTypeEnum"] = { __ename__ = "diff.util.MergeConflictTypeEnum", __constructs__ = _hx_tab_array({[0]="INSERTED","DELETED","MODIFIED","CONFLICT"},4)}
__diff_util_MergeConflictTypeEnum = _hxClasses["diff.util.MergeConflictTypeEnum"];
__diff_util_MergeConflictTypeEnum.INSERTED = _hx_tab_array({[0]="INSERTED",0,__enum__ = __diff_util_MergeConflictTypeEnum},2)

__diff_util_MergeConflictTypeEnum.DELETED = _hx_tab_array({[0]="DELETED",1,__enum__ = __diff_util_MergeConflictTypeEnum},2)

__diff_util_MergeConflictTypeEnum.MODIFIED = _hx_tab_array({[0]="MODIFIED",2,__enum__ = __diff_util_MergeConflictTypeEnum},2)

__diff_util_MergeConflictTypeEnum.CONFLICT = _hx_tab_array({[0]="CONFLICT",3,__enum__ = __diff_util_MergeConflictTypeEnum},2)


__diff_util_MergeConflictType.new = function(type,leftChange,rightChange,canBeResolved) 
  local self = _hx_new(__diff_util_MergeConflictType.prototype)
  __diff_util_MergeConflictType.super(self,type,leftChange,rightChange,canBeResolved)
  return self
end
__diff_util_MergeConflictType.super = function(self,type,leftChange,rightChange,canBeResolved) 
  if (canBeResolved == nil) then 
    canBeResolved = true;
  end;
  self.myType = type;
  self.myLeftChange = leftChange;
  self.myRightChange = rightChange;
  self.myCanBeResolved = canBeResolved;
end
__diff_util_MergeConflictType.__name__ = "diff.util.MergeConflictType"
__diff_util_MergeConflictType.prototype = _hx_e();
__diff_util_MergeConflictType.prototype.myType= nil;
__diff_util_MergeConflictType.prototype.myLeftChange= nil;
__diff_util_MergeConflictType.prototype.myRightChange= nil;
__diff_util_MergeConflictType.prototype.myCanBeResolved= nil;
__diff_util_MergeConflictType.prototype.getType = function(self) 
  do return self.myType end
end
__diff_util_MergeConflictType.prototype.canBeResolved = function(self) 
  do return self.myCanBeResolved end
end
__diff_util_MergeConflictType.prototype.isChangeA = function(self,side) 
  if (side:isLeft()) then 
    do return self.myLeftChange end;
  else
    do return self.myRightChange end;
  end;
end
__diff_util_MergeConflictType.prototype.isChangeB = function(self,side) 
  local isChange;
  local tmp = side[1];
  if (tmp) == 0 then 
    isChange = self.myLeftChange;
  elseif (tmp) == 1 then 
    isChange = true;
  elseif (tmp) == 2 then 
    isChange = self.myRightChange; end;
  do return isChange end
end

__diff_util_MergeConflictType.prototype.__class__ =  __diff_util_MergeConflictType

__diff_util_MergeRange.new = function(start1,end1,start2,end2,start3,end3) 
  local self = _hx_new(__diff_util_MergeRange.prototype)
  __diff_util_MergeRange.super(self,start1,end1,start2,end2,start3,end3)
  return self
end
__diff_util_MergeRange.super = function(self,start1,end1,start2,end2,start3,end3) 
  self.start1 = start1;
  self.end1 = end1;
  self.start2 = start2;
  self.end2 = end2;
  self.start3 = start3;
  self.end3 = end3;
end
__diff_util_MergeRange.__name__ = "diff.util.MergeRange"
__diff_util_MergeRange.prototype = _hx_e();
__diff_util_MergeRange.prototype.start1= nil;
__diff_util_MergeRange.prototype.end1= nil;
__diff_util_MergeRange.prototype.start2= nil;
__diff_util_MergeRange.prototype.end2= nil;
__diff_util_MergeRange.prototype.start3= nil;
__diff_util_MergeRange.prototype.end3= nil;
__diff_util_MergeRange.prototype.equals = function(self,range) 
  if (self == range) then 
    do return true end;
  end;
  local tmp;
  if (range ~= nil) then 
    local c = Type.getClass(range);
    local tmp1 = c.__name__;
    local c = Type.getClass(self);
    tmp = tmp1 ~= c.__name__;
  else
    tmp = true;
  end;
  if (tmp) then 
    do return false end;
  end;
  if (self.start1 ~= range.start1) then 
    do return false end;
  end;
  if (self.end1 ~= range.end1) then 
    do return false end;
  end;
  if (self.start2 ~= range.start2) then 
    do return false end;
  end;
  if (self.end2 ~= range.end2) then 
    do return false end;
  end;
  if (self.start3 ~= range.start3) then 
    do return false end;
  end;
  if (self.end3 ~= range.end3) then 
    do return false end;
  end;
  do return true end
end
__diff_util_MergeRange.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("[") .. Std.string(self.start1)) .. Std.string(", ")) .. Std.string(self.end1)) .. Std.string(") - [")) .. Std.string(self.start2)) .. Std.string(", ")) .. Std.string(self.end2)) .. Std.string(") - [")) .. Std.string(self.start3)) .. Std.string(", ")) .. Std.string(self.end3)) .. Std.string(")") end
end
__diff_util_MergeRange.prototype.isEmpty = function(self) 
  if ((self.start1 == self.end1) and (self.start2 == self.end2)) then 
    do return self.start3 == self.end3 end;
  else
    do return false end;
  end;
end

__diff_util_MergeRange.prototype.__class__ =  __diff_util_MergeRange

__diff_util_MergeRangeUtil.new = {}
__diff_util_MergeRangeUtil.__name__ = "diff.util.MergeRangeUtil"
__diff_util_MergeRangeUtil.getMergeType = function(emptiness,equality,trueEquality,conflictResolver) 
  local isLeftEmpty = emptiness:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT));
  local isBaseEmpty = emptiness:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE));
  local isRightEmpty = emptiness:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
  if (isBaseEmpty) then 
    if (isLeftEmpty) then 
      do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.INSERTED, false, true) end;
    else
      if (isRightEmpty) then 
        do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.INSERTED, true, false) end;
      else
        local equalModifications = equality:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
        if (equalModifications) then 
          do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.INSERTED, true, true) end;
        else
          do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.CONFLICT, true, true, false) end;
        end;
      end;
    end;
  else
    if (isLeftEmpty and isRightEmpty) then 
      do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.DELETED, true, true) end;
    else
      local unchangedLeft = equality:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT));
      local unchangedRight = equality:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
      if (unchangedLeft and unchangedRight) then 
        local trueUnchangedLeft = trueEquality:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT));
        local trueUnchangedRight = trueEquality:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.BASE), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
        do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.MODIFIED, not trueUnchangedLeft, not trueUnchangedRight) end;
      end;
      if (unchangedLeft) then 
        do return __diff_util_MergeConflictType.new((function() 
          local _hx_1
          if (isRightEmpty) then 
          _hx_1 = __diff_util_MergeConflictTypeEnum.DELETED; else 
          _hx_1 = __diff_util_MergeConflictTypeEnum.MODIFIED; end
          return _hx_1
        end )(), false, true) end;
      end;
      if (unchangedRight) then 
        do return __diff_util_MergeConflictType.new((function() 
          local _hx_2
          if (isLeftEmpty) then 
          _hx_2 = __diff_util_MergeConflictTypeEnum.DELETED; else 
          _hx_2 = __diff_util_MergeConflictTypeEnum.MODIFIED; end
          return _hx_2
        end )(), true, false) end;
      end;
      local equalModifications = equality:test(__diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.LEFT), __diff_util_ThreeSide.fromEnum(__diff_util_ThreeSideEnum.RIGHT));
      if (equalModifications) then 
        do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.MODIFIED, true, true) end;
      else
        local canBeResolved = (not isLeftEmpty and not isRightEmpty) and conflictResolver:getAsBoolean();
        do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.CONFLICT, true, true, canBeResolved) end;
      end;
    end;
  end;
end
__diff_util_MergeRangeUtil.getLineThreeWayDiffType = function(fragment,sequences,lineOffsets,policy) 
  do return __diff_util_MergeRangeUtil.getMergeType(__ds_Predicate_diff_util_ThreeSide.new(function(side) 
    do return __diff_util_MergeRangeUtil.isLineMergeIntervalEmpty(fragment, side) end;
  end), __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(side1,side2) 
    do return __diff_util_MergeRangeUtil.compareLineMergeContents(fragment, sequences, lineOffsets, policy, side1, side2) end;
  end), nil, __ds_BooleanSupplier.new(function() 
    do return __diff_util_MergeRangeUtil.canResolveLineConflict(fragment, sequences, lineOffsets) end;
  end)) end;
end
__diff_util_MergeRangeUtil.getLineMergeType = function(fragment,sequences,lineOffsets,policy) 
  do return __diff_util_MergeRangeUtil.getMergeType(__ds_Predicate_diff_util_ThreeSide.new(function(side) 
    do return __diff_util_MergeRangeUtil.isLineMergeIntervalEmpty(fragment, side) end;
  end), __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(side1,side2) 
    do return __diff_util_MergeRangeUtil.compareLineMergeContents(fragment, sequences, lineOffsets, policy, side1, side2) end;
  end), __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(side1,side2) 
    do return __diff_util_MergeRangeUtil.compareLineMergeContents(fragment, sequences, lineOffsets, __diff_comparison_ComparisonPolicy.DEFAULT, side1, side2) end;
  end), __ds_BooleanSupplier.new(function() 
    do return __diff_util_MergeRangeUtil.canResolveLineConflict(fragment, sequences, lineOffsets) end;
  end)) end;
end
__diff_util_MergeRangeUtil.canResolveLineConflict = function(fragment,sequences,lineOffsets) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = _hx_tab_array({[0]=__diff_util_ThreeSideEnum.LEFT, __diff_util_ThreeSideEnum.BASE, __diff_util_ThreeSideEnum.RIGHT}, 3);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__diff_util_DiffRangeUtil.getLinesContent(__diff_util_ThreeSide.fromEnum(i):selectC_String(sequences), __diff_util_ThreeSide.fromEnum(i):selectC_diff_tools_util_text_LineOffsets(lineOffsets), fragment:getStartLine(__diff_util_ThreeSide.fromEnum(i)), fragment:getEndLine(__diff_util_ThreeSide.fromEnum(i))));
  end;
  local contents = _g;
  do return __diff_comparison_ComparisonMergeUtil.tryResolveConflict(contents[0], contents[1], contents[2]) ~= nil end;
end
__diff_util_MergeRangeUtil.compareLineMergeContents = function(fragment,sequences,lineOffsets,policy,side1,side2) 
  local start1 = fragment:getStartLine(side1);
  local end1 = fragment:getEndLine(side1);
  local start2 = fragment:getStartLine(side2);
  local end2 = fragment:getEndLine(side2);
  if ((end2 - start2) ~= (end1 - start1)) then 
    do return false end;
  end;
  local sequence1 = side1:selectC_String(sequences);
  local sequence2 = side2:selectC_String(sequences);
  local offsets1 = side1:selectC_diff_tools_util_text_LineOffsets(lineOffsets);
  local offsets2 = side2:selectC_diff_tools_util_text_LineOffsets(lineOffsets);
  local _g = 0;
  local _g1 = end1 - start1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local line1 = start1 + i;
    local line2 = start2 + i;
    local content1 = __diff_util_DiffRangeUtil.getLinesContent(sequence1, offsets1, line1, line1 + 1);
    local content2 = __diff_util_DiffRangeUtil.getLinesContent(sequence2, offsets2, line2, line2 + 1);
    if (not __diff_comparison_ComparisonUtil.isEqualTexts(content1, content2, policy)) then 
      do return false end;
    end;
  end;
  do return true end;
end
__diff_util_MergeRangeUtil.isLineMergeIntervalEmpty = function(fragment,side) 
  do return fragment:getStartLine(side) == fragment:getEndLine(side) end;
end
__diff_util_MergeRangeUtil.getWordMergeType = function(fragment,texts,policy) 
  do return __diff_util_MergeRangeUtil.getMergeType(__ds_Predicate_diff_util_ThreeSide.new(function(side) 
    do return __diff_util_MergeRangeUtil.isWordMergeIntervalEmpty(fragment, side) end;
  end), __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(side1,side2) 
    do return __diff_util_MergeRangeUtil.compareWordMergeContents(fragment, texts, policy, side1, side2) end;
  end), nil, __ds_BooleanSupplier.new(function() 
    do return false end;
  end)) end;
end
__diff_util_MergeRangeUtil.compareWordMergeContents = function(fragment,texts,policy,side1,side2) 
  local start1 = fragment:getStartOffset(side1);
  local end1 = fragment:getEndOffset(side1);
  local start2 = fragment:getStartOffset(side2);
  local end2 = fragment:getEndOffset(side2);
  local document1 = side1:selectC_String(texts);
  local document2 = side2:selectC_String(texts);
  local content1 = String.prototype.substring(document1, start1, end1);
  local content2 = String.prototype.substring(document2, start2, end2);
  do return __diff_comparison_ComparisonUtil.isEqualTexts(content1, content2, policy) end;
end
__diff_util_MergeRangeUtil.isWordMergeIntervalEmpty = function(fragment,side) 
  do return fragment:getStartOffset(side) == fragment:getEndOffset(side) end;
end
__diff_util_MergeRangeUtil.getLineLeftToRightThreeSideDiffType = function(fragment,sequences,lineOffsets,policy) 
  do return __diff_util_MergeRangeUtil.getLeftToRightDiffType(__ds_Predicate_diff_util_ThreeSideEnum.new(function(side) 
    do return __diff_util_MergeRangeUtil.isLineMergeIntervalEmpty(fragment, __diff_util_ThreeSide.fromEnum(side)) end;
  end), __ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.new(function(side1,side2) 
    do return __diff_util_MergeRangeUtil.compareLineMergeContents(fragment, sequences, lineOffsets, policy, __diff_util_ThreeSide.fromEnum(side1), __diff_util_ThreeSide.fromEnum(side2)) end;
  end)) end;
end
__diff_util_MergeRangeUtil.getLeftToRightDiffType = function(emptiness,equality) 
  local isLeftEmpty = emptiness:test(__diff_util_ThreeSideEnum.LEFT);
  local isBaseEmpty = emptiness:test(__diff_util_ThreeSideEnum.BASE);
  local isRightEmpty = emptiness:test(__diff_util_ThreeSideEnum.RIGHT);
  if (isBaseEmpty) then 
    if (isLeftEmpty) then 
      do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.INSERTED, false, true) end;
    else
      if (isRightEmpty) then 
        do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.DELETED, true, false) end;
      else
        do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.MODIFIED, true, true) end;
      end;
    end;
  else
    if (isLeftEmpty and isRightEmpty) then 
      do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.MODIFIED, true, true) end;
    else
      local unchangedLeft = equality:test(__diff_util_ThreeSideEnum.BASE, __diff_util_ThreeSideEnum.LEFT);
      local unchangedRight = equality:test(__diff_util_ThreeSideEnum.BASE, __diff_util_ThreeSideEnum.RIGHT);
      if (unchangedLeft) then 
        do return __diff_util_MergeConflictType.new((function() 
          local _hx_1
          if (isRightEmpty) then 
          _hx_1 = __diff_util_MergeConflictTypeEnum.DELETED; else 
          _hx_1 = __diff_util_MergeConflictTypeEnum.MODIFIED; end
          return _hx_1
        end )(), false, true) end;
      end;
      if (unchangedRight) then 
        do return __diff_util_MergeConflictType.new((function() 
          local _hx_2
          if (isLeftEmpty) then 
          _hx_2 = __diff_util_MergeConflictTypeEnum.INSERTED; else 
          _hx_2 = __diff_util_MergeConflictTypeEnum.MODIFIED; end
          return _hx_2
        end )(), true, false) end;
      end;
      do return __diff_util_MergeConflictType.new(__diff_util_MergeConflictTypeEnum.MODIFIED, true, true) end;
    end;
  end;
end

__diff_util_Range.new = function(start1,end1,start2,end2) 
  local self = _hx_new(__diff_util_Range.prototype)
  __diff_util_Range.super(self,start1,end1,start2,end2)
  return self
end
__diff_util_Range.super = function(self,start1,end1,start2,end2) 
  self.start1 = start1;
  self.end1 = end1;
  self.start2 = start2;
  self.end2 = end2;
end
__diff_util_Range.__name__ = "diff.util.Range"
__diff_util_Range.prototype = _hx_e();
__diff_util_Range.prototype.start1= nil;
__diff_util_Range.prototype.end1= nil;
__diff_util_Range.prototype.start2= nil;
__diff_util_Range.prototype.end2= nil;
__diff_util_Range.prototype.equals = function(self,range) 
  if (self == range) then 
    do return true end;
  end;
  local tmp;
  if (range ~= nil) then 
    local c = Type.getClass(range);
    local tmp1 = c.__name__;
    local c = Type.getClass(self);
    tmp = tmp1 ~= c.__name__;
  else
    tmp = true;
  end;
  if (tmp) then 
    do return false end;
  end;
  if (self.start1 ~= range.start1) then 
    do return false end;
  end;
  if (self.end1 ~= range.end1) then 
    do return false end;
  end;
  if (self.start2 ~= range.start2) then 
    do return false end;
  end;
  if (self.end2 ~= range.end2) then 
    do return false end;
  end;
  do return true end
end
__diff_util_Range.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("[") .. Std.string(self.start1)) .. Std.string(", ")) .. Std.string(self.end1)) .. Std.string(") - [")) .. Std.string(self.start2)) .. Std.string(", ")) .. Std.string(self.end2)) .. Std.string(")") end
end
__diff_util_Range.prototype.isEmpty = function(self) 
  if (self.start1 == self.end1) then 
    do return self.start2 == self.end2 end;
  else
    do return false end;
  end;
end

__diff_util_Range.prototype.__class__ =  __diff_util_Range
_hxClasses["diff.util.SideEnum"] = { __ename__ = "diff.util.SideEnum", __constructs__ = _hx_tab_array({[0]="LEFT","RIGHT"},2)}
__diff_util_SideEnum = _hxClasses["diff.util.SideEnum"];
__diff_util_SideEnum.LEFT = _hx_tab_array({[0]="LEFT",0,__enum__ = __diff_util_SideEnum},2)

__diff_util_SideEnum.RIGHT = _hx_tab_array({[0]="RIGHT",1,__enum__ = __diff_util_SideEnum},2)


__diff_util_Side.new = function(index) 
  local self = _hx_new(__diff_util_Side.prototype)
  __diff_util_Side.super(self,index)
  return self
end
__diff_util_Side.super = function(self,index) 
  self.myIndex = index;
end
__diff_util_Side.__name__ = "diff.util.Side"
__diff_util_Side.fromEnum = function(from) 
  local tmp = from[1];
  if (tmp) == 0 then 
    do return __diff_util_Side.new(0) end;
  elseif (tmp) == 1 then 
    do return __diff_util_Side.new(1) end; end;
end
__diff_util_Side.fromIndex = function(index) 
  if (index == 0) then 
    do return __diff_util_Side.new(index) end;
  end;
  if (index == 1) then 
    do return __diff_util_Side.new(index) end;
  end;
  _G.error(__exceptions_IndexOutOfBoundsException.new(Std.string("index: ") .. Std.string(index)),0);
end
__diff_util_Side.fromLeft = function(isLeft) 
  if (isLeft) then 
    do return __diff_util_SideEnum.LEFT end;
  else
    do return __diff_util_SideEnum.RIGHT end;
  end;
end
__diff_util_Side.fromRight = function(isRight) 
  if (isRight) then 
    do return __diff_util_SideEnum.RIGHT end;
  else
    do return __diff_util_SideEnum.LEFT end;
  end;
end
__diff_util_Side.prototype = _hx_e();
__diff_util_Side.prototype.selectA_Array_diff_comparison_Line = function(self,left,right) 
  if (self:isLeft()) then 
    do return left end;
  else
    do return right end;
  end;
end
__diff_util_Side.prototype.selectA_Int = function(self,left,right) 
  if (self:isLeft()) then 
    do return left end;
  else
    do return right end;
  end;
end
__diff_util_Side.prototype.selectA_Array_diff_comparison_InlineChunk_Dynamic = function(self,left,right) 
  if (self:isLeft()) then 
    do return left end;
  else
    do return right end;
  end;
end
__diff_util_Side.prototype.selectA_String = function(self,left,right) 
  if (self:isLeft()) then 
    do return left end;
  else
    do return right end;
  end;
end
__diff_util_Side.prototype.selectA_iterators_PeekableIteratorWrapper_diff_util_Range = function(self,left,right) 
  if (self:isLeft()) then 
    do return left end;
  else
    do return right end;
  end;
end
__diff_util_Side.prototype.myIndex= nil;
__diff_util_Side.prototype.getIndex = function(self) 
  do return self.myIndex end
end
__diff_util_Side.prototype.isLeft = function(self) 
  do return self.myIndex == 0 end
end
__diff_util_Side.prototype.other = function(self,other) 
  local cond = (function() 
    local _hx_1
    if (other == nil) then 
    _hx_1 = self:isLeft(); else 
    _hx_1 = other; end
    return _hx_1
  end )();
  if (cond) then 
    do return __diff_util_SideEnum.RIGHT end;
  else
    do return __diff_util_SideEnum.LEFT end;
  end;
end
__diff_util_Side.prototype.getStartOffset = function(self,fragment) 
  if (self:isLeft()) then 
    do return fragment:getStartOffset1() end;
  else
    do return fragment:getStartOffset2() end;
  end;
end
__diff_util_Side.prototype.getEndOffset = function(self,fragment) 
  if (self:isLeft()) then 
    do return fragment:getEndOffset1() end;
  else
    do return fragment:getEndOffset2() end;
  end;
end
__diff_util_Side.prototype.getStartLine = function(self,fragment) 
  if (self:isLeft()) then 
    do return fragment:getStartLine1() end;
  else
    do return fragment:getStartLine2() end;
  end;
end
__diff_util_Side.prototype.getEndLine = function(self,fragment) 
  if (self:isLeft()) then 
    do return fragment:getEndLine1() end;
  else
    do return fragment:getEndLine2() end;
  end;
end

__diff_util_Side.prototype.__class__ =  __diff_util_Side
_hxClasses["diff.util.ThreeSideEnum"] = { __ename__ = "diff.util.ThreeSideEnum", __constructs__ = _hx_tab_array({[0]="LEFT","BASE","RIGHT"},3)}
__diff_util_ThreeSideEnum = _hxClasses["diff.util.ThreeSideEnum"];
__diff_util_ThreeSideEnum.LEFT = _hx_tab_array({[0]="LEFT",0,__enum__ = __diff_util_ThreeSideEnum},2)

__diff_util_ThreeSideEnum.BASE = _hx_tab_array({[0]="BASE",1,__enum__ = __diff_util_ThreeSideEnum},2)

__diff_util_ThreeSideEnum.RIGHT = _hx_tab_array({[0]="RIGHT",2,__enum__ = __diff_util_ThreeSideEnum},2)


__diff_util_ThreeSide.new = function(index) 
  local self = _hx_new(__diff_util_ThreeSide.prototype)
  __diff_util_ThreeSide.super(self,index)
  return self
end
__diff_util_ThreeSide.super = function(self,index) 
  self.myIndex = index;
end
__diff_util_ThreeSide.__name__ = "diff.util.ThreeSide"
__diff_util_ThreeSide.fromEnum = function(from) 
  local index;
  local tmp = from[1];
  if (tmp) == 0 then 
    index = 0;
  elseif (tmp) == 1 then 
    index = 1;
  elseif (tmp) == 2 then 
    index = 2; end;
  do return __diff_util_ThreeSide.new(index) end;
end
__diff_util_ThreeSide.fromIndex = function(index) 
  if (index == 0) then 
    do return __diff_util_ThreeSideEnum.LEFT end;
  end;
  if (index == 1) then 
    do return __diff_util_ThreeSideEnum.BASE end;
  end;
  if (index == 2) then 
    do return __diff_util_ThreeSideEnum.RIGHT end;
  end;
  _G.error(__exceptions_IndexOutOfBoundsException.new(Std.string("index: ") .. Std.string(index)),0);
end
__diff_util_ThreeSide.prototype = _hx_e();
__diff_util_ThreeSide.prototype.selectC_diff_tools_util_text_LineOffsets = function(self,array) 
  do return array[self.myIndex] end
end
__diff_util_ThreeSide.prototype.selectC_String = function(self,array) 
  do return array[self.myIndex] end
end
__diff_util_ThreeSide.prototype.selectA_Int = function(self,left,base,right) 
  if (self.myIndex == 0) then 
    do return left end;
  end;
  if (self.myIndex == 1) then 
    do return base end;
  end;
  if (self.myIndex == 2) then 
    do return right end;
  end;
  _G.error(__exceptions_IllegalStateException.new(""),0);
end
__diff_util_ThreeSide.prototype.myIndex= nil;
__diff_util_ThreeSide.prototype.getIndex = function(self) 
  do return self.myIndex end
end
__diff_util_ThreeSide.prototype.selectB = function(self,left,base,right) 
  if (self.myIndex == 0) then 
    do return left end;
  end;
  if (self.myIndex == 1) then 
    do return base end;
  end;
  if (self.myIndex == 2) then 
    do return right end;
  end;
  _G.error(__exceptions_IllegalStateException.new(""),0);
end

__diff_util_ThreeSide.prototype.__class__ =  __diff_util_ThreeSide

__ds_BiPredicate.new = function(func) 
  local self = _hx_new(__ds_BiPredicate.prototype)
  __ds_BiPredicate.super(self,func)
  return self
end
__ds_BiPredicate.super = function(self,func) 
  self.func = func;
end
__ds_BiPredicate.__name__ = "ds.BiPredicate"
__ds_BiPredicate.prototype = _hx_e();
__ds_BiPredicate.prototype.func= nil;
__ds_BiPredicate.prototype.test = function(self,t,u) 
  do return self.func(t, u) end
end
__ds_BiPredicate.prototype["and"] = function(self,other) 
  local _gthis = self;
  do return __ds_BiPredicate.new(function(t,u) 
    if (_gthis:test(t, u)) then 
      do return other:test(t, u) end;
    else
      do return false end;
    end;
  end) end
end
__ds_BiPredicate.prototype.negate = function(self) 
  local _gthis = self;
  do return __ds_BiPredicate.new(function(t,u) 
    do return not _gthis:test(t, u) end;
  end) end
end
__ds_BiPredicate.prototype["or"] = function(self,other) 
  local _gthis = self;
  do return __ds_BiPredicate.new(function(t,u) 
    if (not _gthis:test(t, u)) then 
      do return other:test(t, u) end;
    else
      do return true end;
    end;
  end) end
end

__ds_BiPredicate.prototype.__class__ =  __ds_BiPredicate

__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.new = function(func) 
  local self = _hx_new(__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype)
  __ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.super(self,func)
  return self
end
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.super = function(self,func) 
  self.func = func;
end
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.__name__ = "ds.BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum"
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype = _hx_e();
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype.func= nil;
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype.test = function(self,t,u) 
  do return self.func(t, u) end
end
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype["and"] = function(self,other) 
  local _gthis = self;
  do return __ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.new(function(t,u) 
    if (_gthis:test(t, u)) then 
      do return other:test(t, u) end;
    else
      do return false end;
    end;
  end) end
end
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype.negate = function(self) 
  local _gthis = self;
  do return __ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.new(function(t,u) 
    do return not _gthis:test(t, u) end;
  end) end
end
__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype["or"] = function(self,other) 
  local _gthis = self;
  do return __ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.new(function(t,u) 
    if (not _gthis:test(t, u)) then 
      do return other:test(t, u) end;
    else
      do return true end;
    end;
  end) end
end

__ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum.prototype.__class__ =  __ds_BiPredicate_diff_util_ThreeSideEnum_diff_util_ThreeSideEnum

__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new = function(func) 
  local self = _hx_new(__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype)
  __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.super(self,func)
  return self
end
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.super = function(self,func) 
  self.func = func;
end
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.__name__ = "ds.BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide"
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype = _hx_e();
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype.func= nil;
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype.test = function(self,t,u) 
  do return self.func(t, u) end
end
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype["and"] = function(self,other) 
  local _gthis = self;
  do return __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(t,u) 
    if (_gthis:test(t, u)) then 
      do return other:test(t, u) end;
    else
      do return false end;
    end;
  end) end
end
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype.negate = function(self) 
  local _gthis = self;
  do return __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(t,u) 
    do return not _gthis:test(t, u) end;
  end) end
end
__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype["or"] = function(self,other) 
  local _gthis = self;
  do return __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.new(function(t,u) 
    if (not _gthis:test(t, u)) then 
      do return other:test(t, u) end;
    else
      do return true end;
    end;
  end) end
end

__ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide.prototype.__class__ =  __ds_BiPredicate_diff_util_ThreeSide_diff_util_ThreeSide

__ds_BooleanSupplier.new = function(func) 
  local self = _hx_new(__ds_BooleanSupplier.prototype)
  __ds_BooleanSupplier.super(self,func)
  return self
end
__ds_BooleanSupplier.super = function(self,func) 
  self.func = func;
end
__ds_BooleanSupplier.__name__ = "ds.BooleanSupplier"
__ds_BooleanSupplier.prototype = _hx_e();
__ds_BooleanSupplier.prototype.func= nil;
__ds_BooleanSupplier.prototype.getAsBoolean = function(self) 
  do return self.func() end
end

__ds_BooleanSupplier.prototype.__class__ =  __ds_BooleanSupplier

__ds_Couple.new = function(first,second) 
  local self = _hx_new(__ds_Couple.prototype)
  __ds_Couple.super(self,first,second)
  return self
end
__ds_Couple.super = function(self,first,second) 
  self.first = first;
  self.second = second;
end
__ds_Couple.__name__ = "ds.Couple"
__ds_Couple.of_diff_comparison_iterables_FairDiffIterable = function(first,second) 
  do return __ds_Couple.new(first, second) end;
end
__ds_Couple.of_Array_diff_util_Range = function(first,second) 
  do return __ds_Couple.new(first, second) end;
end
__ds_Couple.prototype = _hx_e();
__ds_Couple.prototype.first= nil;
__ds_Couple.prototype.second= nil;

__ds_Couple.prototype.__class__ =  __ds_Couple

__ds_Enumerator.new = function(expectNumber) 
  local self = _hx_new(__ds_Enumerator.prototype)
  __ds_Enumerator.super(self,expectNumber)
  return self
end
__ds_Enumerator.super = function(self,expectNumber) 
  self.myNextNumber = 1;
  self.myNumbers = __haxe_ds_IntMap.new();
end
__ds_Enumerator.__name__ = "ds.Enumerator"
__ds_Enumerator.prototype = _hx_e();
__ds_Enumerator.prototype.myNumbers= nil;
__ds_Enumerator.prototype.myNextNumber= nil;
__ds_Enumerator.prototype.clear = function(self) 
  self.myNumbers.h = ({});
  self.myNextNumber = 1;
end
__ds_Enumerator.prototype.enumerateA = function(self,objects) 
  do return self:enumerateB(objects, 0, 0) end
end
__ds_Enumerator.prototype.enumerateB = function(self,objects,startShift,endCut) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = (objects.length - startShift) - endCut;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  local idx = _g;
  local _g = startShift;
  local _g1 = objects.length - endCut;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local object = objects[i];
    local number = self:enumerateC(object);
    idx[i - startShift] = number;
  end;
  do return idx end
end
__ds_Enumerator.prototype.enumerateC = function(self,object) 
  local res = self:enumerateImpl(object);
  do return Std.int(Math.max(res, -res)) end
end
__ds_Enumerator.prototype.add = function(self,object) 
  local res = self:enumerateImpl(object);
  do return res < 0 end
end
__ds_Enumerator.prototype.enumerateImpl = function(self,object) 
  if (object == nil) then 
    do return 0 end;
  end;
  local _this = self.myNumbers;
  local key = object:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local number = ret;
  if (number == nil) then 
    number = (function() 
    local _hx_obj = self;
    local _hx_fld = 'myNextNumber';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local _this = self.myNumbers;
    local key = object:hashCode();
    if (number == nil) then 
      _this.h[key] = __haxe_ds_IntMap.tnull;
    else
      _this.h[key] = number;
    end;
    do return -number end;
  end;
  do return number end
end
__ds_Enumerator.prototype.contains = function(self,object) 
  local _this = self.myNumbers;
  local key = object:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret ~= 0 end
end
__ds_Enumerator.prototype.get = function(self,object) 
  if (object == nil) then 
    do return 0 end;
  end;
  local _this = self.myNumbers;
  local key = object:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local res = ret;
  do return res end
end

__ds_Enumerator.prototype.__class__ =  __ds_Enumerator

__ds_Enumerator_util_HashableType.new = function(expectNumber) 
  local self = _hx_new(__ds_Enumerator_util_HashableType.prototype)
  __ds_Enumerator_util_HashableType.super(self,expectNumber)
  return self
end
__ds_Enumerator_util_HashableType.super = function(self,expectNumber) 
  self.myNextNumber = 1;
  self.myNumbers = __haxe_ds_IntMap.new();
end
__ds_Enumerator_util_HashableType.__name__ = "ds.Enumerator_util_HashableType"
__ds_Enumerator_util_HashableType.prototype = _hx_e();
__ds_Enumerator_util_HashableType.prototype.myNumbers= nil;
__ds_Enumerator_util_HashableType.prototype.myNextNumber= nil;
__ds_Enumerator_util_HashableType.prototype.clear = function(self) 
  self.myNumbers.h = ({});
  self.myNextNumber = 1;
end
__ds_Enumerator_util_HashableType.prototype.enumerateA = function(self,objects) 
  do return self:enumerateB(objects, 0, 0) end
end
__ds_Enumerator_util_HashableType.prototype.enumerateB = function(self,objects,startShift,endCut) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = (objects.length - startShift) - endCut;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  local idx = _g;
  local _g = startShift;
  local _g1 = objects.length - endCut;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local object = objects[i];
    local number = self:enumerateC(object);
    idx[i - startShift] = number;
  end;
  do return idx end
end
__ds_Enumerator_util_HashableType.prototype.enumerateC = function(self,object) 
  local res = self:enumerateImpl(object);
  do return Std.int(Math.max(res, -res)) end
end
__ds_Enumerator_util_HashableType.prototype.add = function(self,object) 
  local res = self:enumerateImpl(object);
  do return res < 0 end
end
__ds_Enumerator_util_HashableType.prototype.enumerateImpl = function(self,object) 
  if (object == nil) then 
    do return 0 end;
  end;
  local _this = self.myNumbers;
  local key = object:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local number = ret;
  if (number == nil) then 
    number = (function() 
    local _hx_obj = self;
    local _hx_fld = 'myNextNumber';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local _this = self.myNumbers;
    local key = object:hashCode();
    if (number == nil) then 
      _this.h[key] = __haxe_ds_IntMap.tnull;
    else
      _this.h[key] = number;
    end;
    do return -number end;
  end;
  do return number end
end
__ds_Enumerator_util_HashableType.prototype.contains = function(self,object) 
  local _this = self.myNumbers;
  local key = object:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret ~= 0 end
end
__ds_Enumerator_util_HashableType.prototype.get = function(self,object) 
  if (object == nil) then 
    do return 0 end;
  end;
  local _this = self.myNumbers;
  local key = object:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local res = ret;
  do return res end
end

__ds_Enumerator_util_HashableType.prototype.__class__ =  __ds_Enumerator_util_HashableType

__ds__MergingCharSequence_MergingCharSequence_Impl_.new = {}
__ds__MergingCharSequence_MergingCharSequence_Impl_.__name__ = "ds._MergingCharSequence.MergingCharSequence_Impl_"
__ds__MergingCharSequence_MergingCharSequence_Impl_._new = function(s1,s2) 
  do return String.new(Std.string(s1) .. Std.string(s2)) end;
end

__ds_Pair.new = function(first,second) 
  local self = _hx_new(__ds_Pair.prototype)
  __ds_Pair.super(self,first,second)
  return self
end
__ds_Pair.super = function(self,first,second) 
  self.first = first;
  self.second = second;
end
__ds_Pair.__name__ = "ds.Pair"
__ds_Pair.create_Null_empty_A_Null_empty_B = function(first,second) 
  do return __ds_Pair.new(first, second) end;
end
__ds_Pair.create_Array_diff_comparison_Line_Array_Int = function(first,second) 
  do return __ds_Pair.new(first, second) end;
end
__ds_Pair.create_diff_util_Range_Bool = function(first,second) 
  do return __ds_Pair.new(first, second) end;
end
__ds_Pair.createNonNull = function(first,second) 
  do return __ds_NonNull.new(first, second) end;
end
__ds_Pair.pair = function(first,second) 
  do return __ds_Pair.new(first, second) end;
end
__ds_Pair.getFirstA = function(pair) 
  if (pair ~= nil) then 
    do return pair.first end;
  else
    do return nil end;
  end;
end
__ds_Pair.getSecondA = function(pair) 
  if (pair ~= nil) then 
    do return pair.second end;
  else
    do return nil end;
  end;
end
__ds_Pair.empty = function() 
  do return __ds_Pair.create_Null_empty_A_Null_empty_B(nil, nil) end;
end
__ds_Pair.prototype = _hx_e();
__ds_Pair.prototype.first= nil;
__ds_Pair.prototype.second= nil;
__ds_Pair.prototype.getFirstB = function(self) 
  do return self.first end
end
__ds_Pair.prototype.getSecondB = function(self) 
  do return self.second end
end
__ds_Pair.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string("<") .. Std.string(Std.string(self.first))) .. Std.string(",")) .. Std.string(Std.string(self.second))) .. Std.string(">") end
end

__ds_Pair.prototype.__class__ =  __ds_Pair

__ds_NonNull.new = function(first,second) 
  local self = _hx_new(__ds_NonNull.prototype)
  __ds_NonNull.super(self,first,second)
  return self
end
__ds_NonNull.super = function(self,first,second) 
  __ds_Pair.super(self,first,second);
end
__ds_NonNull.__name__ = "ds.NonNull"
__ds_NonNull.prototype = _hx_e();

__ds_NonNull.prototype.__class__ =  __ds_NonNull
__ds_NonNull.__super__ = __ds_Pair
setmetatable(__ds_NonNull.prototype,{__index=__ds_Pair.prototype})

__ds_Predicate.new = function(func) 
  local self = _hx_new(__ds_Predicate.prototype)
  __ds_Predicate.super(self,func)
  return self
end
__ds_Predicate.super = function(self,func) 
  self.func = func;
end
__ds_Predicate.__name__ = "ds.Predicate"
__ds_Predicate.prototype = _hx_e();
__ds_Predicate.prototype.func= nil;
__ds_Predicate.prototype.test = function(self,t) 
  do return self.func(t) end
end
__ds_Predicate.prototype["and"] = function(self,other) 
  local _gthis = self;
  do return __ds_Predicate.new(function(t) 
    if (_gthis:test(t)) then 
      do return other:test(t) end;
    else
      do return false end;
    end;
  end) end
end
__ds_Predicate.prototype.negate = function(self) 
  local _gthis = self;
  do return __ds_Predicate.new(function(t) 
    do return not _gthis:test(t) end;
  end) end
end
__ds_Predicate.prototype["or"] = function(self,other) 
  local _gthis = self;
  do return __ds_Predicate.new(function(t) 
    if (not _gthis:test(t)) then 
      do return other:test(t) end;
    else
      do return true end;
    end;
  end) end
end
__ds_Predicate.prototype["not"] = function(self,target) 
  do return target:negate() end
end

__ds_Predicate.prototype.__class__ =  __ds_Predicate

__ds_Predicate_diff_util_ThreeSide.new = function(func) 
  local self = _hx_new(__ds_Predicate_diff_util_ThreeSide.prototype)
  __ds_Predicate_diff_util_ThreeSide.super(self,func)
  return self
end
__ds_Predicate_diff_util_ThreeSide.super = function(self,func) 
  self.func = func;
end
__ds_Predicate_diff_util_ThreeSide.__name__ = "ds.Predicate_diff_util_ThreeSide"
__ds_Predicate_diff_util_ThreeSide.prototype = _hx_e();
__ds_Predicate_diff_util_ThreeSide.prototype.func= nil;
__ds_Predicate_diff_util_ThreeSide.prototype.test = function(self,t) 
  do return self.func(t) end
end
__ds_Predicate_diff_util_ThreeSide.prototype["and"] = function(self,other) 
  local _gthis = self;
  do return __ds_Predicate_diff_util_ThreeSide.new(function(t) 
    if (_gthis:test(t)) then 
      do return other:test(t) end;
    else
      do return false end;
    end;
  end) end
end
__ds_Predicate_diff_util_ThreeSide.prototype.negate = function(self) 
  local _gthis = self;
  do return __ds_Predicate_diff_util_ThreeSide.new(function(t) 
    do return not _gthis:test(t) end;
  end) end
end
__ds_Predicate_diff_util_ThreeSide.prototype["or"] = function(self,other) 
  local _gthis = self;
  do return __ds_Predicate_diff_util_ThreeSide.new(function(t) 
    if (not _gthis:test(t)) then 
      do return other:test(t) end;
    else
      do return true end;
    end;
  end) end
end
__ds_Predicate_diff_util_ThreeSide.prototype["not"] = function(self,target) 
  do return target:negate() end
end

__ds_Predicate_diff_util_ThreeSide.prototype.__class__ =  __ds_Predicate_diff_util_ThreeSide

__ds_Predicate_diff_util_ThreeSideEnum.new = function(func) 
  local self = _hx_new(__ds_Predicate_diff_util_ThreeSideEnum.prototype)
  __ds_Predicate_diff_util_ThreeSideEnum.super(self,func)
  return self
end
__ds_Predicate_diff_util_ThreeSideEnum.super = function(self,func) 
  self.func = func;
end
__ds_Predicate_diff_util_ThreeSideEnum.__name__ = "ds.Predicate_diff_util_ThreeSideEnum"
__ds_Predicate_diff_util_ThreeSideEnum.prototype = _hx_e();
__ds_Predicate_diff_util_ThreeSideEnum.prototype.func= nil;
__ds_Predicate_diff_util_ThreeSideEnum.prototype.test = function(self,t) 
  do return self.func(t) end
end
__ds_Predicate_diff_util_ThreeSideEnum.prototype["and"] = function(self,other) 
  local _gthis = self;
  do return __ds_Predicate_diff_util_ThreeSideEnum.new(function(t) 
    if (_gthis:test(t)) then 
      do return other:test(t) end;
    else
      do return false end;
    end;
  end) end
end
__ds_Predicate_diff_util_ThreeSideEnum.prototype.negate = function(self) 
  local _gthis = self;
  do return __ds_Predicate_diff_util_ThreeSideEnum.new(function(t) 
    do return not _gthis:test(t) end;
  end) end
end
__ds_Predicate_diff_util_ThreeSideEnum.prototype["or"] = function(self,other) 
  local _gthis = self;
  do return __ds_Predicate_diff_util_ThreeSideEnum.new(function(t) 
    if (not _gthis:test(t)) then 
      do return other:test(t) end;
    else
      do return true end;
    end;
  end) end
end
__ds_Predicate_diff_util_ThreeSideEnum.prototype["not"] = function(self,target) 
  do return target:negate() end
end

__ds_Predicate_diff_util_ThreeSideEnum.prototype.__class__ =  __ds_Predicate_diff_util_ThreeSideEnum

__ds_Ref.new = function(value) 
  local self = _hx_new(__ds_Ref.prototype)
  __ds_Ref.super(self,value)
  return self
end
__ds_Ref.super = function(self,value) 
  if (value ~= nil) then 
    self.myValue = value;
  end;
end
__ds_Ref.__name__ = "ds.Ref"
__ds_Ref.prototype = _hx_e();
__ds_Ref.prototype.myValue= nil;
__ds_Ref.prototype.isNull = function(self) 
  do return self.myValue == nil end
end
__ds_Ref.prototype.get = function(self) 
  do return self.myValue end
end
__ds_Ref.prototype.set = function(self,value) 
  self.myValue = value;
end
__ds_Ref.prototype.setIfNull = function(self,value) 
  local result = (self.myValue == nil) and (value ~= nil);
  if (result) then 
    self.myValue = value;
  end;
  do return result end
end

__ds_Ref.prototype.__class__ =  __ds_Ref

__ds__Ref_Ref_Fields_.new = {}
__ds__Ref_Ref_Fields_.__name__ = "ds._Ref.Ref_Fields_"

__ds_Ref_util_diff_Change.new = function(value) 
  local self = _hx_new(__ds_Ref_util_diff_Change.prototype)
  __ds_Ref_util_diff_Change.super(self,value)
  return self
end
__ds_Ref_util_diff_Change.super = function(self,value) 
  if (value ~= nil) then 
    self.myValue = value;
  end;
end
__ds_Ref_util_diff_Change.__name__ = "ds.Ref_util_diff_Change"
__ds_Ref_util_diff_Change.prototype = _hx_e();
__ds_Ref_util_diff_Change.prototype.myValue= nil;
__ds_Ref_util_diff_Change.prototype.isNull = function(self) 
  do return self.myValue == nil end
end
__ds_Ref_util_diff_Change.prototype.get = function(self) 
  do return self.myValue end
end
__ds_Ref_util_diff_Change.prototype.set = function(self,value) 
  self.myValue = value;
end
__ds_Ref_util_diff_Change.prototype.setIfNull = function(self,value) 
  local result = (self.myValue == nil) and (value ~= nil);
  if (result) then 
    self.myValue = value;
  end;
  do return result end
end

__ds_Ref_util_diff_Change.prototype.__class__ =  __ds_Ref_util_diff_Change

__ds_TextRange.new = function(startOffset,endOffset) 
  local self = _hx_new(__ds_TextRange.prototype)
  __ds_TextRange.super(self,startOffset,endOffset)
  return self
end
__ds_TextRange.super = function(self,startOffset,endOffset) 
  self.myStartOffset = startOffset;
  self.myEndOffset = endOffset;
end
__ds_TextRange.__name__ = "ds.TextRange"
__ds_TextRange.prototype = _hx_e();
__ds_TextRange.prototype.myStartOffset= nil;
__ds_TextRange.prototype.myEndOffset= nil;
__ds_TextRange.prototype.subSequence = function(self,str) 
  do return String.prototype.substring(str, self.myStartOffset, self.myEndOffset) end
end

__ds_TextRange.prototype.__class__ =  __ds_TextRange

__exceptions_IllegalArgumentException.new = function(message,previous,native) 
  local self = _hx_new(__exceptions_IllegalArgumentException.prototype)
  __exceptions_IllegalArgumentException.super(self,message,previous,native)
  return self
end
__exceptions_IllegalArgumentException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__exceptions_IllegalArgumentException.__name__ = "exceptions.IllegalArgumentException"
__exceptions_IllegalArgumentException.prototype = _hx_e();

__exceptions_IllegalArgumentException.prototype.__class__ =  __exceptions_IllegalArgumentException
__exceptions_IllegalArgumentException.__super__ = __haxe_Exception
setmetatable(__exceptions_IllegalArgumentException.prototype,{__index=__haxe_Exception.prototype})

__exceptions_IllegalStateException.new = function(message,previous,native) 
  local self = _hx_new(__exceptions_IllegalStateException.prototype)
  __exceptions_IllegalStateException.super(self,message,previous,native)
  return self
end
__exceptions_IllegalStateException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__exceptions_IllegalStateException.__name__ = "exceptions.IllegalStateException"
__exceptions_IllegalStateException.prototype = _hx_e();

__exceptions_IllegalStateException.prototype.__class__ =  __exceptions_IllegalStateException
__exceptions_IllegalStateException.__super__ = __haxe_Exception
setmetatable(__exceptions_IllegalStateException.prototype,{__index=__haxe_Exception.prototype})

__exceptions_IndexOutOfBoundsException.new = function(message,previous,native) 
  local self = _hx_new(__exceptions_IndexOutOfBoundsException.prototype)
  __exceptions_IndexOutOfBoundsException.super(self,message,previous,native)
  return self
end
__exceptions_IndexOutOfBoundsException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__exceptions_IndexOutOfBoundsException.__name__ = "exceptions.IndexOutOfBoundsException"
__exceptions_IndexOutOfBoundsException.prototype = _hx_e();

__exceptions_IndexOutOfBoundsException.prototype.__class__ =  __exceptions_IndexOutOfBoundsException
__exceptions_IndexOutOfBoundsException.__super__ = __haxe_Exception
setmetatable(__exceptions_IndexOutOfBoundsException.prototype,{__index=__haxe_Exception.prototype})

__exceptions_NoSuchElementException.new = function(message,previous,native) 
  local self = _hx_new(__exceptions_NoSuchElementException.prototype)
  __exceptions_NoSuchElementException.super(self,message,previous,native)
  return self
end
__exceptions_NoSuchElementException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__exceptions_NoSuchElementException.__name__ = "exceptions.NoSuchElementException"
__exceptions_NoSuchElementException.prototype = _hx_e();

__exceptions_NoSuchElementException.prototype.__class__ =  __exceptions_NoSuchElementException
__exceptions_NoSuchElementException.__super__ = __haxe_Exception
setmetatable(__exceptions_NoSuchElementException.prototype,{__index=__haxe_Exception.prototype})

__exceptions_UnsupportedOperationException.new = function(message,previous,native) 
  local self = _hx_new(__exceptions_UnsupportedOperationException.prototype)
  __exceptions_UnsupportedOperationException.super(self,message,previous,native)
  return self
end
__exceptions_UnsupportedOperationException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__exceptions_UnsupportedOperationException.__name__ = "exceptions.UnsupportedOperationException"
__exceptions_UnsupportedOperationException.prototype = _hx_e();

__exceptions_UnsupportedOperationException.prototype.__class__ =  __exceptions_UnsupportedOperationException
__exceptions_UnsupportedOperationException.__super__ = __haxe_Exception
setmetatable(__exceptions_UnsupportedOperationException.prototype,{__index=__haxe_Exception.prototype})
_hxClasses["haxe.StackItem"] = { __ename__ = "haxe.StackItem", __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
__haxe_StackItem = _hxClasses["haxe.StackItem"];
__haxe_StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = __haxe_StackItem},2)

__haxe_StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.FilePos = function(s,file,line,column) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,column,__enum__=__haxe_StackItem}, 6); return _x; end 
__haxe_StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=__haxe_StackItem}, 4); return _x; end 
__haxe_StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=__haxe_StackItem}, 3); return _x; end 

__haxe__CallStack_CallStack_Impl_.new = {}
__haxe__CallStack_CallStack_Impl_.__name__ = "haxe._CallStack.CallStack_Impl_"
__haxe__CallStack_CallStack_Impl_.callStack = function() 
  do return __haxe_NativeStackTrace.toHaxe(__haxe_NativeStackTrace.callStack()) end;
end
__haxe__CallStack_CallStack_Impl_.exceptionStack = function(fullStack) 
  if (fullStack == nil) then 
    fullStack = false;
  end;
  local eStack = __haxe_NativeStackTrace.toHaxe(__haxe_NativeStackTrace.exceptionStack());
  do return (function() 
    local _hx_1
    if (fullStack) then 
    _hx_1 = eStack; else 
    _hx_1 = __haxe__CallStack_CallStack_Impl_.subtract(eStack, __haxe__CallStack_CallStack_Impl_.callStack()); end
    return _hx_1
  end )() end;
end
__haxe__CallStack_CallStack_Impl_.toString = function(stack) 
  local b = StringBuf.new();
  local _g = 0;
  local _g1 = stack;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local s = _g1[_g];
    _g = _g + 1;
    local str = "\nCalled from ";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    __haxe__CallStack_CallStack_Impl_.itemToString(b, s);
  end;
  do return _G.table.concat(b.b) end;
end
__haxe__CallStack_CallStack_Impl_.subtract = function(this1,stack) 
  local startIndex = -1;
  local i = -1;
  local _hx_do_first_1 = true;
  while (startIndex < 0) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    i = i + 1;
    if (not (i < this1.length)) then 
      break;
    end;
    local _g = 0;
    local _g1 = stack.length;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local j = _g - 1;
      if (__haxe__CallStack_CallStack_Impl_.equalItems(this1[i], stack[j])) then 
        if (startIndex < 0) then 
          startIndex = i;
        end;
        i = i + 1;
        if (i >= this1.length) then 
          break;
        end;
      else
        startIndex = -1;
      end;
    end;
  end;
  if (startIndex >= 0) then 
    do return this1:slice(0, startIndex) end;
  else
    do return this1 end;
  end;
end
__haxe__CallStack_CallStack_Impl_.equalItems = function(item1,item2) 
  if (item1 == nil) then 
    if (item2 == nil) then 
      do return true end;
    else
      do return false end;
    end;
  else
    local tmp = item1[1];
    if (tmp) == 0 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 0) then 
          do return true end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 1 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 1) then 
          local m2 = item2[2];
          local m1 = item1[2];
          do return m1 == m2 end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 2 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 2) then 
          local item21 = item2[2];
          local file2 = item2[3];
          local line2 = item2[4];
          local col2 = item2[5];
          local col1 = item1[5];
          local line1 = item1[4];
          local file1 = item1[3];
          local item1 = item1[2];
          if (((file1 == file2) and (line1 == line2)) and (col1 == col2)) then 
            do return __haxe__CallStack_CallStack_Impl_.equalItems(item1, item21) end;
          else
            do return false end;
          end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 3 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 3) then 
          local class2 = item2[2];
          local method2 = item2[3];
          local method1 = item1[3];
          local class1 = item1[2];
          if (class1 == class2) then 
            do return method1 == method2 end;
          else
            do return false end;
          end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 4 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 4) then 
          local v2 = item2[2];
          local v1 = item1[2];
          do return v1 == v2 end;
        else
          do return false end;
        end;
      end; end;
  end;
end
__haxe__CallStack_CallStack_Impl_.itemToString = function(b,s) 
  local tmp = s[1];
  if (tmp) == 0 then 
    local str = "a C function";
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 1 then 
    local m = s[2];
    local str = "module ";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(m);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 2 then 
    local s1 = s[2];
    local file = s[3];
    local line = s[4];
    local col = s[5];
    if (s1 ~= nil) then 
      __haxe__CallStack_CallStack_Impl_.itemToString(b, s1);
      local str = " (";
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local str = Std.string(file);
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = " line ";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(line);
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    if (col ~= nil) then 
      local str = " column ";
      _G.table.insert(b.b, str);
      local b1 = b;
      b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
      local str = Std.string(col);
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
    end;
    if (s1 ~= nil) then 
      local str = ")";
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
    end;
  elseif (tmp) == 3 then 
    local cname = s[2];
    local meth = s[3];
    local str = Std.string((function() 
      local _hx_1
      if (cname == nil) then 
      _hx_1 = "<unknown>"; else 
      _hx_1 = cname; end
      return _hx_1
    end )());
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = ".";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(meth);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 4 then 
    local n = s[2];
    local str = "local function #";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(n);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str); end;
end

__haxe_IMap.new = {}
__haxe_IMap.__name__ = "haxe.IMap"
__haxe_IMap.prototype = _hx_e();
__haxe_IMap.prototype.get= nil;
__haxe_IMap.prototype.set= nil;
__haxe_IMap.prototype.exists= nil;
__haxe_IMap.prototype.remove= nil;
__haxe_IMap.prototype.keys= nil;
__haxe_IMap.prototype.iterator= nil;

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe__Int32_Int32_Impl_.new = {}
__haxe__Int32_Int32_Impl_.__name__ = "haxe._Int32.Int32_Impl_"
__haxe__Int32_Int32_Impl_.mul = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp((a * (_hx_bit.band(b,65535))) + __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a * (_hx_bit.rshift(b,16)),16))) end;
end
__haxe__Int32_Int32_Impl_["or"] = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.clamp = function(x) 
  do return _hx_bit_clamp(x) end;
end

__haxe_Log.new = {}
__haxe_Log.__name__ = "haxe.Log"
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do _hx_do_first_1 = false;
      
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_NativeStackTrace.new = {}
__haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace"
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    do return String.prototype.split(s, "\n"):slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end
__haxe_NativeStackTrace.toHaxe = function(native,skip) 
  if (skip == nil) then 
    skip = 0;
  end;
  local stack = _hx_tab_array({}, 0);
  local cnt = -1;
  local _g = 0;
  local _hx_continue_1 = false;
  while (_g < native.length) do _hx_do_first_1 = false;
    repeat 
    local item = native[_g];
    _g = _g + 1;
    local parts = String.prototype.split(String.prototype.substr(item, 1), ":");
    local file = parts[0];
    if (file == "[C]") then 
      break;
    end;
    cnt = cnt + 1;
    if (skip > cnt) then 
      break;
    end;
    local line = parts[1];
    local method;
    if (parts.length <= 2) then 
      method = nil;
    else
      local methodPos = String.prototype.indexOf(parts[2], "'");
      method = (function() 
        local _hx_1
        if (methodPos < 0) then 
        _hx_1 = nil; else 
        _hx_1 = __haxe_StackItem.Method(nil, String.prototype.substring(parts[2], methodPos + 1, __lua_lib_luautf8_Utf8.len(parts[2]) - 1)); end
        return _hx_1
      end )();
    end;
    stack:push(__haxe_StackItem.FilePos(method, file, Std.parseInt(line)));until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return stack end;
end

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,(function() 
    local _hx_1
    if (value == nil) then 
    _hx_1 = "null"; else 
    _hx_1 = Std.string(value); end
    return _hx_1
  end )(),previous,native);
  self.value = value;
end
__haxe_ValueException.__name__ = "haxe.ValueException"
__haxe_ValueException.prototype = _hx_e();
__haxe_ValueException.prototype.value= nil;
__haxe_ValueException.prototype.unwrap = function(self) 
  do return self.value end
end

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})

__haxe_crypto_Base64.new = {}
__haxe_crypto_Base64.__name__ = "haxe.crypto.Base64"

__haxe_ds_BalancedTree.new = function() 
  local self = _hx_new(__haxe_ds_BalancedTree.prototype)
  __haxe_ds_BalancedTree.super(self)
  return self
end
__haxe_ds_BalancedTree.super = function(self) 
end
__haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree"
__haxe_ds_BalancedTree.__interfaces__ = {__haxe_IMap}
__haxe_ds_BalancedTree.iteratorLoop = function(node,acc) 
  if (node ~= nil) then 
    __haxe_ds_BalancedTree.iteratorLoop(node.left, acc);
    acc:push(node.value);
    __haxe_ds_BalancedTree.iteratorLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype = _hx_e();
__haxe_ds_BalancedTree.prototype.root= nil;
__haxe_ds_BalancedTree.prototype.set = function(self,key,value) 
  self.root = self:setLoop(key, value, self.root);
end
__haxe_ds_BalancedTree.prototype.get = function(self,key) 
  local node = self.root;
  while (node ~= nil) do _hx_do_first_1 = false;
    
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return node.value end;
    end;
    if (c < 0) then 
      node = node.left;
    else
      node = node.right;
    end;
  end;
  do return nil end
end
__haxe_ds_BalancedTree.prototype.remove = function(self,key) 
  local _hx_status, _hx_result = pcall(function() 
  
      self.root = self:removeLoop(key, self.root);
      do return true end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), String)) then 
      do return false end;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__haxe_ds_BalancedTree.prototype.exists = function(self,key) 
  local node = self.root;
  while (node ~= nil) do _hx_do_first_1 = false;
    
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return true end;
    else
      if (c < 0) then 
        node = node.left;
      else
        node = node.right;
      end;
    end;
  end;
  do return false end
end
__haxe_ds_BalancedTree.prototype.iterator = function(self) 
  local ret = _hx_tab_array({}, 0);
  __haxe_ds_BalancedTree.iteratorLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.keys = function(self) 
  local ret = _hx_tab_array({}, 0);
  self:keysLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.setLoop = function(self,k,v,node) 
  if (node == nil) then 
    do return __haxe_ds_TreeNode.new(nil, k, v, nil) end;
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return __haxe_ds_TreeNode.new(node.left, k, v, node.right, (function() 
      local _hx_1
      if (node == nil) then 
      _hx_1 = 0; else 
      _hx_1 = node._height; end
      return _hx_1
    end )()) end;
  else
    if (c < 0) then 
      local nl = self:setLoop(k, v, node.left);
      do return self:balance(nl, node.key, node.value, node.right) end;
    else
      local nr = self:setLoop(k, v, node.right);
      do return self:balance(node.left, node.key, node.value, nr) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.removeLoop = function(self,k,node) 
  if (node == nil) then 
    _G.error(__haxe_Exception.thrown("Not_found"),0);
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return self:merge(node.left, node.right) end;
  else
    if (c < 0) then 
      do return self:balance(self:removeLoop(k, node.left), node.key, node.value, node.right) end;
    else
      do return self:balance(node.left, node.key, node.value, self:removeLoop(k, node.right)) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.keysLoop = function(self,node,acc) 
  if (node ~= nil) then 
    self:keysLoop(node.left, acc);
    acc:push(node.key);
    self:keysLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype.merge = function(self,t1,t2) 
  if (t1 == nil) then 
    do return t2 end;
  end;
  if (t2 == nil) then 
    do return t1 end;
  end;
  local t = self:minBinding(t2);
  do return self:balance(t1, t.key, t.value, self:removeMinBinding(t2)) end
end
__haxe_ds_BalancedTree.prototype.minBinding = function(self,t) 
  if (t == nil) then 
    _G.error(__haxe_Exception.thrown("Not_found"),0);
  else
    if (t.left == nil) then 
      do return t end;
    else
      do return self:minBinding(t.left) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.removeMinBinding = function(self,t) 
  if (t.left == nil) then 
    do return t.right end;
  else
    do return self:balance(self:removeMinBinding(t.left), t.key, t.value, t.right) end;
  end;
end
__haxe_ds_BalancedTree.prototype.balance = function(self,l,k,v,r) 
  local hl = (function() 
    local _hx_1
    if (l == nil) then 
    _hx_1 = 0; else 
    _hx_1 = l._height; end
    return _hx_1
  end )();
  local hr = (function() 
    local _hx_2
    if (r == nil) then 
    _hx_2 = 0; else 
    _hx_2 = r._height; end
    return _hx_2
  end )();
  if (hl > (hr + 2)) then 
    local _this = l.left;
    local _this1 = l.right;
    if ((function() 
      local _hx_3
      if (_this == nil) then 
      _hx_3 = 0; else 
      _hx_3 = _this._height; end
      return _hx_3
    end )() >= (function() 
      local _hx_4
      if (_this1 == nil) then 
      _hx_4 = 0; else 
      _hx_4 = _this1._height; end
      return _hx_4
    end )()) then 
      do return __haxe_ds_TreeNode.new(l.left, l.key, l.value, __haxe_ds_TreeNode.new(l.right, k, v, r)) end;
    else
      do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, __haxe_ds_TreeNode.new(l.right.right, k, v, r)) end;
    end;
  else
    if (hr > (hl + 2)) then 
      local _this = r.right;
      local _this1 = r.left;
      if ((function() 
        local _hx_5
        if (_this == nil) then 
        _hx_5 = 0; else 
        _hx_5 = _this._height; end
        return _hx_5
      end )() > (function() 
        local _hx_6
        if (_this1 == nil) then 
        _hx_6 = 0; else 
        _hx_6 = _this1._height; end
        return _hx_6
      end )()) then 
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left), r.key, r.value, r.right) end;
      else
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left.left), r.left.key, r.left.value, __haxe_ds_TreeNode.new(r.left.right, r.key, r.value, r.right)) end;
      end;
    else
      do return __haxe_ds_TreeNode.new(l, k, v, r, (function() 
        local _hx_7
        if (hl > hr) then 
        _hx_7 = hl; else 
        _hx_7 = hr; end
        return _hx_7
      end )() + 1) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.compare = function(self,k1,k2) 
  do return Reflect.compare(k1, k2) end
end

__haxe_ds_BalancedTree.prototype.__class__ =  __haxe_ds_BalancedTree

__haxe_ds_TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(__haxe_ds_TreeNode.prototype)
  __haxe_ds_TreeNode.super(self,l,k,v,r,h)
  return self
end
__haxe_ds_TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this = self.left;
      tmp = (function() 
        local _hx_3
        if (_this == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this._height; end
        return _hx_3
      end )();
    else
      local _this = self.right;
      tmp = (function() 
        local _hx_4
        if (_this == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this._height; end
        return _hx_4
      end )();
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
__haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode"
__haxe_ds_TreeNode.prototype = _hx_e();
__haxe_ds_TreeNode.prototype.left= nil;
__haxe_ds_TreeNode.prototype.right= nil;
__haxe_ds_TreeNode.prototype.key= nil;
__haxe_ds_TreeNode.prototype.value= nil;
__haxe_ds_TreeNode.prototype._height= nil;

__haxe_ds_TreeNode.prototype.__class__ =  __haxe_ds_TreeNode

__haxe_ds_EnumValueMap.new = function() 
  local self = _hx_new(__haxe_ds_EnumValueMap.prototype)
  __haxe_ds_EnumValueMap.super(self)
  return self
end
__haxe_ds_EnumValueMap.super = function(self) 
  __haxe_ds_BalancedTree.super(self);
end
__haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap"
__haxe_ds_EnumValueMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_EnumValueMap.prototype = _hx_e();
__haxe_ds_EnumValueMap.prototype.compare = function(self,k1,k2) 
  local d = k1[1] - k2[1];
  if (d ~= 0) then 
    do return d end;
  end;
  local p1 = k1:slice(2);
  local p2 = k2:slice(2);
  if ((p1.length == 0) and (p2.length == 0)) then 
    do return 0 end;
  end;
  do return self:compareArgs(p1, p2) end
end
__haxe_ds_EnumValueMap.prototype.compareArgs = function(self,a1,a2) 
  local ld = a1.length - a2.length;
  if (ld ~= 0) then 
    do return ld end;
  end;
  local _g = 0;
  local _g1 = a1.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local d = self:compareArg(a1[i], a2[i]);
    if (d ~= 0) then 
      do return d end;
    end;
  end;
  do return 0 end
end
__haxe_ds_EnumValueMap.prototype.compareArg = function(self,v1,v2) 
  if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
    do return self:compare(v1, v2) end;
  else
    if (__lua_Boot.__instanceof(v1, Array) and __lua_Boot.__instanceof(v2, Array)) then 
      do return self:compareArgs(v1, v2) end;
    else
      do return Reflect.compare(v1, v2) end;
    end;
  end;
end

__haxe_ds_EnumValueMap.prototype.__class__ =  __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__super__ = __haxe_ds_BalancedTree
setmetatable(__haxe_ds_EnumValueMap.prototype,{__index=__haxe_ds_BalancedTree.prototype})

__haxe_ds_IntMap.new = function() 
  local self = _hx_new(__haxe_ds_IntMap.prototype)
  __haxe_ds_IntMap.super(self)
  return self
end
__haxe_ds_IntMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_IntMap.__name__ = "haxe.ds.IntMap"
__haxe_ds_IntMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_IntMap.prototype = _hx_e();
__haxe_ds_IntMap.prototype.h= nil;
__haxe_ds_IntMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_IntMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_IntMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_IntMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_IntMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_IntMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_IntMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end

__haxe_ds_IntMap.prototype.__class__ =  __haxe_ds_IntMap

__haxe_ds_ObjectMap.new = function() 
  local self = _hx_new(__haxe_ds_ObjectMap.prototype)
  __haxe_ds_ObjectMap.super(self)
  return self
end
__haxe_ds_ObjectMap.super = function(self) 
  self.h = ({});
  self.k = ({});
end
__haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap"
__haxe_ds_ObjectMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_ObjectMap.prototype = _hx_e();
__haxe_ds_ObjectMap.prototype.h= nil;
__haxe_ds_ObjectMap.prototype.k= nil;
__haxe_ds_ObjectMap.prototype.set = function(self,key,value) 
  self.h[key] = value;
  self.k[key] = true;
end
__haxe_ds_ObjectMap.prototype.get = function(self,key) 
  do return self.h[key] end
end
__haxe_ds_ObjectMap.prototype.exists = function(self,key) 
  do return self.k[key] ~= nil end
end
__haxe_ds_ObjectMap.prototype.remove = function(self,key) 
  if (self.k[key] == nil) then 
    do return false end;
  end;
  self.k[key] = nil;
  self.h[key] = nil;
  do return true end
end
__haxe_ds_ObjectMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.k, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.iterator = function(self) 
  local _gthis = self;
  local itr = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end,next=function(self) 
    do return _gthis.h[itr:next()] end;
  end}) end
end

__haxe_ds_ObjectMap.prototype.__class__ =  __haxe_ds_ObjectMap
_hxClasses["haxe.ds.Option"] = { __ename__ = "haxe.ds.Option", __constructs__ = _hx_tab_array({[0]="Some","None"},2)}
__haxe_ds_Option = _hxClasses["haxe.ds.Option"];
__haxe_ds_Option.Some = function(v) local _x = _hx_tab_array({[0]="Some",0,v,__enum__=__haxe_ds_Option}, 3); return _x; end 
__haxe_ds_Option.None = _hx_tab_array({[0]="None",1,__enum__ = __haxe_ds_Option},2)


__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_StringMap.__name__ = "haxe.ds.StringMap"
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.h= nil;
__haxe_ds_StringMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_StringMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    do return nil end;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_StringMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_StringMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_ds__Vector_Vector_Impl_.new = {}
__haxe_ds__Vector_Vector_Impl_.__name__ = "haxe.ds._Vector.Vector_Impl_"
__haxe_ds__Vector_Vector_Impl_.blit = function(src,srcPos,dest,destPos,len) 
  if (src == dest) then 
    if (srcPos < destPos) then 
      local i = srcPos + len;
      local j = destPos + len;
      local _g = 0;
      local _g1 = len;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local k = _g - 1;
        i = i - 1;
        j = j - 1;
        src[j] = src[i];
      end;
    else
      if (srcPos > destPos) then 
        local i = srcPos;
        local j = destPos;
        local _g = 0;
        local _g1 = len;
        while (_g < _g1) do _hx_do_first_1 = false;
          
          _g = _g + 1;
          local k = _g - 1;
          src[j] = src[i];
          i = i + 1;
          j = j + 1;
        end;
      end;
    end;
  else
    local _g = 0;
    local _g1 = len;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      dest[destPos + i] = src[srcPos + i];
    end;
  end;
end
__haxe_ds__Vector_Vector_Impl_.toArray = function(this1) 
  local a = Array.new();
  local len = this1.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    a[i] = this1[i];
  end;
  do return a end;
end

__haxe_exceptions_PosException.new = function(message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_PosException.prototype)
  __haxe_exceptions_PosException.super(self,message,previous,pos)
  return self
end
__haxe_exceptions_PosException.super = function(self,message,previous,pos) 
  __haxe_Exception.super(self,message,previous);
  if (pos == nil) then 
    self.posInfos = _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="(unknown)",lineNumber=0,className="(unknown)",methodName="(unknown)"});
  else
    self.posInfos = pos;
  end;
end
__haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException"
__haxe_exceptions_PosException.prototype = _hx_e();
__haxe_exceptions_PosException.prototype.posInfos= nil;
__haxe_exceptions_PosException.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__haxe_Exception.prototype.toString(self))) .. Std.string(" in ")) .. Std.string(self.posInfos.className)) .. Std.string(".")) .. Std.string(self.posInfos.methodName)) .. Std.string(" at ")) .. Std.string(self.posInfos.fileName)) .. Std.string(":")) .. Std.string(self.posInfos.lineNumber) end
end

__haxe_exceptions_PosException.prototype.__class__ =  __haxe_exceptions_PosException
__haxe_exceptions_PosException.__super__ = __haxe_Exception
setmetatable(__haxe_exceptions_PosException.prototype,{__index=__haxe_Exception.prototype})

__haxe_exceptions_NotImplementedException.new = function(message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_NotImplementedException.prototype)
  __haxe_exceptions_NotImplementedException.super(self,message,previous,pos)
  return self
end
__haxe_exceptions_NotImplementedException.super = function(self,message,previous,pos) 
  if (message == nil) then 
    message = "Not implemented";
  end;
  __haxe_exceptions_PosException.super(self,message,previous,pos);
end
__haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException"
__haxe_exceptions_NotImplementedException.prototype = _hx_e();

__haxe_exceptions_NotImplementedException.prototype.__class__ =  __haxe_exceptions_NotImplementedException
__haxe_exceptions_NotImplementedException.__super__ = __haxe_exceptions_PosException
setmetatable(__haxe_exceptions_NotImplementedException.prototype,{__index=__haxe_exceptions_PosException.prototype})

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
__haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator"
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.array= nil;
__haxe_iterators_ArrayIterator.prototype.current= nil;
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.array = array;
end
__haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator"
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();
__haxe_iterators_ArrayKeyValueIterator.prototype.array= nil;

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__iterators_PeekableIterator.new = {}
__iterators_PeekableIterator.__name__ = "iterators.PeekableIterator"
__iterators_PeekableIterator.prototype = _hx_e();
__iterators_PeekableIterator.prototype.hasNext= nil;
__iterators_PeekableIterator.prototype.next= nil;
__iterators_PeekableIterator.prototype.peek= nil;

__iterators_PeekableIterator.prototype.__class__ =  __iterators_PeekableIterator

__iterators_PeekableIteratorWrapper.new = function(values) 
  local self = _hx_new(__iterators_PeekableIteratorWrapper.prototype)
  __iterators_PeekableIteratorWrapper.super(self,values)
  return self
end
__iterators_PeekableIteratorWrapper.super = function(self,values) 
  self.myValidValue = false;
  self.myValue = nil;
  self.myIterator = values:iterator();
  self:advance();
end
__iterators_PeekableIteratorWrapper.__name__ = "iterators.PeekableIteratorWrapper"
__iterators_PeekableIteratorWrapper.__interfaces__ = {__iterators_PeekableIterator}
__iterators_PeekableIteratorWrapper.prototype = _hx_e();
__iterators_PeekableIteratorWrapper.prototype.myIterator= nil;
__iterators_PeekableIteratorWrapper.prototype.myValue= nil;
__iterators_PeekableIteratorWrapper.prototype.myValidValue= nil;
__iterators_PeekableIteratorWrapper.prototype.hasNext = function(self) 
  do return self.myValidValue end
end
__iterators_PeekableIteratorWrapper.prototype.next = function(self) 
  if (self.myValidValue) then 
    local save = self.myValue;
    self:advance();
    do return save end;
  end;
  _G.error(__exceptions_NoSuchElementException.new(""),0);
end
__iterators_PeekableIteratorWrapper.prototype.peek = function(self) 
  if (self.myValidValue) then 
    do return self.myValue end;
  end;
  _G.error(__exceptions_NoSuchElementException.new(""),0);
end
__iterators_PeekableIteratorWrapper.prototype.remove = function(self) 
  _G.error(__exceptions_UnsupportedOperationException.new(""),0);
end
__iterators_PeekableIteratorWrapper.prototype.advance = function(self) 
  self.myValidValue = self.myIterator:hasNext();
  self.myValue = (function() 
    local _hx_1
    if (self.myValidValue) then 
    _hx_1 = self.myIterator:next(); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
end

__iterators_PeekableIteratorWrapper.prototype.__class__ =  __iterators_PeekableIteratorWrapper

__iterators_StepIterator.new = function(start,_end,step,inclusive) 
  local self = _hx_new(__iterators_StepIterator.prototype)
  __iterators_StepIterator.super(self,start,_end,step,inclusive)
  return self
end
__iterators_StepIterator.super = function(self,start,_end,step,inclusive) 
  self.index = start;
  self["end"] = _end;
  self.step = step;
  self.inclusive = inclusive;
end
__iterators_StepIterator.__name__ = "iterators.StepIterator"
__iterators_StepIterator.prototype = _hx_e();
__iterators_StepIterator.prototype["end"]= nil;
__iterators_StepIterator.prototype.step= nil;
__iterators_StepIterator.prototype.index= nil;
__iterators_StepIterator.prototype.inclusive= nil;
__iterators_StepIterator.prototype.hasNext = function(self) 
  if (self.inclusive) then 
    do return self.index <= self["end"] end;
  else
    do return self.index < self["end"] end;
  end;
end
__iterators_StepIterator.prototype.next = function(self) 
  local tmp = self;
  tmp.index = tmp.index + self.step;
  do return tmp.index - self.step end
end

__iterators_StepIterator.prototype.__class__ =  __iterators_StepIterator

__lua_Boot.new = {}
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.__cast = function(o,t) 
  if ((o == nil) or __lua_Boot.__instanceof(o, t)) then 
    do return o end;
  else
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Cannot cast ") .. Std.string(Std.string(o))) .. Std.string(" to ")) .. Std.string(Std.string(t))),0);
  end;
end
__lua_Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(date:getFullYear()) .. Std.string("-")) .. Std.string(((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = Std.string("0") .. Std.string(m); else 
    _hx_1 = Std.string("") .. Std.string(m); end
    return _hx_1
  end )()))) .. Std.string("-")) .. Std.string(((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = Std.string("0") .. Std.string(d); else 
    _hx_2 = Std.string("") .. Std.string(d); end
    return _hx_2
  end )()))) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = Std.string("0") .. Std.string(h); else 
    _hx_3 = Std.string("") .. Std.string(h); end
    return _hx_3
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = Std.string("0") .. Std.string(mi); else 
    _hx_4 = Std.string("") .. Std.string(mi); end
    return _hx_4
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = Std.string("0") .. Std.string(s); else 
    _hx_5 = Std.string("") .. Std.string(s); end
    return _hx_5
  end )())) end;
end
__lua_Boot.strDate = function(s) 
  local _g = __lua_lib_luautf8_Utf8.len(s);
  if (_g) == 8 then 
    local k = String.prototype.split(s, ":");
    local t = ((_G.tonumber(k[0]) * 3600000.) + (_G.tonumber(k[1]) * 60000.)) + (_G.tonumber(k[2]) * 1000.);
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    do return d end;
  elseif (_g) == 10 then 
    local k = String.prototype.split(s, "-");
    do return Date.new(_G.tonumber(k[0]), _G.tonumber(k[1]) - 1, _G.tonumber(k[2]), 0, 0, 0) end;
  elseif (_g) == 19 then 
    local k = String.prototype.split(s, " ");
    local y = String.prototype.split(k[0], "-");
    local t = String.prototype.split(k[1], ":");
    do return Date.new(_G.tonumber(y[0]), _G.tonumber(y[1]) - 1, _G.tonumber(y[2]), _G.tonumber(t[0]), _G.tonumber(t[1]), _G.tonumber(t[2])) end;else
  _G.error(__haxe_Exception.thrown(Std.string("Invalid date format : ") .. Std.string(s)),0); end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do _hx_do_first_1 = false;
          
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end

__lua_UserData.new = {}
__lua_UserData.__name__ = "lua.UserData"

__lua_Lib.new = {}
__lua_Lib.__name__ = "lua.Lib"
__lua_Lib.fillArray = function(itr) 
  local i = nil;
  local ret = _hx_tab_array({}, 0);
  while (true) do _hx_do_first_1 = false;
    
    i = itr();
    if (not (i ~= nil)) then 
      break;
    end;
    ret:push(i);
  end;
  do return ret end;
end

__lua_Thread.new = {}
__lua_Thread.__name__ = "lua.Thread"

__thx_Arrays.new = {}
__thx_Arrays.__name__ = "thx.Arrays"
__thx_Arrays.append = function(array,element) 
  array:push(element);
  do return array end;
end
__thx_Arrays.appendIf = function(array,cond,element) 
  if (cond) then 
    array:push(element);
  end;
  do return array end;
end
__thx_Arrays.applyIndexes = function(array,indexes,incrementDuplicates) 
  if (incrementDuplicates == nil) then 
    incrementDuplicates = false;
  end;
  if (indexes.length ~= array.length) then 
    _G.error(__haxe_Exception.thrown(__thx_Error.new("`Arrays.applyIndexes` can only be applied to two arrays with the same length", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/Arrays.hx",lineNumber=55,className="thx.Arrays",methodName="applyIndexes"}))),0);
  end;
  local result = _hx_tab_array({}, 0);
  if (incrementDuplicates) then 
    local usedIndexes = __thx__Set_Set_Impl_.createInt();
    local _g = 0;
    local _g1 = array.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local index = indexes[i];
      while (usedIndexes.h[index] ~= nil) do _hx_do_first_2 = false;
        
        index = index + 1;
      end;
      __thx__Set_Set_Impl_.add(usedIndexes, index);
      result[index] = array[i];
    end;
  else
    local _g = 0;
    local _g1 = array.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      result[indexes[i]] = array[i];
    end;
  end;
  do return result end;
end
__thx_Arrays.monoid = function() 
  do return _hx_o({__fields__={zero=true,append=true},zero=_hx_tab_array({}, 0),append=function(self,a,b) 
    do return a:concat(b) end;
  end}) end;
end
__thx_Arrays.after = function(array,element) 
  do return array:slice(_hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(array, element) + 1) end;
end
__thx_Arrays.atIndex = function(array,i) 
  if ((i >= 0) and (i < array.length)) then 
    do return __haxe_ds_Option.Some(array[i]) end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__thx_Arrays.getOption = function(array,i) 
  local value = array[i];
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Arrays.each = function(arr,effect) 
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    effect(arr[i]);
  end;
end
__thx_Arrays.eachi = function(arr,effect) 
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    effect(arr[i], i);
  end;
end
__thx_Arrays.all = function(arr,predicate) 
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (not predicate(arr[i])) then 
      do return false end;
    end;
  end;
  do return true end;
end
__thx_Arrays.any = function(arr,predicate) 
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (predicate(arr[i])) then 
      do return true end;
    end;
  end;
  do return false end;
end
__thx_Arrays.at = function(arr,indexes) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = indexes;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(arr[i]);
  end;
  do return _g end;
end
__thx_Arrays.before = function(array,element) 
  do return array:slice(0, _hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(array, element)) end;
end
__thx_Arrays.commonsFromStart = function(_self,other,equality) 
  if (nil == equality) then 
    equality = __thx_Functions.equality;
  end;
  local count = 0;
  local _g = 0;
  local _g1 = __thx_Arrays.zip(_self, other);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local pair = _g1[_g];
    _g = _g + 1;
    if (equality(pair._0, pair._1)) then 
      count = count + 1;
    else
      break;
    end;
  end;
  do return _self:slice(0, count) end;
end
__thx_Arrays.compact = function(arr) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = arr;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (nil ~= i) then 
      _g:push(i);
    end;
  end;
  do return _g end;
end
__thx_Arrays.compare = function(a,b) 
  local v = __thx_Ints.compare(a.length, b.length);
  if (v ~= 0) then 
    do return v end;
  end;
  local _g = 0;
  local _g1 = a.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    v = __thx_Dynamics.compare(a[i], b[i]);
    if (v ~= 0) then 
      do return v end;
    end;
  end;
  do return 0 end;
end
__thx_Arrays.contains = function(array,element,eq) 
  if (nil == eq) then 
    do return _hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(array, element) >= 0 end;
  else
    local _g = 0;
    local _g1 = array.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      if (eq(array[i], element)) then 
        do return true end;
      end;
    end;
    do return false end;
  end;
end
__thx_Arrays.containsAll = function(array,elements,eq) 
  local el = elements:iterator();
  while (el:hasNext()) do _hx_do_first_1 = false;
    
    local el = el:next();
    if (not __thx_Arrays.contains(array, el, eq)) then 
      do return false end;
    end;
  end;
  do return true end;
end
__thx_Arrays.containsAny = function(array,elements,eq) 
  local el = elements:iterator();
  while (el:hasNext()) do _hx_do_first_1 = false;
    
    local el = el:next();
    if (__thx_Arrays.contains(array, el, eq)) then 
      do return true end;
    end;
  end;
  do return false end;
end
__thx_Arrays.create = function(length,fillWith) 
  local arr = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    arr[i] = fillWith;
  end;
  do return arr end;
end
__thx_Arrays.fromItem = function(t) 
  do return _hx_tab_array({[0]=t}, 1) end;
end
__thx_Arrays.cross = function(a,b) 
  local r = _hx_tab_array({}, 0);
  local _g_current = 0;
  local _g_array = a;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local va = _g_array[_g_current - 1];
    local _g_current = 0;
    local _g_array = b;
    while (_g_current < _g_array.length) do _hx_do_first_2 = false;
      
      _g_current = _g_current + 1;
      local vb = _g_array[_g_current - 1];
      r:push(_hx_tab_array({[0]=va, vb}, 2));
    end;
  end;
  do return r end;
end
__thx_Arrays.crossMulti = function(array) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local acopy = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = acopy:shift();
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(_hx_tab_array({[0]=i}, 1));
  end;
  local result = _g;
  while (acopy.length > 0) do _hx_do_first_1 = false;
    
    local array = acopy:shift();
    local tresult = result;
    result = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = array;
    while (_g_current < _g_array.length) do _hx_do_first_2 = false;
      
      _g_current = _g_current + 1;
      local v = _g_array[_g_current - 1];
      local _g = 0;
      while (_g < tresult.length) do _hx_do_first_3 = false;
        
        local ar = tresult[_g];
        _g = _g + 1;
        local _g = _hx_tab_array({}, 0);
        local _g1 = 0;
        local _g2 = ar;
        while (_g1 < _g2.length) do _hx_do_first_4 = false;
          
          local i = _g2[_g1];
          _g1 = _g1 + 1;
          _g:push(i);
        end;
        local t = _g;
        t:push(v);
        result:push(t);
      end;
    end;
  end;
  do return result end;
end
__thx_Arrays.distinct = function(array,predicate) 
  local result = _hx_tab_array({}, 0);
  if (array.length <= 1) then 
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = array;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
    end;
    do return _g end;
  end;
  if (nil == predicate) then 
    predicate = __thx_Functions.equality;
  end;
  local _g_current = 0;
  local _g_array = array;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local v = _hx_tab_array({[0]=_g_array[_g_current - 1]}, 1);
    local keep = not __thx_Arrays.any(result, (function(v) 
      do return function(r) 
        do return predicate(r, v[0]) end;
      end end;
    end)(v));
    if (keep) then 
      result:push(v[0]);
    end;
  end;
  do return result end;
end
__thx_Arrays.eachPair = function(array,callback) 
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local _g = i;
    local _g1 = array.length;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local j = _g - 1;
      if (not callback(array[i], array[j])) then 
        do return end;
      end;
    end;
  end;
end
__thx_Arrays.equals = function(a,b,equality) 
  if (((a == nil) or (b == nil)) or (a.length ~= b.length)) then 
    do return false end;
  end;
  if (nil == equality) then 
    equality = __thx_Functions.equality;
  end;
  local _g = 0;
  local _g1 = a.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (not equality(a[i], b[i])) then 
      do return false end;
    end;
  end;
  do return true end;
end
__thx_Arrays.extract = function(a,predicate) 
  local _g = 0;
  local _g1 = a.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (predicate(a[i])) then 
      do return a:splice(i, 1)[0] end;
    end;
  end;
  do return nil end;
end
__thx_Arrays.filterNull = function(a) 
  local arr = _hx_tab_array({}, 0);
  local _g_current = 0;
  local _g_array = a;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local v = _g_array[_g_current - 1];
    if (nil ~= v) then 
      arr:push(v);
    end;
  end;
  do return arr end;
end
__thx_Arrays.filterOption = function(a) 
  do return __thx_Arrays.reduce(a, function(acc,maybeV) 
    local tmp = maybeV[1];
    if (tmp) == 0 then 
      local v = maybeV[2];
      acc:push(v);
    elseif (tmp) == 1 then  end;
    do return acc end;
  end, _hx_tab_array({}, 0)) end;
end
__thx_Arrays.flattenOptions = function(a) 
  local acc = _hx_tab_array({}, 0);
  local _g_current = 0;
  local _g_array = a;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local e = _g_array[_g_current - 1];
    local tmp = e[1];
    if (tmp) == 0 then 
      local v = e[2];
      acc:push(v);
    elseif (tmp) == 1 then 
      do return __haxe_ds_Option.None end; end;
  end;
  do return __haxe_ds_Option.Some(acc) end;
end
__thx_Arrays.find = function(array,predicate) 
  local _g_current = 0;
  local _g_array = array;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local element = _g_array[_g_current - 1];
    if (predicate(element)) then 
      do return element end;
    end;
  end;
  do return nil end;
end
__thx_Arrays.findi = function(array,predicate) 
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (predicate(array[i], i)) then 
      do return array[i] end;
    end;
  end;
  do return nil end;
end
__thx_Arrays.findiOption = function(array,predicate) 
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (predicate(array[i], i)) then 
      do return __haxe_ds_Option.Some(array[i]) end;
    end;
  end;
  do return __haxe_ds_Option.None end;
end
__thx_Arrays.findOption = function(array,predicate) 
  local _g_current = 0;
  local _g_array = array;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local element = _g_array[_g_current - 1];
    if (predicate(element)) then 
      do return __haxe_ds_Option.Some(element) end;
    end;
  end;
  do return __haxe_ds_Option.None end;
end
__thx_Arrays.findMap = function(values,f) 
  local _g_current = 0;
  local _g_array = values;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local value = _g_array[_g_current - 1];
    local opt = f(value);
    if (not __thx_Options.isNone(opt)) then 
      do return opt end;
    end;
  end;
  do return __haxe_ds_Option.None end;
end
__thx_Arrays.filterMap = function(values,f) 
  local acc = _hx_tab_array({}, 0);
  local _g_current = 0;
  local _g_array = values;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local value = _g_array[_g_current - 1];
    local _g = f(value);
    local tmp = _g[1];
    if (tmp) == 0 then 
      local v = _g[2];
      acc:push(v);
    elseif (tmp) == 1 then  end;
  end;
  do return acc end;
end
__thx_Arrays.findSome = function(options) 
  local _g_current = 0;
  local _g_array = options;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local option = _g_array[_g_current - 1];
    if (not __thx_Options.isNone(option)) then 
      do return option end;
    end;
  end;
  do return __haxe_ds_Option.None end;
end
__thx_Arrays.findIndex = function(array,predicate) 
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (predicate(array[i])) then 
      do return i end;
    end;
  end;
  do return -1 end;
end
__thx_Arrays.findLast = function(array,predicate) 
  local len = array.length;
  local j;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    j = (len - i) - 1;
    if (predicate(array[j])) then 
      do return array[j] end;
    end;
  end;
  do return nil end;
end
__thx_Arrays.first = function(array) 
  do return array[0] end;
end
__thx_Arrays.firstOption = function(array) 
  local value = array[0];
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Arrays.flatMap = function(array,callback) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(callback(i));
  end;
  do return __thx_Arrays.flatten(_g) end;
end
__thx_Arrays.flatten = function(array) 
  do return __thx_Arrays.reduce(array, function(acc,element) 
    do return acc:concat(element) end;
  end, _hx_tab_array({}, 0)) end;
end
__thx_Arrays.from = function(array,element) 
  do return array:slice(_hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(array, element)) end;
end
__thx_Arrays.groupByAppend = function(arr,resolver,map) 
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local v = arr[i];
    local key = resolver(v);
    local acc = map:get(key);
    if (nil == acc) then 
      map:set(key, _hx_tab_array({[0]=v}, 1));
    else
      acc:push(v);
    end;
  end;
  do return map end;
end
__thx_Arrays.spanByIndex = function(arr,spanKey) 
  local acc = _hx_tab_array({}, 0);
  local cur = nil;
  local j = -1;
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local k = spanKey(i);
    if (k == nil) then 
      _G.error(__haxe_Exception.thrown(__thx_Error.new(Std.string("spanKey function returned null for index ") .. Std.string(i), nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/Arrays.hx",lineNumber=633,className="thx.Arrays",methodName="spanByIndex"}))),0);
    end;
    if (cur == k) then 
      acc[j]:push(arr[i]);
    else
      cur = k;
      j = j + 1;
      acc:push(_hx_tab_array({[0]=arr[i]}, 1));
    end;
  end;
  do return acc end;
end
__thx_Arrays.hasElements = function(array) 
  if (nil ~= array) then 
    do return array.length > 0 end;
  else
    do return false end;
  end;
end
__thx_Arrays.head = function(array) 
  do return array[0] end;
end
__thx_Arrays.ifEmpty = function(array,alt) 
  if ((nil ~= array) and (0 ~= array.length)) then 
    do return array end;
  else
    do return alt end;
  end;
end
__thx_Arrays.initial = function(array) 
  do return array:slice(0, array.length - 1) end;
end
__thx_Arrays.intersperse = function(array,value) 
  do return __thx_Arrays.reducei(array, function(acc,v,i) 
    acc[i * 2] = v;
    do return acc end;
  end, __thx_Arrays.create((array.length * 2) - 1, value)) end;
end
__thx_Arrays.interspersef = function(array,f) 
  if (array.length == 0) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local acc = _hx_tab_array({[0]=array[0]}, 1);
  local _g = 1;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    acc:push(f());
    acc:push(array[i]);
  end;
  do return acc end;
end
__thx_Arrays.isEmpty = function(array) 
  if (nil ~= array) then 
    do return array.length == 0 end;
  else
    do return true end;
  end;
end
__thx_Arrays.last = function(array) 
  do return array[array.length - 1] end;
end
__thx_Arrays.lastOption = function(array) 
  local value = array[array.length - 1];
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Arrays.map = function(array,callback) 
  local r = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    r:push(callback(array[i]));
  end;
  do return r end;
end
__thx_Arrays.mapi = function(array,callback) 
  local r = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    r:push(callback(array[i], i));
  end;
  do return r end;
end
__thx_Arrays.mapRight = function(array,callback) 
  local i = array.length;
  local result = _hx_tab_array({}, 0);
  while (true) do _hx_do_first_1 = false;
    
    i = i - 1;
    if (not (i >= 0)) then 
      break;
    end;
    result:push(callback(array[i]));
  end;
  do return result end;
end
__thx_Arrays.order = function(array,sort) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local n = _g;
  n:sort(sort);
  do return n end;
end
__thx_Arrays.pull = function(array,toRemove,equality) 
  local _g_current = 0;
  local _g_array = toRemove;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local element = _g_array[_g_current - 1];
    __thx_Arrays.removeAll(array, element, equality);
  end;
end
__thx_Arrays.pushIf = function(array,condition,value) 
  if (condition) then 
    array:push(value);
  end;
  do return array end;
end
__thx_Arrays.rank = function(array,compare,incrementDuplicates) 
  if (incrementDuplicates == nil) then 
    incrementDuplicates = true;
  end;
  local arr = __thx_Arrays.mapi(array, function(v,i) 
    do return _hx_o({__fields__={_0=true,_1=true},_0=v,_1=i}) end;
  end);
  arr:sort(function(a,b) 
    do return compare(a._0, b._0) end;
  end);
  if (incrementDuplicates) then 
    local usedIndexes = __thx__Set_Set_Impl_.createInt();
    do return __thx_Arrays.reducei(arr, function(acc,x,i) 
      local index = (function() 
        local _hx_1
        if ((i > 0) and (compare(arr[i - 1]._0, x._0) == 0)) then 
        _hx_1 = acc[arr[i - 1]._1]; else 
        _hx_1 = i; end
        return _hx_1
      end )();
      while (usedIndexes.h[index] ~= nil) do _hx_do_first_1 = false;
        
        index = index + 1;
      end;
      __thx__Set_Set_Impl_.add(usedIndexes, index);
      acc[x._1] = index;
      do return acc end;
    end, _hx_tab_array({}, 0)) end;
  else
    do return __thx_Arrays.reducei(arr, function(acc,x,i) 
      acc[x._1] = (function() 
        local _hx_2
        if ((i > 0) and (compare(arr[i - 1]._0, x._0) == 0)) then 
        _hx_2 = acc[arr[i - 1]._1]; else 
        _hx_2 = i; end
        return _hx_2
      end )();
      do return acc end;
    end, _hx_tab_array({}, 0)) end;
  end;
end
__thx_Arrays.reduce = function(array,f,initial) 
  local _g_current = 0;
  local _g_array = array;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local v = _g_array[_g_current - 1];
    initial = f(initial, v);
  end;
  do return initial end;
end
__thx_Arrays.foldLeft = function(array,init,f) 
  do return __thx_Arrays.reduce(array, f, init) end;
end
__thx_Arrays.foldLeft1 = function(array,f) 
  local tail = __thx_Arrays.dropLeft(array, 1);
  local head = array[0];
  if (head == nil) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(__thx_Arrays.reduce(tail, f, head)) end;
  end;
end
__thx_Arrays.foldLeftEither = function(array,init,f) 
  local acc = __thx_Either.Right(init);
  local _g_current = 0;
  local _g_array = array;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local a = _g_array[_g_current - 1];
    local tmp = acc[1];
    if (tmp) == 0 then 
      local error = acc[2];
      do return acc end;
    elseif (tmp) == 1 then 
      local b = acc[2];
      acc = f(b, a); end;
  end;
  do return acc end;
end
__thx_Arrays.foldMap = function(array,f,m) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  local _e = m;
  do return __thx_Arrays.reduce(_g, function(a0,a1) 
    do return __thx__Monoid_Monoid_Impl_.append(_e, a0, a1) end;
  end, __thx__Monoid_Monoid_Impl_.get_zero(m)) end;
end
__thx_Arrays.fold = function(array,m) 
  do return __thx_Arrays.foldMap(array, __thx_Functions.identity, m) end;
end
__thx_Arrays.nel = function(array) 
  do return __thx__Nel_Nel_Impl_.fromArray(array) end;
end
__thx_Arrays.foldS = function(array,s) 
  do return __thx_Options.map(__thx_Arrays.nel(array), function(x) 
    do return __thx__Nel_Nel_Impl_.fold(x, s) end;
  end) end;
end
__thx_Arrays.resize = function(array,length,fill) 
  while (array.length < length) do _hx_do_first_1 = false;
    
    array:push(fill);
  end;
  array:splice(length, array.length - length);
  do return array end;
end
__thx_Arrays.resized = function(array,length,fill) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  array = _g;
  do return __thx_Arrays.resize(array, length, fill) end;
end
__thx_Arrays.reducei = function(array,f,initial) 
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    initial = f(initial, array[i], i);
  end;
  do return initial end;
end
__thx_Arrays.reduceRight = function(array,f,initial) 
  local i = array.length;
  while (true) do _hx_do_first_1 = false;
    
    i = i - 1;
    if (not (i >= 0)) then 
      break;
    end;
    initial = f(initial, array[i]);
  end;
  do return initial end;
end
__thx_Arrays.removeAll = function(array,element,equality) 
  if (nil == equality) then 
    equality = __thx_Functions.equality;
  end;
  local i = array.length;
  while (true) do _hx_do_first_1 = false;
    
    i = i - 1;
    if (not (i >= 0)) then 
      break;
    end;
    if (equality(array[i], element)) then 
      array:splice(i, 1);
    end;
  end;
end
__thx_Arrays.rest = function(array) 
  do return array:slice(1) end;
end
__thx_Arrays.reversed = function(array) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local result = _g;
  result:reverse();
  do return result end;
end
__thx_Arrays.sample = function(array,n) 
  local b = array.length;
  if (n >= b) then 
    n = b;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local copy = _g;
  local result = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = n;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    result:push(copy:splice(Std.random(copy.length), 1)[0]);
  end;
  do return result end;
end
__thx_Arrays.sampleOne = function(array) 
  do return array[Std.random(array.length)] end;
end
__thx_Arrays.string = function(arr) 
  local f = __thx_Dynamics.string;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = arr;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  local strings = _g;
  do return Std.string(Std.string("[") .. Std.string(strings:join(", "))) .. Std.string("]") end;
end
__thx_Arrays.shuffle = function(a) 
  local t = __thx_Ints.range(a.length);
  local array = _hx_tab_array({}, 0);
  while (t.length > 0) do _hx_do_first_1 = false;
    
    local pos = Std.random(t.length);
    local index = t[pos];
    t:splice(pos, 1);
    array:push(a[index]);
  end;
  do return array end;
end
__thx_Arrays.split = function(array,parts) 
  local len = _G.math.ceil(array.length / parts);
  do return __thx_Arrays.splitBy(array, len) end;
end
__thx_Arrays.splitBy = function(array,len) 
  local res = _hx_tab_array({}, 0);
  local b = array.length;
  if (len >= b) then 
    len = b;
  end;
  local _g = 0;
  local _g1 = _G.math.ceil(array.length / len);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local p = _g - 1;
    res:push(array:slice(p * len, (p + 1) * len));
  end;
  do return res end;
end
__thx_Arrays.splitByPad = function(arr,len,pad) 
  local res = __thx_Arrays.splitBy(arr, len);
  while (res[res.length - 1].length < len) do _hx_do_first_1 = false;
    
    res[res.length - 1]:push(pad);
  end;
  do return res end;
end
__thx_Arrays.tail = function(array) 
  do return array:slice(1) end;
end
__thx_Arrays.take = function(arr,n) 
  do return arr:slice(0, n) end;
end
__thx_Arrays.takeLast = function(arr,n) 
  do return arr:slice(arr.length - n) end;
end
__thx_Arrays.traverseOption = function(arr,f) 
  do return __thx_Arrays.reduce(arr, function(acc,t) 
    do return __thx_Options.ap(f(t), __thx_Options.map(acc, function(ux) 
      do return function(u) 
        ux:push(u);
        do return ux end;
      end end;
    end)) end;
  end, __haxe_ds_Option.Some(_hx_tab_array({}, 0))) end;
end
__thx_Arrays.traverseEither = function(arr,f) 
  do return __thx_Arrays.reduce(arr, function(acc,t) 
    do return __thx_Eithers.ap(f(t), __thx_Eithers.map(acc, function(ux) 
      do return function(u) 
        ux:push(u);
        do return ux end;
      end end;
    end)) end;
  end, __thx_Either.Right(_hx_tab_array({}, 0))) end;
end
__thx_Arrays.traverseValidation = function(arr,f,s) 
  do return __thx_Arrays.reduce(arr, function(acc,t) 
    do return __thx__Validation_Validation_Impl_.ap(f(t), __thx__Validation_Validation_Impl_.map(acc, function(ux) 
      do return function(u) 
        ux:push(u);
        do return ux end;
      end end;
    end), s) end;
  end, __thx_Either.Right(_hx_tab_array({}, 0))) end;
end
__thx_Arrays.traverseValidationIndexed = function(arr,f,s) 
  do return __thx_Arrays.reducei(arr, function(acc,t,i) 
    do return __thx__Validation_Validation_Impl_.ap(f(t, i), __thx__Validation_Validation_Impl_.map(acc, function(ux) 
      do return function(u) 
        ux:push(u);
        do return ux end;
      end end;
    end), s) end;
  end, __thx_Either.Right(_hx_tab_array({}, 0))) end;
end
__thx_Arrays.rotate = function(arr) 
  local result = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = arr[0].length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local row = _hx_tab_array({}, 0);
    result:push(row);
    local _g = 0;
    local _g1 = arr.length;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local j = _g - 1;
      row:push(arr[j][i]);
    end;
  end;
  do return result end;
end
__thx_Arrays.sliding2 = function(arr,f) 
  if (arr.length < 2) then 
    do return _hx_tab_array({}, 0) end;
  else
    local result = _hx_tab_array({}, 0);
    local _g = 0;
    local _g1 = arr.length - 1;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      result:push(f(arr[i], arr[i + 1]));
    end;
    do return result end;
  end;
end
__thx_Arrays.unzip = function(array) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    a1:push(i._0);
    a2:push(i._1);
    local tmp = nil;
    _g:push(tmp);
  end;
  do return _hx_o({__fields__={_0=true,_1=true},_0=a1,_1=a2}) end;
end
__thx_Arrays.unzip3 = function(array) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local a3 = _hx_tab_array({}, 0);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    a1:push(i._0);
    a2:push(i._1);
    a3:push(i._2);
    local tmp = nil;
    _g:push(tmp);
  end;
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=a1,_1=a2,_2=a3}) end;
end
__thx_Arrays.unzip4 = function(array) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local a3 = _hx_tab_array({}, 0);
  local a4 = _hx_tab_array({}, 0);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    a1:push(i._0);
    a2:push(i._1);
    a3:push(i._2);
    a4:push(i._3);
    local tmp = nil;
    _g:push(tmp);
  end;
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=a1,_1=a2,_2=a3,_3=a4}) end;
end
__thx_Arrays.unzip5 = function(array) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local a3 = _hx_tab_array({}, 0);
  local a4 = _hx_tab_array({}, 0);
  local a5 = _hx_tab_array({}, 0);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    a1:push(i._0);
    a2:push(i._1);
    a3:push(i._2);
    a4:push(i._3);
    a5:push(i._4);
    local tmp = nil;
    _g:push(tmp);
  end;
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=a1,_1=a2,_2=a3,_3=a4,_4=a5}) end;
end
__thx_Arrays.zip = function(array1,array2) 
  local a = array1.length;
  local b = array2.length;
  local length = (function() 
    local _hx_1
    if (a < b) then 
    _hx_1 = a; else 
    _hx_1 = b; end
    return _hx_1
  end )();
  local array = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    array:push(_hx_o({__fields__={_0=true,_1=true},_0=array1[i],_1=array2[i]}));
  end;
  do return array end;
end
__thx_Arrays.zip3 = function(array1,array2,array3) 
  local length = __thx_ArrayInts.min(_hx_tab_array({[0]=array1.length, array2.length, array3.length}, 3));
  local array = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    array:push(_hx_o({__fields__={_0=true,_1=true,_2=true},_0=array1[i],_1=array2[i],_2=array3[i]}));
  end;
  do return array end;
end
__thx_Arrays.zip4 = function(array1,array2,array3,array4) 
  local length = __thx_ArrayInts.min(_hx_tab_array({[0]=array1.length, array2.length, array3.length, array4.length}, 4));
  local array = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    array:push(_hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=array1[i],_1=array2[i],_2=array3[i],_3=array4[i]}));
  end;
  do return array end;
end
__thx_Arrays.zip5 = function(array1,array2,array3,array4,array5) 
  local length = __thx_ArrayInts.min(_hx_tab_array({[0]=array1.length, array2.length, array3.length, array4.length, array5.length}, 5));
  local array = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    array:push(_hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=array1[i],_1=array2[i],_2=array3[i],_3=array4[i],_4=array5[i]}));
  end;
  do return array end;
end
__thx_Arrays.zipAp = function(ax,fx) 
  local result = _hx_tab_array({}, 0);
  local _g = 0;
  local a = ax.length;
  local b = fx.length;
  local _g1 = (function() 
    local _hx_1
    if (a < b) then 
    _hx_1 = a; else 
    _hx_1 = b; end
    return _hx_1
  end )();
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    result:push(fx[i](ax[i]));
  end;
  do return result end;
end
__thx_Arrays.zip2Ap = function(f,ax,bx) 
  local f = __thx_Functions2.curry(f);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = ax;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return __thx_Arrays.zipAp(bx, _g) end;
end
__thx_Arrays.zip3Ap = function(f,ax,bx,cx) 
  local f = f;
  do return __thx_Arrays.zipAp(cx, __thx_Arrays.zip2Ap(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end, ax, bx)) end;
end
__thx_Arrays.zip4Ap = function(f,ax,bx,cx,dx) 
  local f = f;
  do return __thx_Arrays.zipAp(dx, __thx_Arrays.zip3Ap(function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end, ax, bx, cx)) end;
end
__thx_Arrays.zip5Ap = function(f,ax,bx,cx,dx,ex) 
  local f = f;
  do return __thx_Arrays.zipAp(ex, __thx_Arrays.zip4Ap(function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end, ax, bx, cx, dx)) end;
end
__thx_Arrays.withPrepend = function(arr,el) 
  do return _hx_tab_array({[0]=el}, 1):concat(arr) end;
end
__thx_Arrays.with = function(arr,el) 
  do return arr:concat(_hx_tab_array({[0]=el}, 1)) end;
end
__thx_Arrays.withSlice = function(arr,other,start,length) 
  if (length == nil) then 
    length = 0;
  end;
  do return arr:slice(0, start):concat(other):concat(arr:slice(start + length)) end;
end
__thx_Arrays.withInsert = function(arr,el,pos) 
  do return arr:slice(0, pos):concat(_hx_tab_array({[0]=el}, 1)):concat(arr:slice(pos)) end;
end
__thx_Arrays.maxBy = function(arr,ord) 
  if (arr.length == 0) then 
    do return __haxe_ds_Option.None end;
  else
    local _e = ord;
    do return __haxe_ds_Option.Some(__thx_Arrays.reduce(arr, function(a0,a1) 
      do return __thx__Ord_Ord_Impl_.max(_e, a0, a1) end;
    end, arr[0])) end;
  end;
end
__thx_Arrays.minBy = function(arr,ord) 
  if (arr.length == 0) then 
    do return __haxe_ds_Option.None end;
  else
    local _e = ord;
    do return __haxe_ds_Option.Some(__thx_Arrays.reduce(arr, function(a0,a1) 
      do return __thx__Ord_Ord_Impl_.min(_e, a0, a1) end;
    end, arr[0])) end;
  end;
end
__thx_Arrays.toMap = function(arr,keyOrder) 
  local m = __thx_fp_MapImpl.Tip;
  local collisions = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = arr.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local tuple = arr[i];
    if (__thx_Options.isNone(__thx_fp__Map_Map_Impl_.lookup(m, tuple._0, keyOrder))) then 
      m = __thx_fp__Map_Map_Impl_.insert(m, tuple._0, tuple._1, keyOrder);
    else
      collisions:push(tuple._0);
    end;
  end;
  do return __thx_Options.toFailure(__thx__Nel_Nel_Impl_.fromArray(collisions), m) end;
end
__thx_Arrays.toStringMap = function(arr) 
  do return __thx_Arrays.reduce(arr, function(acc,t) 
    local key = t._0;
    local value = t._1;
    if (value == nil) then 
      acc.h[key] = __haxe_ds_StringMap.tnull;
    else
      acc.h[key] = value;
    end;
    do return acc end;
  end, __haxe_ds_StringMap.new()) end;
end
__thx_Arrays.partition = function(arr,f) 
  do return __thx_Arrays.reduce(arr, function(a,b) 
    if (f(b)) then 
      a._0:push(b);
    else
      a._1:push(b);
    end;
    do return a end;
  end, _hx_o({__fields__={_0=true,_1=true},_0=_hx_tab_array({}, 0),_1=_hx_tab_array({}, 0)})) end;
end
__thx_Arrays.partitionWhile = function(arr,f) 
  local partitioning = true;
  do return __thx_Arrays.reduce(arr, function(a,b) 
    if (partitioning) then 
      if (f(b)) then 
        a._0:push(b);
      else
        partitioning = false;
        a._1:push(b);
      end;
    else
      a._1:push(b);
    end;
    do return a end;
  end, _hx_o({__fields__={_0=true,_1=true},_0=_hx_tab_array({}, 0),_1=_hx_tab_array({}, 0)})) end;
end
__thx_Arrays.dropLeft = function(a,n) 
  if (n >= a.length) then 
    do return _hx_tab_array({}, 0) end;
  else
    do return a:slice(n) end;
  end;
end
__thx_Arrays.dropRight = function(a,n) 
  if (n >= a.length) then 
    do return _hx_tab_array({}, 0) end;
  else
    do return a:slice(0, a.length - n) end;
  end;
end
__thx_Arrays.dropWhile = function(a,p) 
  local r = _hx_tab_array({}, 0):concat(a);
  local _g_current = 0;
  local _g_array = a;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local e = _g_array[_g_current - 1];
    if (p(e)) then 
      r:shift();
    else
      break;
    end;
  end;
  do return r end;
end
__thx_Arrays.pad = function(arr,len,def) 
  local len0 = len - arr.length;
  local arr0 = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = len0;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    arr0:push(def);
  end;
  do return arr:concat(arr0) end;
end
__thx_Arrays.fill = function(arr,def) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = arr;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push((function() 
      local _hx_1
      if (i == nil) then 
      _hx_1 = def; else 
      _hx_1 = i; end
      return _hx_1
    end )());
  end;
  do return _g end;
end

__thx_ArrayFloats.new = {}
__thx_ArrayFloats.__name__ = "thx.ArrayFloats"
__thx_ArrayFloats.average = function(arr) 
  do return __thx_ArrayFloats.sum(arr) / arr.length end;
end
__thx_ArrayFloats.compact = function(arr) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = arr;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if ((nil ~= i) and Math.isFinite(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end;
end
__thx_ArrayFloats.max = function(arr) 
  do return __thx_Options.get(__thx_Arrays.maxBy(arr, __thx_Floats.order)) end;
end
__thx_ArrayFloats.min = function(arr) 
  do return __thx_Options.get(__thx_Arrays.minBy(arr, __thx_Floats.order)) end;
end
__thx_ArrayFloats.resize = function(array,length,fill) 
  if (fill == nil) then 
    fill = 0.0;
  end;
  while (array.length < length) do _hx_do_first_1 = false;
    
    array:push(fill);
  end;
  array:splice(length, array.length - length);
  do return array end;
end
__thx_ArrayFloats.resized = function(array,length,fill) 
  if (fill == nil) then 
    fill = 0.0;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  array = _g;
  do return __thx_ArrayFloats.resize(array, length, fill) end;
end
__thx_ArrayFloats.standardDeviation = function(array) 
  if (array.length < 2) then 
    do return 0.0 end;
  end;
  local mean = __thx_ArrayFloats.average(array);
  local variance = __thx_Arrays.reduce(array, function(acc,val) 
    do return acc + _G.math.pow(val - mean, 2) end;
  end, 0) / (array.length - 1);
  do return _G.math.sqrt(variance) end;
end
__thx_ArrayFloats.sum = function(arr) 
  do return __thx_Arrays.reduce(arr, function(tot,v) 
    do return tot + v end;
  end, 0.0) end;
end

__thx_ArrayInts.new = {}
__thx_ArrayInts.__name__ = "thx.ArrayInts"
__thx_ArrayInts.average = function(arr) 
  do return __thx_ArrayInts.sum(arr) / arr.length end;
end
__thx_ArrayInts.max = function(arr) 
  do return __thx_Options.get(__thx_Arrays.maxBy(arr, __thx_Ints.order)) end;
end
__thx_ArrayInts.min = function(arr) 
  do return __thx_Options.get(__thx_Arrays.minBy(arr, __thx_Ints.order)) end;
end
__thx_ArrayInts.resize = function(array,length,fill) 
  if (fill == nil) then 
    fill = 0;
  end;
  while (array.length < length) do _hx_do_first_1 = false;
    
    array:push(fill);
  end;
  array:splice(length, array.length - length);
  do return array end;
end
__thx_ArrayInts.resized = function(array,length,fill) 
  if (fill == nil) then 
    fill = 0;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = array;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  array = _g;
  do return __thx_ArrayInts.resize(array, length, fill) end;
end
__thx_ArrayInts.sum = function(arr) 
  do return __thx_Arrays.reduce(arr, function(tot,v) 
    do return tot + v end;
  end, 0) end;
end

__thx_ArrayStrings.new = {}
__thx_ArrayStrings.__name__ = "thx.ArrayStrings"
__thx_ArrayStrings.compact = function(arr) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = arr;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (not __thx_Strings.isEmpty(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end;
end
__thx_ArrayStrings.max = function(arr) 
  do return __thx_Options.getOrElse(__thx_Arrays.maxBy(arr, __thx_Strings.order), nil) end;
end
__thx_ArrayStrings.min = function(arr) 
  do return __thx_Options.getOrElse(__thx_Arrays.minBy(arr, __thx_Strings.order), nil) end;
end

__thx__BitSet_BitSet_Impl_.new = {}
__thx__BitSet_BitSet_Impl_.__name__ = "thx._BitSet.BitSet_Impl_"
__thx__BitSet_BitSet_Impl_._new = function(length) 
  local this1 = _hx_tab_array({[0]=length}, 1);
  local size = Std.int(length / 32) + 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  do return this1 end;
end
__thx__BitSet_BitSet_Impl_.empty = function(length) 
  if (length == nil) then 
    length = 0;
  end;
  local this1 = _hx_tab_array({[0]=length}, 1);
  local size = Std.int(length / 32) + 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  do return this1 end;
end
__thx__BitSet_BitSet_Impl_.fromBools = function(values) 
  local this1 = _hx_tab_array({[0]=0}, 1);
  local size = 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  do return __thx_Arrays.reducei(values, function(acc,value,i) 
    __thx__BitSet_BitSet_Impl_.setAt(acc, i, value);
    do return acc end;
  end, this1) end;
end
__thx__BitSet_BitSet_Impl_.fromString = function(str) 
  local chars = String.prototype.split(str, "");
  local this1 = _hx_tab_array({[0]=0}, 1);
  local size = 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  do return __thx_Arrays.reducei(chars, function(acc,char,i) 
    __thx__BitSet_BitSet_Impl_.setAt(acc, i, char == "1");
    do return acc end;
  end, this1) end;
end
__thx__BitSet_BitSet_Impl_.toBools = function(this1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Ints.range(__thx__BitSet_BitSet_Impl_.get_length(this1));
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__thx__BitSet_BitSet_Impl_.at(this1, i));
  end;
  do return _g end;
end
__thx__BitSet_BitSet_Impl_.toInt32s = function(this1) 
  local parts = this1:slice(1);
  do return parts end;
end
__thx__BitSet_BitSet_Impl_.at = function(this1,index) 
  if ((index < 0) or (index >= __thx__BitSet_BitSet_Impl_.get_length(this1))) then 
    _G.error(__haxe_Exception.thrown(__thx_Error.new(Std.string(Std.string("BitSet: index ") .. Std.string(index)) .. Std.string(" out of bounds"), nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/BitSet.hx",lineNumber=88,className="thx._BitSet.BitSet_Impl_",methodName="at"}))),0);
  end;
  local blockIndex = _G.math.floor(index / 32) + 1;
  local block = this1[blockIndex];
  local bitIndex = _G.math.fmod(index, 32);
  do return (_hx_bit.band(block,_hx_bit.lshift(1,bitIndex))) ~= 0 end;
end
__thx__BitSet_BitSet_Impl_.setAt = function(this1,index,value) 
  local blockIndex = _G.math.floor(index / 32) + 1;
  if (blockIndex >= this1.length) then 
    __thx_Arrays.resize(this1, blockIndex + 1, 0);
  end;
  if (this1[0] <= index) then 
    this1[0] = index + 1;
  end;
  local bitIndex = _G.math.fmod(index, 32);
  if (value) then 
    this1[blockIndex] = __haxe__Int32_Int32_Impl_["or"](this1[blockIndex], __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(1,bitIndex)));
  else
    local this1 = this1;
    local blockIndex = blockIndex;
    local this2 = this1[blockIndex];
    local a = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(1,bitIndex));
    this1[blockIndex] = _hx_bit.band(this2,_hx_bit_clamp(_hx_bit.bnot(a)));
  end;
  do return value end;
end
__thx__BitSet_BitSet_Impl_.clone = function(this1) 
  local tmp = __thx_Ints.range(__thx__BitSet_BitSet_Impl_.get_length(this1));
  local this2 = _hx_tab_array({[0]=0}, 1);
  local size = 1;
  __thx_Arrays.resize(this2, size + 1, 0);
  do return __thx_Arrays.reduce(tmp, function(acc,i) 
    __thx__BitSet_BitSet_Impl_.setAt(acc, i, __thx__BitSet_BitSet_Impl_.at(this1, i));
    do return acc end;
  end, this2) end;
end
__thx__BitSet_BitSet_Impl_.setAll = function(this1,value) 
  if (value == nil) then 
    value = true;
  end;
  local _g = 0;
  local _g1 = __thx__BitSet_BitSet_Impl_.get_length(this1);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(this1, i, value);
  end;
  do return this1 end;
end
__thx__BitSet_BitSet_Impl_.clearAll = function(this1) 
  local value = false;
  if (value == nil) then 
    value = true;
  end;
  local _g = 0;
  local _g1 = __thx__BitSet_BitSet_Impl_.get_length(this1);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(this1, i, value);
  end;
  do return this1 end;
end
__thx__BitSet_BitSet_Impl_.concat = function(this1,right) 
  local left = this1;
  local length = __thx__BitSet_BitSet_Impl_.get_length(left) + __thx__BitSet_BitSet_Impl_.get_length(right);
  if (length == nil) then 
    length = 0;
  end;
  local this1 = _hx_tab_array({[0]=length}, 1);
  local size = Std.int(length / 32) + 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  local result = this1;
  local index = 0;
  local _g = 0;
  local _g1 = __thx__BitSet_BitSet_Impl_.get_length(left);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local leftIndex = _g - 1;
    index = index + 1;
    __thx__BitSet_BitSet_Impl_.setAt(result, index - 1, __thx__BitSet_BitSet_Impl_.at(left, leftIndex));
  end;
  local _g = 0;
  local _g1 = __thx__BitSet_BitSet_Impl_.get_length(right);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local rightIndex = _g - 1;
    index = index + 1;
    __thx__BitSet_BitSet_Impl_.setAt(result, index - 1, __thx__BitSet_BitSet_Impl_.at(right, rightIndex));
  end;
  do return result end;
end
__thx__BitSet_BitSet_Impl_.expand = function(this1,count) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Ints.range(__thx__BitSet_BitSet_Impl_.get_length(this1));
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__thx_Arrays.create(count + 1, __thx__BitSet_BitSet_Impl_.at(this1, i)));
  end;
  local values = __thx_Arrays.flatten(_g);
  local this1 = _hx_tab_array({[0]=0}, 1);
  local size = 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  do return __thx_Arrays.reducei(values, function(acc,value,i) 
    __thx__BitSet_BitSet_Impl_.setAt(acc, i, value);
    do return acc end;
  end, this1) end;
end
__thx__BitSet_BitSet_Impl_.toString = function(this1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Ints.range(__thx__BitSet_BitSet_Impl_.get_length(this1));
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push((function() 
      local _hx_1
      if (__thx__BitSet_BitSet_Impl_.at(this1, i)) then 
      _hx_1 = "1"; else 
      _hx_1 = "0"; end
      return _hx_1
    end )());
  end;
  do return _g:join("") end;
end
__thx__BitSet_BitSet_Impl_["and"] = function(this1,right) 
  do return __thx__BitSet_BitSet_Impl_.combine(this1, right, function(l,r) 
    if (l) then 
      do return r end;
    else
      do return false end;
    end;
  end) end;
end
__thx__BitSet_BitSet_Impl_["or"] = function(this1,right) 
  do return __thx__BitSet_BitSet_Impl_.combine(this1, right, function(l,r) 
    if (not l) then 
      do return r end;
    else
      do return true end;
    end;
  end) end;
end
__thx__BitSet_BitSet_Impl_.xor = function(this1,right) 
  do return __thx__BitSet_BitSet_Impl_.combine(this1, right, function(l,r) 
    if (not (l and not r)) then 
      if (not l) then 
        do return r end;
      else
        do return false end;
      end;
    else
      do return true end;
    end;
  end) end;
end
__thx__BitSet_BitSet_Impl_.negate = function(this1) 
  local tmp = __thx_Ints.range(__thx__BitSet_BitSet_Impl_.get_length(this1));
  local this2 = _hx_tab_array({[0]=0}, 1);
  local size = 1;
  __thx_Arrays.resize(this2, size + 1, 0);
  do return __thx_Arrays.reduce(tmp, function(acc,i) 
    __thx__BitSet_BitSet_Impl_.setAt(acc, i, not __thx__BitSet_BitSet_Impl_.at(this1, i));
    do return acc end;
  end, this2) end;
end
__thx__BitSet_BitSet_Impl_.equals = function(this1,other) 
  if (__thx__BitSet_BitSet_Impl_.get_length(this1) ~= __thx__BitSet_BitSet_Impl_.get_length(other)) then 
    do return false end;
  end;
  local _g = 0;
  local _g1 = __thx__BitSet_BitSet_Impl_.get_length(this1);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (__thx__BitSet_BitSet_Impl_.at(this1, i) ~= __thx__BitSet_BitSet_Impl_.at(other, i)) then 
      do return false end;
    end;
  end;
  do return true end;
end
__thx__BitSet_BitSet_Impl_.notEquals = function(this1,other) 
  do return not __thx__BitSet_BitSet_Impl_.equals(this1, other) end;
end
__thx__BitSet_BitSet_Impl_.combine = function(this1,right,combiner) 
  local left = this1;
  local a = __thx__BitSet_BitSet_Impl_.get_length(left);
  local b = __thx__BitSet_BitSet_Impl_.get_length(right);
  local length = (function() 
    local _hx_1
    if (a > b) then 
    _hx_1 = a; else 
    _hx_1 = b; end
    return _hx_1
  end )();
  local tmp = __thx_Ints.range(length);
  local this1 = _hx_tab_array({[0]=0}, 1);
  local size = 1;
  __thx_Arrays.resize(this1, size + 1, 0);
  do return __thx_Arrays.reduce(tmp, function(acc,i) 
    local leftBit = __thx__BitSet_BitSet_Impl_.at(left, i);
    local rightBit = __thx__BitSet_BitSet_Impl_.at(right, i);
    __thx__BitSet_BitSet_Impl_.setAt(acc, i, combiner(leftBit, rightBit));
    do return acc end;
  end, this1) end;
end
__thx__BitSet_BitSet_Impl_.get_length = function(this1) 
  do return this1[0] end;
end

__thx_Bools.new = {}
__thx_Bools.__name__ = "thx.Bools"
__thx_Bools.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a) then 
      do return -1 end;
    else
      do return 1 end;
    end;
  end;
end
__thx_Bools.toInt = function(v) 
  if (v) then 
    do return 1 end;
  else
    do return 0 end;
  end;
end
__thx_Bools.canParse = function(v) 
  local _g = __lua_lib_luautf8_Utf8.lower(v);
  if (_g == nil) then 
    do return true end;
  else
    local _g = _g;
    if (_g) == "0" or (_g) == "1" or (_g) == "false" or (_g) == "off" or (_g) == "on" or (_g) == "true" then 
      do return true end;else
    do return false end; end;
  end;
end
__thx_Bools.parse = function(v) 
  local _g = __lua_lib_luautf8_Utf8.lower(v);
  if (_g == nil) then 
    do return false end;
  else
    local _g1 = _g;
    if (_g1) == "0" or (_g1) == "false" or (_g1) == "off" then 
      do return false end;
    elseif (_g1) == "1" or (_g1) == "on" or (_g1) == "true" then 
      do return true end;else
    local v = _g;
    _G.error(__haxe_Exception.thrown(Std.string(Std.string("unable to parse \"") .. Std.string(v)) .. Std.string("\"")),0); end;
  end;
end
__thx_Bools.xor = function(a,b) 
  do return a ~= b end;
end
__thx_Bools.option = function(cond,a) 
  if (cond) then 
    do return __haxe_ds_Option.Some(a) end;
  else
    do return __haxe_ds_Option.None end;
  end;
end

__thx__Ord_Ord_Impl_.new = {}
__thx__Ord_Ord_Impl_.__name__ = "thx._Ord.Ord_Impl_"
__thx__Ord_Ord_Impl_.order = function(this1,a0,a1) 
  do return this1(a0, a1) end;
end
__thx__Ord_Ord_Impl_.max = function(this1,a0,a1) 
  local tmp = this1(a0, a1)[1];
  if (tmp) == 1 then 
    do return a0 end;
  elseif (tmp) == 0 or (tmp) == 2 then 
    do return a1 end; end;
end
__thx__Ord_Ord_Impl_.min = function(this1,a0,a1) 
  local tmp = this1(a0, a1)[1];
  if (tmp) == 1 then 
    do return a1 end;
  elseif (tmp) == 0 or (tmp) == 2 then 
    do return a0 end; end;
end
__thx__Ord_Ord_Impl_.equal = function(this1,a0,a1) 
  do return this1(a0, a1) == __thx_OrderingImpl.EQ end;
end
__thx__Ord_Ord_Impl_.contramap = function(this1,f) 
  do return function(b0,b1) 
    do return this1(f(b0), f(b1)) end;
  end end;
end
__thx__Ord_Ord_Impl_.inverse = function(this1) 
  do return function(a0,a1) 
    do return this1(a1, a0) end;
  end end;
end
__thx__Ord_Ord_Impl_.intComparison = function(this1,a0,a1) 
  local tmp = this1(a0, a1)[1];
  if (tmp) == 0 then 
    do return -1 end;
  elseif (tmp) == 1 then 
    do return 1 end;
  elseif (tmp) == 2 then 
    do return 0 end; end;
end
__thx__Ord_Ord_Impl_.fromIntComparison = function(f) 
  do return function(a,b) 
    do return __thx__Ord_Ordering_Impl_.fromInt(f(a, b)) end;
  end end;
end
__thx__Ord_Ord_Impl_.forComparable = function() 
  do return function(a,b) 
    do return __thx__Ord_Ordering_Impl_.fromInt(a:compareTo(b)) end;
  end end;
end
__thx__Ord_Ord_Impl_.forComparableOrd = function() 
  do return function(a,b) 
    do return a:compareTo(b) end;
  end end;
end

__thx__Ord_Ordering_Impl_.new = {}
__thx__Ord_Ordering_Impl_.__name__ = "thx._Ord.Ordering_Impl_"
__thx__Ord_Ordering_Impl_.fromInt = function(value) 
  if (value < 0) then 
    do return __thx_OrderingImpl.LT end;
  else
    if (value > 0) then 
      do return __thx_OrderingImpl.GT end;
    else
      do return __thx_OrderingImpl.EQ end;
    end;
  end;
end
__thx__Ord_Ordering_Impl_.fromFloat = function(value) 
  if (value < 0) then 
    do return __thx_OrderingImpl.LT end;
  else
    if (value > 0) then 
      do return __thx_OrderingImpl.GT end;
    else
      do return __thx_OrderingImpl.EQ end;
    end;
  end;
end
__thx__Ord_Ordering_Impl_.toInt = function(this1) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return -1 end;
  elseif (tmp) == 1 then 
    do return 1 end;
  elseif (tmp) == 2 then 
    do return 0 end; end;
end
_hxClasses["thx.OrderingImpl"] = { __ename__ = "thx.OrderingImpl", __constructs__ = _hx_tab_array({[0]="LT","GT","EQ"},3)}
__thx_OrderingImpl = _hxClasses["thx.OrderingImpl"];
__thx_OrderingImpl.LT = _hx_tab_array({[0]="LT",0,__enum__ = __thx_OrderingImpl},2)

__thx_OrderingImpl.GT = _hx_tab_array({[0]="GT",1,__enum__ = __thx_OrderingImpl},2)

__thx_OrderingImpl.EQ = _hx_tab_array({[0]="EQ",2,__enum__ = __thx_OrderingImpl},2)


__thx_Dates.new = {}
__thx_Dates.__name__ = "thx.Dates"
__thx_Dates.compare = function(a,b) 
  local a = a:getTime();
  local b = b:getTime();
  if (a < b) then 
    do return -1 end;
  else
    if (a > b) then 
      do return 1 end;
    else
      do return 0 end;
    end;
  end;
end
__thx_Dates.create = function(year,month,day,hour,minute,second) 
  if (second == nil) then 
    second = 0;
  end;
  if (minute == nil) then 
    minute = 0;
  end;
  if (hour == nil) then 
    hour = 0;
  end;
  if (day == nil) then 
    day = 1;
  end;
  if (month == nil) then 
    month = 0;
  end;
  minute = minute + _G.math.floor(second / 60);
  second = _G.math.fmod(second, 60);
  if (second < 0) then 
    second = second + 60;
  end;
  hour = hour + _G.math.floor(minute / 60);
  minute = _G.math.fmod(minute, 60);
  if (minute < 0) then 
    minute = minute + 60;
  end;
  day = day + _G.math.floor(hour / 24);
  hour = _G.math.fmod(hour, 24);
  if (hour < 0) then 
    hour = hour + 24;
  end;
  if (day == 0) then 
    month = month - 1;
    if (month < 0) then 
      month = 11;
      year = year - 1;
    end;
    day = __thx_Dates.daysInMonth(year, month);
  end;
  year = year + _G.math.floor(month / 12);
  month = _G.math.fmod(month, 12);
  if (month < 0) then 
    month = month + 12;
  end;
  local days = __thx_Dates.daysInMonth(year, month);
  while (day > days) do _hx_do_first_1 = false;
    
    if (day > days) then 
      day = day - days;
      month = month + 1;
    end;
    if (month > 11) then 
      month = month - 12;
      year = year + 1;
    end;
    days = __thx_Dates.daysInMonth(year, month);
  end;
  do return Date.new(year, month, day, hour, minute, second) end;
end
__thx_Dates.daysRange = function(start,_end) 
  if (__thx_Dates.compare(_end, start) < 0) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local days = _hx_tab_array({}, 0);
  while (not __thx_Dates.sameDay(start, _end)) do _hx_do_first_1 = false;
    
    days:push(start);
    start = __thx_Dates.jump(start, __thx_TimePeriod.Day, 1);
  end;
  days:push(_end);
  do return days end;
end
__thx_Dates.equals = function(_self,other) 
  do return _self:getTime() == other:getTime() end;
end
__thx_Dates.nearEquals = function(_self,other,units,period) 
  if (units == nil) then 
    units = 1;
  end;
  if (nil == period) then 
    period = __thx_TimePeriod.Second;
  end;
  if (units < 0) then 
    units = -units;
  end;
  local min = __thx_Dates.jump(_self, period, -units);
  local max = __thx_Dates.jump(_self, period, units);
  if (__thx_Dates.compare(min, other) <= 0) then 
    do return __thx_Dates.compare(max, other) >= 0 end;
  else
    do return false end;
  end;
end
__thx_Dates.greater = function(_self,other) 
  do return __thx_Dates.compare(_self, other) > 0 end;
end
__thx_Dates.more = function(_self,other) 
  do return __thx_Dates.compare(_self, other) > 0 end;
end
__thx_Dates.less = function(_self,other) 
  do return __thx_Dates.compare(_self, other) < 0 end;
end
__thx_Dates.greaterEquals = function(_self,other) 
  do return __thx_Dates.compare(_self, other) >= 0 end;
end
__thx_Dates.moreEqual = function(_self,other) 
  do return __thx_Dates.compare(_self, other) >= 0 end;
end
__thx_Dates.lessEquals = function(_self,other) 
  do return __thx_Dates.compare(_self, other) <= 0 end;
end
__thx_Dates.lessEqual = function(_self,other) 
  do return __thx_Dates.compare(_self, other) <= 0 end;
end
__thx_Dates.isLeapYear = function(year) 
  if ((_G.math.fmod(year, 4)) ~= 0) then 
    do return false end;
  end;
  if ((_G.math.fmod(year, 100)) == 0) then 
    do return (_G.math.fmod(year, 400)) == 0 end;
  end;
  do return true end;
end
__thx_Dates.isInLeapYear = function(d) 
  do return __thx_Dates.isLeapYear(d:getFullYear()) end;
end
__thx_Dates.daysInMonth = function(year,month) 
  local month1 = month;
  if (month1) == 1 then 
    if (__thx_Dates.isLeapYear(year)) then 
      do return 29 end;
    else
      do return 28 end;
    end;
  elseif (month1) == 3 or (month1) == 5 or (month1) == 8 or (month1) == 10 then 
    do return 30 end;
  elseif (month1) == 0 or (month1) == 2 or (month1) == 4 or (month1) == 6 or (month1) == 7 or (month1) == 9 or (month1) == 11 then 
    do return 31 end;else
  _G.error(__haxe_Exception.thrown(Std.string(Std.string("Invalid month \"") .. Std.string(month)) .. Std.string("\".  Month should be a number, Jan=0, Dec=11")),0); end;
end
__thx_Dates.numDaysInMonth = function(month,year) 
  do return __thx_Dates.daysInMonth(year, month) end;
end
__thx_Dates.daysInThisMonth = function(d) 
  do return __thx_Dates.daysInMonth(d:getFullYear(), d:getMonth()) end;
end
__thx_Dates.numDaysInThisMonth = function(d) 
  do return __thx_Dates.daysInThisMonth(d) end;
end
__thx_Dates.sameYear = function(_self,other) 
  do return _self:getFullYear() == other:getFullYear() end;
end
__thx_Dates.sameMonth = function(_self,other) 
  if (__thx_Dates.sameYear(_self, other)) then 
    do return _self:getMonth() == other:getMonth() end;
  else
    do return false end;
  end;
end
__thx_Dates.sameDay = function(_self,other) 
  if (__thx_Dates.sameMonth(_self, other)) then 
    do return _self:getDate() == other:getDate() end;
  else
    do return false end;
  end;
end
__thx_Dates.sameHour = function(_self,other) 
  if (__thx_Dates.sameDay(_self, other)) then 
    do return _self:getHours() == other:getHours() end;
  else
    do return false end;
  end;
end
__thx_Dates.sameMinute = function(_self,other) 
  if (__thx_Dates.sameHour(_self, other)) then 
    do return _self:getMinutes() == other:getMinutes() end;
  else
    do return false end;
  end;
end
__thx_Dates.snapNext = function(date,period) 
  local this1 = __thx__Timestamp_Timestamp_Impl_.snapNext(date:getTime(), period);
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = this1 / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d end;
end
__thx_Dates.snapPrev = function(date,period) 
  local this1 = __thx__Timestamp_Timestamp_Impl_.snapPrev(date:getTime(), period);
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = this1 / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d end;
end
__thx_Dates.snapTo = function(date,period) 
  local this1 = __thx__Timestamp_Timestamp_Impl_.snapTo(date:getTime(), period);
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = this1 / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d end;
end
__thx_Dates.jump = function(date,period,amount) 
  local sec = date:getSeconds();
  local min = date:getMinutes();
  local hour = date:getHours();
  local day = date:getDate();
  local month = date:getMonth();
  local year = date:getFullYear();
  local tmp = period[1];
  if (tmp) == 0 then 
    sec = sec + amount;
  elseif (tmp) == 1 then 
    min = min + amount;
  elseif (tmp) == 2 then 
    hour = hour + amount;
  elseif (tmp) == 3 then 
    day = day + amount;
  elseif (tmp) == 4 then 
    day = day + (amount * 7);
  elseif (tmp) == 5 then 
    month = month + amount;
  elseif (tmp) == 6 then 
    year = year + amount; end;
  do return __thx_Dates.create(year, month, day, hour, min, sec) end;
end
__thx_Dates.max = function(_self,other) 
  if (_self:getTime() > other:getTime()) then 
    do return _self end;
  else
    do return other end;
  end;
end
__thx_Dates.min = function(_self,other) 
  if (_self:getTime() < other:getTime()) then 
    do return _self end;
  else
    do return other end;
  end;
end
__thx_Dates.snapToWeekDay = function(date,day,firstDayOfWk) 
  if (firstDayOfWk == nil) then 
    firstDayOfWk = 0;
  end;
  local d = date:getDay();
  local s = day;
  if (s < firstDayOfWk) then 
    s = s + 7;
  end;
  if (d < firstDayOfWk) then 
    d = d + 7;
  end;
  do return __thx_Dates.jump(date, __thx_TimePeriod.Day, s - d) end;
end
__thx_Dates.snapNextWeekDay = function(date,day) 
  local d = date:getDay();
  local s = day;
  if (s < d) then 
    s = s + 7;
  end;
  do return __thx_Dates.jump(date, __thx_TimePeriod.Day, s - d) end;
end
__thx_Dates.snapPrevWeekDay = function(date,day) 
  local d = date:getDay();
  local s = day;
  if (s > d) then 
    s = s - 7;
  end;
  do return __thx_Dates.jump(date, __thx_TimePeriod.Day, s - d) end;
end
__thx_Dates.prevYear = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Year, -1) end;
end
__thx_Dates.nextYear = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Year, 1) end;
end
__thx_Dates.prevMonth = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Month, -1) end;
end
__thx_Dates.nextMonth = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Month, 1) end;
end
__thx_Dates.prevWeek = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Week, -1) end;
end
__thx_Dates.nextWeek = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Week, 1) end;
end
__thx_Dates.prevDay = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Day, -1) end;
end
__thx_Dates.nextDay = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Day, 1) end;
end
__thx_Dates.prevHour = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Hour, -1) end;
end
__thx_Dates.nextHour = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Hour, 1) end;
end
__thx_Dates.prevMinute = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Minute, -1) end;
end
__thx_Dates.nextMinute = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Minute, 1) end;
end
__thx_Dates.prevSecond = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Second, -1) end;
end
__thx_Dates.nextSecond = function(d) 
  do return __thx_Dates.jump(d, __thx_TimePeriod.Second, 1) end;
end
__thx_Dates.withYear = function(date,year) 
  do return __thx_Dates.create(year, date:getMonth(), date:getDate(), date:getHours(), date:getMinutes(), date:getSeconds()) end;
end
__thx_Dates.withMonth = function(date,month) 
  do return __thx_Dates.create(date:getFullYear(), month, date:getDate(), date:getHours(), date:getMinutes(), date:getSeconds()) end;
end
__thx_Dates.withDay = function(date,day) 
  do return __thx_Dates.create(date:getFullYear(), date:getMonth(), day, date:getHours(), date:getMinutes(), date:getSeconds()) end;
end
__thx_Dates.withHour = function(date,hour) 
  do return __thx_Dates.create(date:getFullYear(), date:getMonth(), date:getDate(), hour, date:getMinutes(), date:getSeconds()) end;
end
__thx_Dates.withMinute = function(date,minute) 
  do return __thx_Dates.create(date:getFullYear(), date:getMonth(), date:getDate(), date:getHours(), minute, date:getSeconds()) end;
end
__thx_Dates.withSecond = function(date,second) 
  do return __thx_Dates.create(date:getFullYear(), date:getMonth(), date:getDate(), date:getHours(), date:getMinutes(), second) end;
end
__thx_Dates.parseDate = function(s) 
  local _hx_status, _hx_result = pcall(function() 
  
      do return __thx_Either.Right(__lua_Boot.strDate(s)) end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    do return __thx_Either.Left(Std.string(Std.string("") .. Std.string(s)) .. Std.string(" could not be parsed to a valid Date value.")) end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end

__thx_Dynamics.new = {}
__thx_Dynamics.__name__ = "thx.Dynamics"
__thx_Dynamics.equals = function(a,b) 
  if (not __thx_Types.sameType(a, b)) then 
    do return false end;
  end;
  if (a == b) then 
    do return true end;
  end;
  local _g = Type.typeof(a);
  local tmp = _g[1];
  if (tmp) == 0 or (tmp) == 1 or (tmp) == 2 or (tmp) == 3 then 
    do return false end;
  elseif (tmp) == 4 then 
    local fa = Reflect.fields(a);
    local fb = Reflect.fields(b);
    local _g = 0;
    local _hx_continue_1 = false;
    while (_g < fa.length) do _hx_do_first_1 = false;
      repeat 
      local field = fa[_g];
      _g = _g + 1;
      fb:remove(field);
      local o = b;
      if (not ((function() 
        local _hx_1
        if ((_G.type(o) == "function") and not ((function() 
          local _hx_2
          if (_G.type(o) ~= "table") then 
          _hx_2 = false; else 
          _hx_2 = o.__name__; end
          return _hx_2
        end )() or (function() 
          local _hx_3
          if (_G.type(o) ~= "table") then 
          _hx_3 = false; else 
          _hx_3 = o.__ename__; end
          return _hx_3
        end )())) then 
        _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
        _hx_1 = true; elseif (o.__fields__ ~= nil) then 
        _hx_1 = o.__fields__[field] ~= nil; else 
        _hx_1 = o[field] ~= nil; end
        return _hx_1
      end )())) then 
        do return false end;
      end;
      local va = Reflect.field(a, field);
      if (Reflect.isFunction(va)) then 
        break;
      end;
      local vb = Reflect.field(b, field);
      if (not __thx_Dynamics.equals(va, vb)) then 
        do return false end;
      end;until true
      if _hx_continue_1 then 
      _hx_continue_1 = false;
      break;
      end;
      
    end;
    if (fb.length > 0) then 
      do return false end;
    end;
    local t = false;
    t = __thx_Iterators.isIterator(a);
    if (t or __thx_Iterables.isIterable(a)) then 
      if (t and not __thx_Iterators.isIterator(b)) then 
        do return false end;
      end;
      if (not t and not __thx_Iterables.isIterable(b)) then 
        do return false end;
      end;
      local aa = (function() 
        local _hx_4
        if (t) then 
        _hx_4 = __thx_Iterators.toArray(a); else 
        _hx_4 = __thx_Iterators.toArray(a:iterator()); end
        return _hx_4
      end )();
      local ab = (function() 
        local _hx_5
        if (t) then 
        _hx_5 = __thx_Iterators.toArray(b); else 
        _hx_5 = __thx_Iterators.toArray(b:iterator()); end
        return _hx_5
      end )();
      if (aa.length ~= ab.length) then 
        do return false end;
      end;
      local _g = 0;
      local _g1 = aa.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        if (not __thx_Dynamics.equals(aa[i], ab[i])) then 
          do return false end;
        end;
      end;
      do return true end;
    end;
    do return true end;
  elseif (tmp) == 5 then 
    do return Reflect.compareMethods(a, b) end;
  elseif (tmp) == 6 then 
    local c = _g[2];
    local ca = c.__name__;
    local c = Type.getClass(b);
    local cb = c.__name__;
    if (ca ~= cb) then 
      do return false end;
    end;
    if (__lua_Boot.__instanceof(a, String)) then 
      do return false end;
    end;
    if (__lua_Boot.__instanceof(a, Array)) then 
      local aa = a;
      local ab = b;
      if (aa.length ~= ab.length) then 
        do return false end;
      end;
      local _g = 0;
      local _g1 = aa.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        if (not __thx_Dynamics.equals(aa[i], ab[i])) then 
          do return false end;
        end;
      end;
      do return true end;
    end;
    if (__lua_Boot.__instanceof(a, Date)) then 
      do return a:getTime() == b:getTime() end;
    end;
    if (__lua_Boot.__instanceof(a, __haxe_IMap)) then 
      local ha = a;
      local hb = b;
      local ka = __thx_Iterators.toArray(ha:keys());
      local kb = __thx_Iterators.toArray(hb:keys());
      if (ka.length ~= kb.length) then 
        do return false end;
      end;
      local _g = 0;
      while (_g < ka.length) do _hx_do_first_1 = false;
        
        local key = ka[_g];
        _g = _g + 1;
        local tmp;
        if (hb.h[key] ~= nil) then 
          local ret = ha.h[key];
          local ret1 = hb.h[key];
          tmp = not __thx_Dynamics.equals((function() 
            local _hx_6
            if (ret == __haxe_ds_StringMap.tnull) then 
            _hx_6 = nil; else 
            _hx_6 = ret; end
            return _hx_6
          end )(), (function() 
            local _hx_7
            if (ret1 == __haxe_ds_StringMap.tnull) then 
            _hx_7 = nil; else 
            _hx_7 = ret1; end
            return _hx_7
          end )());
        else
          tmp = true;
        end;
        if (tmp) then 
          do return false end;
        end;
      end;
      do return true end;
    end;
    local t = false;
    t = __thx_Iterators.isIterator(a);
    if (t or __thx_Iterables.isIterable(a)) then 
      local va = (function() 
        local _hx_8
        if (t) then 
        _hx_8 = __thx_Iterators.toArray(a); else 
        _hx_8 = __thx_Iterators.toArray(a:iterator()); end
        return _hx_8
      end )();
      local vb = (function() 
        local _hx_9
        if (t) then 
        _hx_9 = __thx_Iterators.toArray(b); else 
        _hx_9 = __thx_Iterators.toArray(b:iterator()); end
        return _hx_9
      end )();
      if (va.length ~= vb.length) then 
        do return false end;
      end;
      local _g = 0;
      local _g1 = va.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        if (not __thx_Dynamics.equals(va[i], vb[i])) then 
          do return false end;
        end;
      end;
      do return true end;
    end;
    local f = nil;
    local tmp;
    local o = a;
    if ((function() 
      local _hx_10
      if ((_G.type(o) == "function") and not ((function() 
        local _hx_11
        if (_G.type(o) ~= "table") then 
        _hx_11 = false; else 
        _hx_11 = o.__name__; end
        return _hx_11
      end )() or (function() 
        local _hx_12
        if (_G.type(o) ~= "table") then 
        _hx_12 = false; else 
        _hx_12 = o.__ename__; end
        return _hx_12
      end )())) then 
      _hx_10 = false; elseif ((_G.type(o) == "string") and (String.prototype.equals ~= nil)) then 
      _hx_10 = true; elseif (o.__fields__ ~= nil) then 
      _hx_10 = o.__fields__.equals ~= nil; else 
      _hx_10 = o.equals ~= nil; end
      return _hx_10
    end )()) then 
      f = Reflect.field(a, "equals");
      tmp = Reflect.isFunction(f);
    else
      tmp = false;
    end;
    if (tmp) then 
      do return Reflect.callMethod(a,f,_hx_tab_array({[0]=b}, 1)) end;
    end;
    local fields = Type.getInstanceFields(Type.getClass(a));
    local _g = 0;
    local _hx_continue_1 = false;
    while (_g < fields.length) do _hx_do_first_1 = false;
      repeat 
      local field = fields[_g];
      _g = _g + 1;
      local va = Reflect.field(a, field);
      if (Reflect.isFunction(va)) then 
        break;
      end;
      local vb = Reflect.field(b, field);
      if (not __thx_Dynamics.equals(va, vb)) then 
        do return false end;
      end;until true
      if _hx_continue_1 then 
      _hx_continue_1 = false;
      break;
      end;
      
    end;
    do return true end;
  elseif (tmp) == 7 then 
    local e = _g[2];
    local ea = Type.getEnumName(e);
    local teb = Type.getEnum(b);
    local eb = Type.getEnumName(teb);
    if (ea ~= eb) then 
      do return false end;
    end;
    if (a[1] ~= b[1]) then 
      do return false end;
    end;
    local pa = a:slice(2);
    local pb = b:slice(2);
    local _g = 0;
    local _g1 = pa.length;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      if (not __thx_Dynamics.equals(pa[i], pb[i])) then 
        do return false end;
      end;
    end;
    do return true end;
  elseif (tmp) == 8 then 
    _G.error(__haxe_Exception.thrown("Unable to compare two unknown types"),0); end;
end
__thx_Dynamics.clone = function(v,cloneInstances) 
  if (cloneInstances == nil) then 
    cloneInstances = false;
  end;
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    do return nil end;
  elseif (tmp) == 4 then 
    do return __thx_Objects.copyTo(v, _hx_e()) end;
  elseif (tmp) == 1 or (tmp) == 2 or (tmp) == 3 or (tmp) == 5 or (tmp) == 8 then 
    do return v end;
  elseif (tmp) == 6 then 
    local c = _g[2];
    local name = c.__name__;
    local name = name;
    if (name) == "Array" then 
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = v;
      while (_g1 < _g2.length) do _hx_do_first_1 = false;
        
        local i = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(__thx_Dynamics.clone(i, cloneInstances));
      end;
      do return _g end;
    elseif (name) == "Date" or (name) == "String" then 
      do return v end;else
    if (cloneInstances) then 
      local o = Type.createEmptyInstance(c);
      local _g = 0;
      local _g1 = Type.getInstanceFields(c);
      while (_g < _g1.length) do _hx_do_first_1 = false;
        
        local field = _g1[_g];
        _g = _g + 1;
        o[field] = __thx_Dynamics.clone(Reflect.field(v, field), cloneInstances);
      end;
      do return o end;
    else
      do return v end;
    end; end;
  elseif (tmp) == 7 then 
    local _g = _g[2];
    do return v end; end;
end
__thx_Dynamics.compare = function(a,b) 
  if ((nil == a) and (nil == b)) then 
    do return 0 end;
  end;
  if (nil == a) then 
    do return -1 end;
  end;
  if (nil == b) then 
    do return 1 end;
  end;
  if (not __thx_Types.sameType(a, b)) then 
    local a = _hx_wrap_if_string_field(__thx_Types,'toString')(Type.typeof(a));
    local b = _hx_wrap_if_string_field(__thx_Types,'toString')(Type.typeof(b));
    if (a < b) then 
      do return -1 end;
    else
      if (a > b) then 
        do return 1 end;
      else
        do return 0 end;
      end;
    end;
  end;
  local _g = Type.typeof(a);
  local tmp = _g[1];
  if (tmp) == 1 then 
    do return __thx_Ints.compare(a, b) end;
  elseif (tmp) == 2 then 
    local a = a;
    local b = b;
    if (a < b) then 
      do return -1 end;
    else
      if (a > b) then 
        do return 1 end;
      else
        do return 0 end;
      end;
    end;
  elseif (tmp) == 3 then 
    do return __thx_Bools.compare(a, b) end;
  elseif (tmp) == 4 then 
    do return __thx_Objects.compare(a, b) end;
  elseif (tmp) == 6 then 
    local c = _g[2];
    local name = c.__name__;
    local name = name;
    if (name) == "Array" then 
      do return __thx_Arrays.compare(a, b) end;
    elseif (name) == "Date" then 
      do return __thx_Dates.compare(a, b) end;
    elseif (name) == "String" then 
      local a = a;
      local b = b;
      if (a < b) then 
        do return -1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return 0 end;
        end;
      end;else
    if ((function() 
      local _hx_1
      if ((_G.type(a) == "function") and not ((function() 
        local _hx_2
        if (_G.type(a) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = a.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (_G.type(a) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = a.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((_G.type(a) == "string") and (String.prototype.compare ~= nil)) then 
      _hx_1 = true; elseif (a.__fields__ ~= nil) then 
      _hx_1 = a.__fields__.compare ~= nil; else 
      _hx_1 = a.compare ~= nil; end
      return _hx_1
    end )()) then 
      do return Reflect.callMethod(a,Reflect.field(a, "compare"),_hx_tab_array({[0]=b}, 1)) end;
    else
      local a = Std.string(a);
      local b = Std.string(b);
      if (a < b) then 
        do return -1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return 0 end;
        end;
      end;
    end; end;
  elseif (tmp) == 7 then 
    local e = _g[2];
    do return __thx_Enums.compare(a, b) end;else
  do return 0 end; end;
end
__thx_Dynamics.string = function(v) 
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    do return "null" end;
  elseif (tmp) == 1 or (tmp) == 2 or (tmp) == 3 then 
    do return Std.string("") .. Std.string(Std.string(v)) end;
  elseif (tmp) == 4 then 
    do return __thx_Objects.string(v) end;
  elseif (tmp) == 5 then 
    do return "<function>" end;
  elseif (tmp) == 6 then 
    local c = _g[2];
    local _g = c.__name__;
    if (_g) == "Array" then 
      do return __thx_Arrays.string(v) end;
    elseif (_g) == "Date" then 
      do return __lua_Boot.dateStr(v) end;
    elseif (_g) == "String" then 
      do return v end;else
    if (__lua_Boot.__instanceof(v, __haxe_IMap)) then 
      do return __thx_Maps.string(v) end;
    else
      do return Std.string(v) end;
    end; end;
  elseif (tmp) == 7 then 
    local e = _g[2];
    do return __thx_Enums.string(v) end;
  elseif (tmp) == 8 then 
    do return "<unknown>" end; end;
end

__thx_DynamicsT.new = {}
__thx_DynamicsT.__name__ = "thx.DynamicsT"
__thx_DynamicsT.isEmpty = function(o) 
  do return Reflect.fields(o).length == 0 end;
end
__thx_DynamicsT.exists = function(o,name) 
  local o = o;
  if ((_G.type(o) == "function") and not ((function() 
    local _hx_1
    if (_G.type(o) ~= "table") then 
    _hx_1 = false; else 
    _hx_1 = o.__name__; end
    return _hx_1
  end )() or (function() 
    local _hx_2
    if (_G.type(o) ~= "table") then 
    _hx_2 = false; else 
    _hx_2 = o.__ename__; end
    return _hx_2
  end )())) then 
    do return false end;
  else
    if ((_G.type(o) == "string") and ((String.prototype[name] ~= nil) or (name == "length"))) then 
      do return true end;
    else
      if (o.__fields__ ~= nil) then 
        do return o.__fields__[name] ~= nil end;
      else
        do return o[name] ~= nil end;
      end;
    end;
  end;
end
__thx_DynamicsT.fields = function(o) 
  do return Reflect.fields(o) end;
end
__thx_DynamicsT.merge = function(to,from,replacef) 
  if (nil == replacef) then 
    replacef = function(field,oldv,newv) 
      do return newv end;
    end;
  end;
  local _g = 0;
  local _g1 = Reflect.fields(from);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local field = _g1[_g];
    _g = _g + 1;
    local newv = Reflect.field(from, field);
    local o = to;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "function") and not ((function() 
        local _hx_2
        if (_G.type(o) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = o.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (_G.type(o) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = o.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      to[field] = replacef(field, Reflect.field(to, field), newv);
    else
      to[field] = newv;
    end;
  end;
  do return to end;
end
__thx_DynamicsT.size = function(o) 
  do return Reflect.fields(o).length end;
end
__thx_DynamicsT.values = function(o) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = Reflect.fields(o);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(Reflect.field(o, i));
  end;
  do return _g end;
end
__thx_DynamicsT.tuples = function(o) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = Reflect.fields(o);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(_hx_o({__fields__={_0=true,_1=true},_0=i,_1=Reflect.field(o, i)}));
  end;
  do return _g end;
end
_hxClasses["thx.Either"] = { __ename__ = "thx.Either", __constructs__ = _hx_tab_array({[0]="Left","Right"},2)}
__thx_Either = _hxClasses["thx.Either"];
__thx_Either.Left = function(value) local _x = _hx_tab_array({[0]="Left",0,value,__enum__=__thx_Either}, 3); return _x; end 
__thx_Either.Right = function(value) local _x = _hx_tab_array({[0]="Right",1,value,__enum__=__thx_Either}, 3); return _x; end 

__thx_Eithers.new = {}
__thx_Eithers.__name__ = "thx.Eithers"
__thx_Eithers.isLeft = function(either) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local _g = either[2];
    do return true end;
  elseif (tmp) == 1 then 
    local _g = either[2];
    do return false end; end;
end
__thx_Eithers.isRight = function(either) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local _g = either[2];
    do return false end;
  elseif (tmp) == 1 then 
    local _g = either[2];
    do return true end; end;
end
__thx_Eithers.toLeft = function(either) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local v = either[2];
    do return __haxe_ds_Option.Some(v) end;
  elseif (tmp) == 1 then 
    local _g = either[2];
    do return __haxe_ds_Option.None end; end;
end
__thx_Eithers.toRight = function(either) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local _g = either[2];
    do return __haxe_ds_Option.None end;
  elseif (tmp) == 1 then 
    local v = either[2];
    do return __haxe_ds_Option.Some(v) end; end;
end
__thx_Eithers.toLeftUnsafe = function(either) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local v = either[2];
    do return v end;
  elseif (tmp) == 1 then 
    local _g = either[2];
    do return nil end; end;
end
__thx_Eithers.toRightUnsafe = function(either) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local _g = either[2];
    do return nil end;
  elseif (tmp) == 1 then 
    local v = either[2];
    do return v end; end;
end
__thx_Eithers.map = function(either,f) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local v = either[2];
    do return __thx_Either.Left(v) end;
  elseif (tmp) == 1 then 
    local v = either[2];
    do return __thx_Either.Right(f(v)) end; end;
end
__thx_Eithers.ap = function(either,fa) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local l = either[2];
    do return __thx_Either.Left(l) end;
  elseif (tmp) == 1 then 
    local v = either[2];
    do return __thx_Eithers.map(fa, function(f) 
      do return f(v) end;
    end) end; end;
end
__thx_Eithers.flatMap = function(either,f) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local v = either[2];
    do return __thx_Either.Left(v) end;
  elseif (tmp) == 1 then 
    local v = either[2];
    do return f(v) end; end;
end
__thx_Eithers.leftMap = function(either,f) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local v = either[2];
    do return __thx_Either.Left(f(v)) end;
  elseif (tmp) == 1 then 
    local v = either[2];
    do return __thx_Either.Right(v) end; end;
end
__thx_Eithers.orThrow = function(either,message) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local v = either[2];
    _G.error(__haxe_Exception.thrown(__thx_Error.new(Std.string(Std.string(Std.string("") .. Std.string(message)) .. Std.string(": ")) .. Std.string(Std.string(v)), nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/Eithers.hx",lineNumber=104,className="thx.Eithers",methodName="orThrow"}))),0);
  elseif (tmp) == 1 then 
    local v = either[2];
    do return v end; end;
end
__thx_Eithers.toValidation = function(either) 
  do return either end;
end
__thx_Eithers.toVNel = function(either) 
  do return __thx_Eithers.leftMap(either, __thx__Nel_Nel_Impl_.pure) end;
end
__thx_Eithers.cata = function(either,l,r) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local l0 = either[2];
    do return l(l0) end;
  elseif (tmp) == 1 then 
    local r0 = either[2];
    do return r(r0) end; end;
end
__thx_Eithers.bimap = function(either,l,r) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local l0 = either[2];
    do return __thx_Either.Left(l(l0)) end;
  elseif (tmp) == 1 then 
    local r0 = either[2];
    do return __thx_Either.Right(r(r0)) end; end;
end
__thx_Eithers.foldLeft = function(either,a,f) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local l0 = either[2];
    do return a end;
  elseif (tmp) == 1 then 
    local r0 = either[2];
    do return f(a, r0) end; end;
end
__thx_Eithers.foldMap = function(either,f,m) 
  local _e = m;
  local tmp = function(a0,a1) 
    do return __thx__Monoid_Monoid_Impl_.append(_e, a0, a1) end;
  end;
  do return __thx_Eithers.foldLeft(__thx_Eithers.map(either, f), __thx__Monoid_Monoid_Impl_.get_zero(m), tmp) end;
end
__thx_Eithers.getOrElse = function(e0,v) 
  local tmp = e0[1];
  if (tmp) == 0 then 
    local _g = e0[2];
    do return v end;
  elseif (tmp) == 1 then 
    local v = e0[2];
    do return v end; end;
end
__thx_Eithers.getOrElseF = function(e0,f) 
  local tmp = e0[1];
  if (tmp) == 0 then 
    local _g = e0[2];
    do return f() end;
  elseif (tmp) == 1 then 
    local v = e0[2];
    do return v end; end;
end
__thx_Eithers.orElse = function(e0,e1) 
  if (e0[1] == 0) then 
    local e = e0[2];
    do return e1 end;
  else
    local r = e0;
    do return r end;
  end;
end
__thx_Eithers.orElseF = function(e0,f) 
  if (e0[1] == 0) then 
    local e = e0[2];
    do return f() end;
  else
    local r = e0;
    do return r end;
  end;
end
__thx_Eithers.each = function(either,f) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local l = either[2];
  elseif (tmp) == 1 then 
    local r = either[2];
    f(r); end;
end
__thx_Eithers.eachLeft = function(either,f) 
  local tmp = either[1];
  if (tmp) == 0 then 
    local l = either[2];
    f(l);
  elseif (tmp) == 1 then 
    local r = either[2]; end;
end
__thx_Eithers.ensure = function(either,p,error) 
  if (either[1] == 1) then 
    local a = either[2];
    if (p(a)) then 
      do return either end;
    else
      do return __thx_Either.Left(error) end;
    end;
  else
    do return either end;
  end;
end
__thx_Eithers.exists = function(either,p) 
  if (either[1] == 1) then 
    local a = either[2];
    do return p(a) end;
  else
    do return false end;
  end;
end
__thx_Eithers.forall = function(either,p) 
  if (either[1] == 1) then 
    local a = either[2];
    do return p(a) end;
  else
    do return true end;
  end;
end

__thx__Eithers_EitherK_Impl_.new = {}
__thx__Eithers_EitherK_Impl_.__name__ = "thx._Eithers.EitherK_Impl_"
__thx__Eithers_EitherK_Impl_.apply = function(this1,a) 
  do return this1(a) end;
end
__thx__Eithers_EitherK_Impl_.compose = function(this1,f) 
  do return function(a0) 
    do return __thx_Eithers.flatMap(__thx__Eithers_EitherK_Impl_.apply(f, a0), this1) end;
  end end;
end
__thx__Eithers_EitherK_Impl_.andThen = function(this1,f) 
  do return function(a) 
    local tmp = this1(a);
    local _e = f;
    do return __thx_Eithers.flatMap(tmp, function(a) 
      do return __thx__Eithers_EitherK_Impl_.apply(_e, a) end;
    end) end;
  end end;
end
__thx__Eithers_EitherK_Impl_.pure = function(r) 
  do return function(a) 
    do return __thx_Either.Right(r) end;
  end end;
end
__thx__Eithers_EitherK_Impl_.map = function(this1,f) 
  local fb = f;
  do return __thx__Eithers_EitherK_Impl_.flatMap(this1, function(v) 
    do return __thx__Eithers_EitherK_Impl_.pure(fb(v)) end;
  end) end;
end
__thx__Eithers_EitherK_Impl_.ap = function(this1,e) 
  do return __thx__Eithers_EitherK_Impl_.flatMap(this1, function(r) 
    do return __thx__Eithers_EitherK_Impl_.map(e, function(f) 
      do return f(r) end;
    end) end;
  end) end;
end
__thx__Eithers_EitherK_Impl_.flatMap = function(this1,f) 
  do return function(a) 
    do return __thx_Eithers.flatMap(this1(a), function(r) 
      do return __thx__Eithers_EitherK_Impl_.apply(f(r), a) end;
    end) end;
  end end;
end
__thx__Eithers_EitherK_Impl_.monoid = function() 
  do return _hx_o({__fields__={zero=true,append=true},zero=function(r) 
    do return __thx_Either.Right(r) end;
  end,append=function(self,f0,f1) 
    do return function(r) 
      local tmp = __thx__Eithers_EitherK_Impl_.apply(f0, r);
      local _e = f1;
      do return __thx_Eithers.flatMap(tmp, function(a) 
        do return __thx__Eithers_EitherK_Impl_.apply(_e, a) end;
      end) end;
    end end;
  end}) end;
end

__thx_Enums.new = {}
__thx_Enums.__name__ = "thx.Enums"
__thx_Enums.string = function(e) 
  local cons = e[0];
  local params = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = e:slice(2);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local param = _g1[_g];
    _g = _g + 1;
    params:push(__thx_Dynamics.string(param));
  end;
  do return Std.string(cons) .. Std.string(((function() 
    local _hx_1
    if (params.length == 0) then 
    _hx_1 = ""; else 
    _hx_1 = Std.string(Std.string("(") .. Std.string(params:join(", "))) .. Std.string(")"); end
    return _hx_1
  end )())) end;
end
__thx_Enums.compare = function(a,b) 
  local v = __thx_Ints.compare(a[1], b[1]);
  if (v ~= 0) then 
    do return v end;
  end;
  do return __thx_Arrays.compare(a:slice(2), b:slice(2)) end;
end
__thx_Enums.sameConstructor = function(a,b) 
  do return a[1] == b[1] end;
end
__thx_Enums.min = function(a,b) 
  if (__thx_Enums.compare(a, b) < 0) then 
    do return a end;
  else
    do return b end;
  end;
end
__thx_Enums.max = function(a,b) 
  if (__thx_Enums.compare(a, b) > 0) then 
    do return a end;
  else
    do return b end;
  end;
end

__thx_Error.new = function(message,stack,pos) 
  local self = _hx_new(__thx_Error.prototype)
  __thx_Error.super(self,message,stack,pos)
  return self
end
__thx_Error.super = function(self,message,stack,pos) 
  self.message = message;
  if (nil == stack) then 
    local _hx_status, _hx_result = pcall(function() 
    
        stack = __haxe__CallStack_CallStack_Impl_.exceptionStack();
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      stack = _hx_tab_array({}, 0);
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
    if (stack.length == 0) then 
      local _hx_status, _hx_result = pcall(function() 
      
          stack = __haxe__CallStack_CallStack_Impl_.callStack();
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
        local _g = _hx_result;
        stack = _hx_tab_array({}, 0);
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
    end;
  end;
  self.stackItems = stack;
  self.pos = pos;
end
__thx_Error.__name__ = "thx.Error"
__thx_Error.fromDynamic = function(err,pos) 
  if (__lua_Boot.__instanceof(err, __thx_Error)) then 
    do return err end;
  end;
  do return __thx_error_ErrorWrapper.new(Std.string("") .. Std.string(Std.string(err)), err, nil, pos) end;
end
__thx_Error.prototype = _hx_e();
__thx_Error.prototype.message= nil;
__thx_Error.prototype.pos= nil;
__thx_Error.prototype.stackItems= nil;
__thx_Error.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(self.message) .. Std.string("\nfrom: ")) .. Std.string(self:getPosition())) .. Std.string("\n\n")) .. Std.string(self:stackToString()) end
end
__thx_Error.prototype.getPosition = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(self.pos.className) .. Std.string(".")) .. Std.string(self.pos.methodName)) .. Std.string("() at ")) .. Std.string(self.pos.lineNumber) end
end
__thx_Error.prototype.stackToString = function(self) 
  do return _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(self.stackItems) end
end

__thx_Error.prototype.__class__ =  __thx_Error

__thx_Floats.new = {}
__thx_Floats.__name__ = "thx.Floats"
__thx_Floats.angleDifference = function(a,b,turn) 
  if (turn == nil) then 
    turn = 360.0;
  end;
  local r = _G.math.fmod((b - a), turn);
  if (r < 0) then 
    r = r + turn;
  end;
  if (r > (turn / 2)) then 
    r = r - turn;
  end;
  do return r end;
end
__thx_Floats.ceilTo = function(f,decimals) 
  local p = _G.math.pow(10, decimals);
  do return _G.math.ceil(f * p) / p end;
end
__thx_Floats.canParse = function(s) 
  if (not (__thx_Floats.pattern_parse:match(s) or __thx_Floats.pattern_inf:match(s))) then 
    do return __thx_Floats.pattern_neg_inf:match(s) end;
  else
    do return true end;
  end;
end
__thx_Floats.clamp = function(v,min,max) 
  if (v < min) then 
    do return min end;
  else
    if (v > max) then 
      do return max end;
    else
      do return v end;
    end;
  end;
end
__thx_Floats.clampSym = function(v,max) 
  local min = -max;
  if (v < min) then 
    do return min end;
  else
    if (v > max) then 
      do return max end;
    else
      do return v end;
    end;
  end;
end
__thx_Floats.compare = function(a,b) 
  if (a < b) then 
    do return -1 end;
  else
    if (a > b) then 
      do return 1 end;
    else
      do return 0 end;
    end;
  end;
end
__thx_Floats.floorTo = function(f,decimals) 
  local p = _G.math.pow(10, decimals);
  do return _G.math.floor(f * p) / p end;
end
__thx_Floats.interpolate = function(f,a,b) 
  do return ((b - a) * f) + a end;
end
__thx_Floats.interpolateAngle = function(f,a,b,turn) 
  if (turn == nil) then 
    turn = 360;
  end;
  do return __thx_Floats.wrapCircular(__thx_Floats.interpolate(f, a, a + __thx_Floats.angleDifference(a, b, turn)), turn) end;
end
__thx_Floats.interpolateAngleWidest = function(f,a,b,turn) 
  if (turn == nil) then 
    turn = 360;
  end;
  do return __thx_Floats.wrapCircular(__thx_Floats.interpolateAngle(f, a, b, turn) - (turn / 2), turn) end;
end
__thx_Floats.interpolateAngleCW = function(f,a,b,turn) 
  if (turn == nil) then 
    turn = 360;
  end;
  a = __thx_Floats.wrapCircular(a, turn);
  b = __thx_Floats.wrapCircular(b, turn);
  if (b < a) then 
    b = b + turn;
  end;
  do return __thx_Floats.wrapCircular(__thx_Floats.interpolate(f, a, b), turn) end;
end
__thx_Floats.interpolateAngleCCW = function(f,a,b,turn) 
  if (turn == nil) then 
    turn = 360;
  end;
  a = __thx_Floats.wrapCircular(a, turn);
  b = __thx_Floats.wrapCircular(b, turn);
  if (b > a) then 
    b = b - turn;
  end;
  do return __thx_Floats.wrapCircular(__thx_Floats.interpolate(f, a, b), turn) end;
end
__thx_Floats.max = function(a,b) 
  if (a > b) then 
    do return a end;
  else
    do return b end;
  end;
end
__thx_Floats.min = function(a,b) 
  if (a < b) then 
    do return a end;
  else
    do return b end;
  end;
end
__thx_Floats.nearEquals = function(a,b,tollerance) 
  if (tollerance == nil) then 
    tollerance = 1e-9;
  end;
  if (Math.isFinite(a)) then 
    do return _G.math.abs(a - b) <= tollerance end;
  end;
  if (Math.isNaN(a)) then 
    do return Math.isNaN(b) end;
  end;
  if (Math.isNaN(b)) then 
    do return false end;
  end;
  if (not Math.isFinite(b)) then 
    do return (a > 0) == (b > 0) end;
  end;
  do return false end;
end
__thx_Floats.nearEqualAngles = function(a,b,turn,tollerance) 
  if (tollerance == nil) then 
    tollerance = 1e-9;
  end;
  if (turn == nil) then 
    turn = 360.0;
  end;
  do return _G.math.abs(__thx_Floats.angleDifference(a, b, turn)) <= tollerance end;
end
__thx_Floats.nearZero = function(n,tollerance) 
  if (tollerance == nil) then 
    tollerance = 1e-9;
  end;
  do return _G.math.abs(n) <= tollerance end;
end
__thx_Floats.normalize = function(v) 
  if (v < 0) then 
    do return 0 end;
  else
    if (v > 1) then 
      do return 1 end;
    else
      do return v end;
    end;
  end;
end
__thx_Floats.parse = function(s) 
  if (String.prototype.substring(s, 0, 1) == "+") then 
    s = String.prototype.substring(s, 1);
  end;
  if (__thx_Floats.pattern_inf:match(s)) then 
    do return _G.math.huge end;
  else
    if (__thx_Floats.pattern_neg_inf:match(s)) then 
      do return -_G.math.huge end;
    else
      do return Std.parseFloat(s) end;
    end;
  end;
end
__thx_Floats.root = function(base,index) 
  do return _G.math.pow(base, 1 / index) end;
end
__thx_Floats.roundTo = function(f,decimals) 
  local p = _G.math.pow(10, decimals);
  do return _G.math.floor((f * p) + 0.5) / p end;
end
__thx_Floats.sign = function(value) 
  if (value < 0) then 
    do return -1 end;
  else
    do return 1 end;
  end;
end
__thx_Floats.toString = function(v) 
  do return Std.string("") .. Std.string(v) end;
end
__thx_Floats.toFloat = function(s) 
  do return __thx_Floats.parse(s) end;
end
__thx_Floats.trunc = function(value) 
  if (value < 0.0) then 
    do return _G.math.ceil(value) end;
  else
    do return _G.math.floor(value) end;
  end;
end
__thx_Floats.ftrunc = function(value) 
  if (value < 0.0) then 
    do return _G.math.ceil(value) end;
  else
    do return _G.math.floor(value) end;
  end;
end
__thx_Floats.wrap = function(v,min,max) 
  local range = (max - min) + 1;
  if (v < min) then 
    v = v + (range * (((min - v) / range) + 1));
  end;
  do return min + (_G.math.fmod((v - min), range)) end;
end
__thx_Floats.wrapCircular = function(v,max) 
  v = _G.math.fmod(v, max);
  if (v < 0) then 
    v = v + max;
  end;
  do return v end;
end

__thx_Functions0.new = {}
__thx_Functions0.__name__ = "thx.Functions0"
__thx_Functions0.after = function(callback,n) 
  do return function() 
    n = n - 1;
    if (n == 0) then 
      callback();
    end;
  end end;
end
__thx_Functions0.join = function(fa,fb) 
  do return function() 
    fa();
    fb();
  end end;
end
__thx_Functions0.memoize = function(callback) 
  local result = nil;
  do return function() 
    if (result == nil) then 
      result = callback();
    end;
    do return result end;
  end end;
end
__thx_Functions0.once = function(f) 
  do return function() 
    local t = f;
    f = __thx_Functions.noop;
    t();
  end end;
end
__thx_Functions0.negate = function(callback) 
  do return function() 
    do return not callback() end;
  end end;
end
__thx_Functions0.times = function(n,callback) 
  do return function() 
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = __thx_Ints.range(n);
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(callback());
    end;
    do return _g end;
  end end;
end
__thx_Functions0.timesi = function(n,callback) 
  do return function() 
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = __thx_Ints.range(n);
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(callback(i));
    end;
    do return _g end;
  end end;
end

__thx_Functions1.new = {}
__thx_Functions1.__name__ = "thx.Functions1"
__thx_Functions1.compose = function(fa,fb) 
  do return function(v) 
    do return fa(fb(v)) end;
  end end;
end
__thx_Functions1.map = function(fab,fbc) 
  do return function(a) 
    do return fbc(fab(a)) end;
  end end;
end
__thx_Functions1.contramap = function(fbc,fab) 
  do return function(a) 
    do return fbc(fab(a)) end;
  end end;
end
__thx_Functions1.join = function(fa,fb) 
  do return function(v) 
    fa(v);
    fb(v);
  end end;
end
__thx_Functions1.memoize = function(callback,resolver) 
  if (nil == resolver) then 
    resolver = function(v) 
      do return Std.string("") .. Std.string(Std.string(v)) end;
    end;
  end;
  local map_h = ({});
  do return function(v) 
    local key = resolver(v);
    if (map_h[key] ~= nil) then 
      local ret = map_h[key];
      if (ret == __haxe_ds_StringMap.tnull) then 
        do return nil end;
      else
        do return ret end;
      end;
    end;
    local result = callback(v);
    if (result == nil) then 
      map_h[key] = __haxe_ds_StringMap.tnull;
    else
      map_h[key] = result;
    end;
    do return result end;
  end end;
end
__thx_Functions1.negate = function(callback) 
  do return function(v) 
    do return not callback(v) end;
  end end;
end
__thx_Functions1.noop = function(_) 
end
__thx_Functions1.times = function(n,callback) 
  do return function(value) 
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = __thx_Ints.range(n);
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(callback(value));
    end;
    do return _g end;
  end end;
end
__thx_Functions1.timesi = function(n,callback) 
  do return function(value) 
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = __thx_Ints.range(n);
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(callback(value, i));
    end;
    do return _g end;
  end end;
end
__thx_Functions1.swapArguments = function(callback) 
  do return function(a2,a1) 
    do return callback(a1, a2) end;
  end end;
end

__thx_Functions2.new = {}
__thx_Functions2.__name__ = "thx.Functions2"
__thx_Functions2.memoize = function(callback,resolver) 
  if (nil == resolver) then 
    resolver = function(v1,v2) 
      do return Std.string(Std.string(Std.string("") .. Std.string(Std.string(v1))) .. Std.string(":")) .. Std.string(Std.string(v2)) end;
    end;
  end;
  local map_h = ({});
  do return function(v1,v2) 
    local key = resolver(v1, v2);
    if (map_h[key] ~= nil) then 
      local ret = map_h[key];
      if (ret == __haxe_ds_StringMap.tnull) then 
        do return nil end;
      else
        do return ret end;
      end;
    end;
    local result = callback(v1, v2);
    if (result == nil) then 
      map_h[key] = __haxe_ds_StringMap.tnull;
    else
      map_h[key] = result;
    end;
    do return result end;
  end end;
end
__thx_Functions2.curry = function(f) 
  do return function(a) 
    do return function(b) 
      do return f(a, b) end;
    end end;
  end end;
end
__thx_Functions2.join = function(fa,fb) 
  do return function(v1,v2) 
    fa(v1, v2);
    fb(v1, v2);
  end end;
end
__thx_Functions2.negate = function(callback) 
  do return function(v1,v2) 
    do return not callback(v1, v2) end;
  end end;
end

__thx_Functions3.new = {}
__thx_Functions3.__name__ = "thx.Functions3"
__thx_Functions3.memoize = function(callback,resolver) 
  if (nil == resolver) then 
    resolver = function(v1,v2,v3) 
      do return Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(Std.string(v1))) .. Std.string(":")) .. Std.string(Std.string(v2))) .. Std.string(":")) .. Std.string(Std.string(v3)) end;
    end;
  end;
  local map_h = ({});
  do return function(v1,v2,v3) 
    local key = resolver(v1, v2, v3);
    if (map_h[key] ~= nil) then 
      local ret = map_h[key];
      if (ret == __haxe_ds_StringMap.tnull) then 
        do return nil end;
      else
        do return ret end;
      end;
    end;
    local result = callback(v1, v2, v3);
    if (result == nil) then 
      map_h[key] = __haxe_ds_StringMap.tnull;
    else
      map_h[key] = result;
    end;
    do return result end;
  end end;
end
__thx_Functions3.negate = function(callback) 
  do return function(v1,v2,v3) 
    do return not callback(v1, v2, v3) end;
  end end;
end
__thx_Functions3.curry = function(f) 
  do return function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end end;
end

__thx_Functions4.new = {}
__thx_Functions4.__name__ = "thx.Functions4"
__thx_Functions4.curry = function(f) 
  do return function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end end;
end

__thx_Functions5.new = {}
__thx_Functions5.__name__ = "thx.Functions5"
__thx_Functions5.curry = function(f) 
  do return function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end end;
end

__thx_Functions6.new = {}
__thx_Functions6.__name__ = "thx.Functions6"
__thx_Functions6.curry = function(f) 
  do return function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end end;
end

__thx_Functions7.new = {}
__thx_Functions7.__name__ = "thx.Functions7"
__thx_Functions7.curry = function(f) 
  do return function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end end;
end

__thx_Functions8.new = {}
__thx_Functions8.__name__ = "thx.Functions8"
__thx_Functions8.curry = function(f) 
  do return function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end end;
end

__thx_Functions9.new = {}
__thx_Functions9.__name__ = "thx.Functions9"
__thx_Functions9.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end end;
end

__thx_Functions10.new = {}
__thx_Functions10.__name__ = "thx.Functions10"
__thx_Functions10.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end end;
end

__thx_Functions11.new = {}
__thx_Functions11.__name__ = "thx.Functions11"
__thx_Functions11.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end end;
end

__thx_Functions12.new = {}
__thx_Functions12.__name__ = "thx.Functions12"
__thx_Functions12.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end end;
end

__thx_Functions13.new = {}
__thx_Functions13.__name__ = "thx.Functions13"
__thx_Functions13.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end end;
end

__thx_Functions14.new = {}
__thx_Functions14.__name__ = "thx.Functions14"
__thx_Functions14.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end end;
end

__thx_Functions15.new = {}
__thx_Functions15.__name__ = "thx.Functions15"
__thx_Functions15.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end end;
end

__thx_Functions16.new = {}
__thx_Functions16.__name__ = "thx.Functions16"
__thx_Functions16.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o) 
    do return function(p) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p) end;
    end end;
  end end;
end

__thx_Functions17.new = {}
__thx_Functions17.__name__ = "thx.Functions17"
__thx_Functions17.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p) 
    do return function(q) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q) end;
    end end;
  end end;
end

__thx_Functions18.new = {}
__thx_Functions18.__name__ = "thx.Functions18"
__thx_Functions18.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q) 
    do return function(r) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r) end;
    end end;
  end end;
end

__thx_Functions19.new = {}
__thx_Functions19.__name__ = "thx.Functions19"
__thx_Functions19.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q,r) 
    do return function(s) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r, s) end;
    end end;
  end end;
end

__thx_Functions20.new = {}
__thx_Functions20.__name__ = "thx.Functions20"
__thx_Functions20.curry = function(f) 
  do return function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q,r,s) 
    do return function(t) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r, s, t) end;
    end end;
  end end;
end

__thx__Functions_Reader_Impl_.new = {}
__thx__Functions_Reader_Impl_.__name__ = "thx._Functions.Reader_Impl_"
__thx__Functions_Reader_Impl_.flatMap = function(this1,f) 
  do return function(a) 
    do return (f(this1(a)))(a) end;
  end end;
end

__thx_Functions.new = {}
__thx_Functions.__name__ = "thx.Functions"
__thx_Functions.equality = function(a,b) 
  do return a == b end;
end
__thx_Functions.identity = function(value) 
  do return value end;
end
__thx_Functions.noop = function() 
end
__thx_Functions.passTo = function(a,f) 
  do return f(a) end;
end
__thx_Functions.applyTo = function(f,a) 
  do return f(a) end;
end

__thx_Ints.new = {}
__thx_Ints.__name__ = "thx.Ints"
__thx_Ints.abs = function(v) 
  if (v < 0) then 
    do return -v end;
  else
    do return v end;
  end;
end
__thx_Ints.canParse = function(s) 
  do return __thx_Ints.pattern_parse:match(s) end;
end
__thx_Ints.clamp = function(v,min,max) 
  if (v < min) then 
    do return min end;
  else
    if (v > max) then 
      do return max end;
    else
      do return v end;
    end;
  end;
end
__thx_Ints.clampSym = function(v,max) 
  local min = -max;
  if (v < min) then 
    do return min end;
  else
    if (v > max) then 
      do return max end;
    else
      do return v end;
    end;
  end;
end
__thx_Ints.compare = function(a,b) 
  do return a - b end;
end
__thx_Ints.gcd = function(m,n) 
  if (m < 0) then 
    m = -m;
  end;
  if (n < 0) then 
    n = -n;
  end;
  local t;
  while (true) do _hx_do_first_1 = false;
    
    if (n == 0) then 
      do return m end;
    end;
    t = m;
    m = n;
    n = _G.math.fmod(t, m);
  end;
end
__thx_Ints.interpolate = function(f,a,b) 
  do return _G.math.floor((a + ((b - a) * f)) + 0.5) end;
end
__thx_Ints.isEven = function(v) 
  do return (_G.math.fmod(v, 2)) == 0 end;
end
__thx_Ints.isOdd = function(v) 
  do return (_G.math.fmod(v, 2)) ~= 0 end;
end
__thx_Ints.lpad = function(v,pad,len) 
  if (pad == nil) then 
    pad = "0";
  end;
  local neg = false;
  if (v < 0) then 
    neg = true;
    v = -v;
  end;
  do return Std.string(((function() 
    local _hx_1
    if (neg) then 
    _hx_1 = "-"; else 
    _hx_1 = ""; end
    return _hx_1
  end )())) .. Std.string(StringTools.lpad(Std.string("") .. Std.string(v), pad, len)) end;
end
__thx_Ints.lcm = function(m,n) 
  if (m < 0) then 
    m = -m;
  end;
  if (n < 0) then 
    n = -n;
  end;
  if (n == 0) then 
    do return m end;
  end;
  do return m * Std.int(n / __thx_Ints.gcd(m, n)) end;
end
__thx_Ints.rpad = function(v,pad,len) 
  if (pad == nil) then 
    pad = "0";
  end;
  do return StringTools.rpad(Std.string("") .. Std.string(v), pad, len) end;
end
__thx_Ints.max = function(a,b) 
  if (a > b) then 
    do return a end;
  else
    do return b end;
  end;
end
__thx_Ints.min = function(a,b) 
  if (a < b) then 
    do return a end;
  else
    do return b end;
  end;
end
__thx_Ints.parse = function(s,base) 
  if ((base ~= nil) and ((base < 2) or (base > __lua_lib_luautf8_Utf8.len(__thx_Ints.BASE)))) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("invalid base ") .. Std.string(base)) .. Std.string(", it must be between 2 and ")) .. Std.string(__lua_lib_luautf8_Utf8.len(__thx_Ints.BASE))),0);
  end;
  s = __lua_lib_luautf8_Utf8.lower(StringTools.trim(s));
  local sign;
  if (StringTools.startsWith(s, "+")) then 
    s = String.prototype.substring(s, 1);
    sign = 1;
  else
    if (StringTools.startsWith(s, "-")) then 
      s = String.prototype.substring(s, 1);
      sign = -1;
    else
      sign = 1;
    end;
  end;
  if (__lua_lib_luautf8_Utf8.len(s) == 0) then 
    do return nil end;
  end;
  if (StringTools.startsWith(s, "0x")) then 
    if ((nil ~= base) and (16 ~= base)) then 
      do return nil end;
    end;
    base = 16;
    s = String.prototype.substring(s, 2);
  else
    if (nil == base) then 
      base = 10;
    end;
  end;
  local acc = 0;
  local _hx_status, _hx_result = pcall(function() 
  
      __thx_Strings.map(s, function(c) 
        local i = String.prototype.indexOf(__thx_Ints.BASE, c);
        if ((i < 0) or (i >= base)) then 
          _G.error(__haxe_Exception.thrown("invalid"),0);
        end;
        acc = (acc * base) + i;
      end);
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return acc * sign end;
end
__thx_Ints.random = function(min,max) 
  if (min == nil) then 
    min = 0;
  end;
  do return Std.random((max - min) + 1) + min end;
end
__thx_Ints.range = function(start,stop,step) 
  if (step == nil) then 
    step = 1;
  end;
  if (nil == stop) then 
    stop = start;
    start = 0;
  end;
  if (((stop - start) / step) == _G.math.huge) then 
    _G.error(__haxe_Exception.thrown("infinite range"),0);
  end;
  local range = _hx_tab_array({}, 0);
  local i = -1;
  local j;
  if (step < 0) then 
    while (true) do _hx_do_first_1 = false;
      
      i = i + 1;
      j = start + (step * i);
      if (not (j > stop)) then 
        break;
      end;
      range:push(j);
    end;
  else
    while (true) do _hx_do_first_1 = false;
      
      i = i + 1;
      j = start + (step * i);
      if (not (j < stop)) then 
        break;
      end;
      range:push(j);
    end;
  end;
  do return range end;
end
__thx_Ints.rangeIter = function(start,stop,step) 
  if (step == nil) then 
    step = 1;
  end;
  do return __thx_RangeIterator.new(start, stop, step) end;
end
__thx_Ints.toString = function(value,base) 
  if ((base < 2) or (base > __lua_lib_luautf8_Utf8.len(__thx_Ints.BASE))) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("invalid base ") .. Std.string(base)) .. Std.string(", it must be between 2 and ")) .. Std.string(__lua_lib_luautf8_Utf8.len(__thx_Ints.BASE))),0);
  end;
  if ((base == 10) or (value == 0)) then 
    do return Std.string("") .. Std.string(value) end;
  end;
  local buf = "";
  local abs = (function() 
    local _hx_1
    if (value < 0) then 
    _hx_1 = -value; else 
    _hx_1 = value; end
    return _hx_1
  end )();
  while (abs > 0) do _hx_do_first_1 = false;
    
    local index = _G.math.fmod(abs, base);
    buf = Std.string(__lua_lib_luautf8_Utf8.sub(__thx_Ints.BASE, index + 1, index + 1)) .. Std.string(buf);
    abs = Std.int(abs / base);
  end;
  do return Std.string(((function() 
    local _hx_2
    if (value < 0) then 
    _hx_2 = "-"; else 
    _hx_2 = ""; end
    return _hx_2
  end )())) .. Std.string(buf) end;
end
__thx_Ints.toBase = function(value,base) 
  do return _hx_wrap_if_string_field(__thx_Ints,'toString')(value, base) end;
end
__thx_Ints.toBool = function(v) 
  do return v ~= 0 end;
end
__thx_Ints.toInt = function(s,base) 
  do return __thx_Ints.parse(s, base) end;
end
__thx_Ints.sign = function(value) 
  if (value < 0) then 
    do return -1 end;
  else
    do return 1 end;
  end;
end
__thx_Ints.wrapCircular = function(v,max) 
  v = _G.math.fmod(v, max);
  if (v < 0) then 
    v = v + max;
  end;
  do return v end;
end

__thx_RangeIterator.new = function(start,stop,step) 
  local self = _hx_new(__thx_RangeIterator.prototype)
  __thx_RangeIterator.super(self,start,stop,step)
  return self
end
__thx_RangeIterator.super = function(self,start,stop,step) 
  if (step == nil) then 
    step = 1;
  end;
  self.current = start;
  self.stop = stop;
  self.step = step;
end
__thx_RangeIterator.__name__ = "thx.RangeIterator"
__thx_RangeIterator.prototype = _hx_e();
__thx_RangeIterator.prototype.current= nil;
__thx_RangeIterator.prototype.stop= nil;
__thx_RangeIterator.prototype.step= nil;
__thx_RangeIterator.prototype.hasNext = function(self) 
  if (not ((self.stop == nil) or ((self.step >= 0) and (self.current < self.stop)))) then 
    if (self.step < 0) then 
      do return self.current > self.stop end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
__thx_RangeIterator.prototype.next = function(self) 
  local result = self.current;
  local tmp = self;
  tmp.current = tmp.current + self.step;
  do return result end
end

__thx_RangeIterator.prototype.__class__ =  __thx_RangeIterator

__thx_Iterables.new = {}
__thx_Iterables.__name__ = "thx.Iterables"
__thx_Iterables.all = function(it,predicate) 
  do return __thx_Iterators.all(it:iterator(), predicate) end;
end
__thx_Iterables.any = function(it,predicate) 
  do return __thx_Iterators.any(it:iterator(), predicate) end;
end
__thx_Iterables.eachPair = function(it,handler) 
  __thx_Iterators.eachPair(it:iterator(), handler);
end
__thx_Iterables.equals = function(a,b,equality) 
  do return __thx_Iterators.equals(a:iterator(), b:iterator(), equality) end;
end
__thx_Iterables.filter = function(it,predicate) 
  do return __thx_Iterators.filter(it:iterator(), predicate) end;
end
__thx_Iterables.find = function(it,predicate) 
  do return __thx_Iterators.find(it:iterator(), predicate) end;
end
__thx_Iterables.findOption = function(it,predicate) 
  local value = __thx_Iterators.find(it:iterator(), predicate);
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Iterables.first = function(it) 
  do return __thx_Iterators.first(it:iterator()) end;
end
__thx_Iterables.get = function(it,index) 
  do return __thx_Iterators.get(it:iterator(), index) end;
end
__thx_Iterables.getOption = function(it,index) 
  local value = __thx_Iterators.get(it:iterator(), index);
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Iterables.last = function(it) 
  do return __thx_Iterators.last(it:iterator()) end;
end
__thx_Iterables.hasElements = function(it) 
  do return it:iterator():hasNext() end;
end
__thx_Iterables.indexOf = function(it,element) 
  do return _hx_wrap_if_string_field(__thx_Iterators,'indexOf')(it:iterator(), element) end;
end
__thx_Iterables.isEmpty = function(it) 
  do return not it:iterator():hasNext() end;
end
__thx_Iterables.isIterable = function(v) 
  local fields = (function() 
    local _hx_1
    if (Reflect.isObject(v) and (nil == Type.getClass(v))) then 
    _hx_1 = Reflect.fields(v); else 
    _hx_1 = Type.getInstanceFields(Type.getClass(v)); end
    return _hx_1
  end )();
  if (not Lambda.has(fields, "iterator")) then 
    do return false end;
  end;
  do return Reflect.isFunction(Reflect.field(v, "iterator")) end;
end
__thx_Iterables.map = function(it,f) 
  do return __thx_Iterators.map(it:iterator(), f) end;
end
__thx_Iterables.fmap = function(it,f) 
  do return _hx_o({__fields__={iterator=true},iterator=function(self) 
    do return __thx_Iterators.fmap(it:iterator(), f) end;
  end}) end;
end
__thx_Iterables.mapi = function(it,f) 
  do return __thx_Iterators.mapi(it:iterator(), f) end;
end
__thx_Iterables.fmapi = function(it,f) 
  do return _hx_o({__fields__={iterator=true},iterator=function(self) 
    do return __thx_Iterators.fmapi(it:iterator(), f) end;
  end}) end;
end
__thx_Iterables.order = function(it,sort) 
  do return __thx_Iterators.order(it:iterator(), sort) end;
end
__thx_Iterables.reduce = function(it,callback,initial) 
  do return __thx_Iterators.reduce(it:iterator(), callback, initial) end;
end
__thx_Iterables.reducei = function(it,callback,initial) 
  do return __thx_Iterators.reducei(it:iterator(), callback, initial) end;
end
__thx_Iterables.toArray = function(it) 
  do return __thx_Iterators.toArray(it:iterator()) end;
end
__thx_Iterables.minBy = function(it,f,ord) 
  local found = __haxe_ds_Option.None;
  local a = it:iterator();
  while (a:hasNext()) do _hx_do_first_1 = false;
    
    local a = _hx_tab_array({[0]=a:next()}, 1);
    if (not __thx_Options.any(found, (function(a) 
      do return function(a0) 
        do return ord(f(a0), f(a[0])) == __thx_OrderingImpl.LT end;
      end end;
    end)(a))) then 
      found = __haxe_ds_Option.Some(a[0]);
    end;
  end;
  do return found end;
end
__thx_Iterables.maxBy = function(it,f,ord) 
  do return __thx_Iterables.minBy(it, f, __thx__Ord_Ord_Impl_.inverse(ord)) end;
end
__thx_Iterables.min = function(it,ord) 
  do return __thx_Iterables.minBy(it, __thx_Functions.identity, ord) end;
end
__thx_Iterables.max = function(it,ord) 
  do return __thx_Iterables.minBy(it, __thx_Functions.identity, __thx__Ord_Ord_Impl_.inverse(ord)) end;
end
__thx_Iterables.extremaBy = function(it,f,ord) 
  local found = __haxe_ds_Option.None;
  local a = it:iterator();
  while (a:hasNext()) do _hx_do_first_1 = false;
    
    local a = a:next();
    local found1 = found[1];
    if (found1) == 0 then 
      local _g = found[2];
      local t = _g;
      if (ord(f(a), f(t._0)) == __thx_OrderingImpl.LT) then 
        found = __haxe_ds_Option.Some(_hx_o({__fields__={_0=true,_1=true},_0=a,_1=t._1}));
      else
        local t = _g;
        if (ord(f(a), f(t._1)) == __thx_OrderingImpl.GT) then 
          found = __haxe_ds_Option.Some(_hx_o({__fields__={_0=true,_1=true},_0=t._0,_1=a}));
        end;
      end;
    elseif (found1) == 1 then 
      found = __haxe_ds_Option.Some(_hx_o({__fields__={_0=true,_1=true},_0=a,_1=a}));else end;
  end;
  do return found end;
end
__thx_Iterables.extrema = function(it,ord) 
  do return __thx_Iterables.extremaBy(it, __thx_Functions.identity, ord) end;
end
__thx_Iterables.takeUntil = function(it,fn) 
  do return __thx_Iterators.takeUntil(it:iterator(), fn) end;
end
__thx_Iterables.dropLeft = function(itr,n) 
  do return _hx_o({__fields__={iterator=true},iterator=function(self) 
    local itr = itr:iterator();
    local count = n;
    while (count > 0) do _hx_do_first_1 = false;
      
      if (itr:hasNext()) then 
        itr:next();
      end;
    end;
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(_,...) return _hx_bind(itr,itr.next)(...) end,hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end}) end;
  end}) end;
end
__thx_Iterables.dropUntil = function(it,fn) 
  do return __thx_Iterators.dropUntil(it:iterator(), fn) end;
end
__thx_Iterables.unionBy = function(a,b,eq) 
  local res = _hx_tab_array({}, 0);
  local e = a:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = e:next();
    res:push(e);
  end;
  local e = b:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = _hx_tab_array({[0]=e:next()}, 1);
    if (not __thx_Iterables.any(res, (function(e) 
      do return function(x) 
        do return eq(x, e[0]) end;
      end end;
    end)(e))) then 
      res:push(e[0]);
    end;
  end;
  do return res end;
end
__thx_Iterables.differenceBy = function(a,b,eq) 
  local res = _hx_tab_array({}, 0);
  local e = a:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = _hx_tab_array({[0]=e:next()}, 1);
    if (not __thx_Iterables.any(b, (function(e) 
      do return function(x) 
        do return eq(x, e[0]) end;
      end end;
    end)(e))) then 
      res:push(e[0]);
    end;
  end;
  do return res end;
end
__thx_Iterables.unzip = function(it) 
  do return __thx_Iterators.unzip(it:iterator()) end;
end
__thx_Iterables.unzip3 = function(it) 
  do return __thx_Iterators.unzip3(it:iterator()) end;
end
__thx_Iterables.unzip4 = function(it) 
  do return __thx_Iterators.unzip4(it:iterator()) end;
end
__thx_Iterables.unzip5 = function(it) 
  do return __thx_Iterators.unzip5(it:iterator()) end;
end
__thx_Iterables.zip = function(it1,it2) 
  do return __thx_Iterators.zip(it1:iterator(), it2:iterator()) end;
end
__thx_Iterables.zip3 = function(it1,it2,it3) 
  do return __thx_Iterators.zip3(it1:iterator(), it2:iterator(), it3:iterator()) end;
end
__thx_Iterables.zip4 = function(it1,it2,it3,it4) 
  do return __thx_Iterators.zip4(it1:iterator(), it2:iterator(), it3:iterator(), it4:iterator()) end;
end
__thx_Iterables.zip5 = function(it1,it2,it3,it4,it5) 
  do return __thx_Iterators.zip5(it1:iterator(), it2:iterator(), it3:iterator(), it4:iterator(), it5:iterator()) end;
end

__thx_Iterators.new = {}
__thx_Iterators.__name__ = "thx.Iterators"
__thx_Iterators.all = function(it,predicate) 
  local element = it;
  while (element:hasNext()) do _hx_do_first_1 = false;
    
    local element = element:next();
    if (not predicate(element)) then 
      do return false end;
    end;
  end;
  do return true end;
end
__thx_Iterators.any = function(it,predicate) 
  local element = it;
  while (element:hasNext()) do _hx_do_first_1 = false;
    
    local element = element:next();
    if (predicate(element)) then 
      do return true end;
    end;
  end;
  do return false end;
end
__thx_Iterators.equals = function(a,b,equality) 
  if (nil == equality) then 
    equality = __thx_Functions.equality;
  end;
  local ae;
  local be;
  local an;
  local bn;
  while (true) do _hx_do_first_1 = false;
    
    an = a:hasNext();
    bn = b:hasNext();
    if (not an and not bn) then 
      do return true end;
    end;
    if (not an or not bn) then 
      do return false end;
    end;
    if (not equality(a:next(), b:next())) then 
      do return false end;
    end;
  end;
end
__thx_Iterators.get = function(it,index) 
  local pos = 0;
  local i = it;
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    pos = pos + 1;
    if ((pos - 1) == index) then 
      do return i end;
    end;
  end;
  do return nil end;
end
__thx_Iterators.getOption = function(it,index) 
  local value = __thx_Iterators.get(it, index);
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Iterators.eachPair = function(it,handler) 
  __thx_Arrays.eachPair(__thx_Iterators.toArray(it), handler);
end
__thx_Iterators.filter = function(it,predicate) 
  do return __thx_Iterators.reduce(it, function(acc,element) 
    if (predicate(element)) then 
      acc:push(element);
    end;
    do return acc end;
  end, _hx_tab_array({}, 0)) end;
end
__thx_Iterators.find = function(it,f) 
  local element = it;
  while (element:hasNext()) do _hx_do_first_1 = false;
    
    local element = element:next();
    if (f(element)) then 
      do return element end;
    end;
  end;
  do return nil end;
end
__thx_Iterators.findOption = function(it,f) 
  local value = __thx_Iterators.find(it, f);
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Iterators.first = function(it) 
  if (it:hasNext()) then 
    do return it:next() end;
  else
    do return nil end;
  end;
end
__thx_Iterators.hasElements = function(it) 
  do return it:hasNext() end;
end
__thx_Iterators.indexOf = function(it,element) 
  local pos = 0;
  local v = it;
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    if (element == v) then 
      do return pos end;
    end;
    pos = pos + 1;
  end;
  do return -1 end;
end
__thx_Iterators.isEmpty = function(it) 
  do return not it:hasNext() end;
end
__thx_Iterators.isIterator = function(v) 
  local fields = (function() 
    local _hx_1
    if (Reflect.isObject(v) and (nil == Type.getClass(v))) then 
    _hx_1 = Reflect.fields(v); else 
    _hx_1 = Type.getInstanceFields(Type.getClass(v)); end
    return _hx_1
  end )();
  if (not Lambda.has(fields, "next") or not Lambda.has(fields, "hasNext")) then 
    do return false end;
  end;
  if (Reflect.isFunction(Reflect.field(v, "next"))) then 
    do return Reflect.isFunction(Reflect.field(v, "hasNext")) end;
  else
    do return false end;
  end;
end
__thx_Iterators.last = function(it) 
  local buf = nil;
  while (it:hasNext()) do _hx_do_first_1 = false;
    
    buf = it:next();
  end;
  do return buf end;
end
__thx_Iterators.forEach = function(it,proc) 
  while (it:hasNext()) do _hx_do_first_1 = false;
    
    proc(it:next());
  end;
end
__thx_Iterators.map = function(it,f) 
  local acc = _hx_tab_array({}, 0);
  local v = it;
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    acc:push(f(v));
  end;
  do return acc end;
end
__thx_Iterators.fmap = function(it,f) 
  do return __thx_MapIterator.new(it, f) end;
end
__thx_Iterators.mapi = function(it,f) 
  local acc = _hx_tab_array({}, 0);
  local i = 0;
  local v = it;
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    i = i + 1;
    acc:push(f(v, i - 1));
  end;
  do return acc end;
end
__thx_Iterators.fmapi = function(it,f) 
  do return __thx_MapIIterator.new(it, f) end;
end
__thx_Iterators.order = function(it,sort) 
  local n = __thx_Iterators.toArray(it);
  n:sort(sort);
  do return n end;
end
__thx_Iterators.reduce = function(it,callback,initial) 
  local result = initial;
  while (it:hasNext()) do _hx_do_first_1 = false;
    
    result = callback(result, it:next());
  end;
  do return result end;
end
__thx_Iterators.reducei = function(it,callback,initial) 
  __thx_Iterators.mapi(it, function(v,i) 
    initial = callback(initial, v, i);
  end);
  do return initial end;
end
__thx_Iterators.foldLeft = function(it,zero,f) 
  do return __thx_Iterators.reduce(it, f, zero) end;
end
__thx_Iterators.foldMap = function(it,f,m) 
  local _e = m;
  local tmp = function(a0,a1) 
    do return __thx__Monoid_Monoid_Impl_.append(_e, a0, a1) end;
  end;
  do return __thx_Iterators.foldLeft(__thx_Iterators.fmap(it, f), __thx__Monoid_Monoid_Impl_.get_zero(m), tmp) end;
end
__thx_Iterators.takeUntil = function(it,f) 
  local out = _hx_tab_array({}, 0);
  local v = it;
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    if (f(v)) then 
      out:push(v);
    else
      break;
    end;
  end;
  do return out end;
end
__thx_Iterators.dropUntil = function(it,f) 
  local done = false;
  local out = _hx_tab_array({}, 0);
  local v = it;
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    if (not done) then 
      if (not f(v)) then 
        done = true;
        out:push(v);
      end;
    else
      out:push(v);
    end;
  end;
  do return out end;
end
__thx_Iterators.toArray = function(it) 
  local elements = _hx_tab_array({}, 0);
  local element = it;
  while (element:hasNext()) do _hx_do_first_1 = false;
    
    local element = element:next();
    elements:push(element);
  end;
  do return elements end;
end
__thx_Iterators.unzip = function(it) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  __thx_Iterators.forEach(it, function(t) 
    a1:push(t._0);
    a2:push(t._1);
  end);
  do return _hx_o({__fields__={_0=true,_1=true},_0=a1,_1=a2}) end;
end
__thx_Iterators.unzip3 = function(it) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local a3 = _hx_tab_array({}, 0);
  __thx_Iterators.forEach(it, function(t) 
    a1:push(t._0);
    a2:push(t._1);
    a3:push(t._2);
  end);
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=a1,_1=a2,_2=a3}) end;
end
__thx_Iterators.unzip4 = function(it) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local a3 = _hx_tab_array({}, 0);
  local a4 = _hx_tab_array({}, 0);
  __thx_Iterators.forEach(it, function(t) 
    a1:push(t._0);
    a2:push(t._1);
    a3:push(t._2);
    a4:push(t._3);
  end);
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=a1,_1=a2,_2=a3,_3=a4}) end;
end
__thx_Iterators.unzip5 = function(it) 
  local a1 = _hx_tab_array({}, 0);
  local a2 = _hx_tab_array({}, 0);
  local a3 = _hx_tab_array({}, 0);
  local a4 = _hx_tab_array({}, 0);
  local a5 = _hx_tab_array({}, 0);
  __thx_Iterators.forEach(it, function(t) 
    a1:push(t._0);
    a2:push(t._1);
    a3:push(t._2);
    a4:push(t._3);
    a5:push(t._4);
  end);
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=a1,_1=a2,_2=a3,_3=a4,_4=a5}) end;
end
__thx_Iterators.zip = function(it1,it2) 
  local array = _hx_tab_array({}, 0);
  while (it1:hasNext() and it2:hasNext()) do _hx_do_first_1 = false;
    
    array:push(_hx_o({__fields__={_0=true,_1=true},_0=it1:next(),_1=it2:next()}));
  end;
  do return array end;
end
__thx_Iterators.zip3 = function(it1,it2,it3) 
  local array = _hx_tab_array({}, 0);
  while ((it1:hasNext() and it2:hasNext()) and it3:hasNext()) do _hx_do_first_1 = false;
    
    array:push(_hx_o({__fields__={_0=true,_1=true,_2=true},_0=it1:next(),_1=it2:next(),_2=it3:next()}));
  end;
  do return array end;
end
__thx_Iterators.zip4 = function(it1,it2,it3,it4) 
  local array = _hx_tab_array({}, 0);
  while (((it1:hasNext() and it2:hasNext()) and it3:hasNext()) and it4:hasNext()) do _hx_do_first_1 = false;
    
    array:push(_hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=it1:next(),_1=it2:next(),_2=it3:next(),_3=it4:next()}));
  end;
  do return array end;
end
__thx_Iterators.zip5 = function(it1,it2,it3,it4,it5) 
  local array = _hx_tab_array({}, 0);
  while ((((it1:hasNext() and it2:hasNext()) and it3:hasNext()) and it4:hasNext()) and it5:hasNext()) do _hx_do_first_1 = false;
    
    array:push(_hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=it1:next(),_1=it2:next(),_2=it3:next(),_3=it4:next(),_4=it5:next()}));
  end;
  do return array end;
end

__thx_MapIterator.new = function(base,f) 
  local self = _hx_new(__thx_MapIterator.prototype)
  __thx_MapIterator.super(self,base,f)
  return self
end
__thx_MapIterator.super = function(self,base,f) 
  self.base = base;
  self.f = f;
end
__thx_MapIterator.__name__ = "thx.MapIterator"
__thx_MapIterator.prototype = _hx_e();
__thx_MapIterator.prototype.base= nil;
__thx_MapIterator.prototype.f= nil;
__thx_MapIterator.prototype.next = function(self) 
  do return self.f(self.base:next()) end
end
__thx_MapIterator.prototype.hasNext = function(self) 
  do return self.base:hasNext() end
end

__thx_MapIterator.prototype.__class__ =  __thx_MapIterator

__thx_MapIIterator.new = function(base,f) 
  local self = _hx_new(__thx_MapIIterator.prototype)
  __thx_MapIIterator.super(self,base,f)
  return self
end
__thx_MapIIterator.super = function(self,base,f) 
  self.i = 0;
  self.base = base;
  self.f = f;
end
__thx_MapIIterator.__name__ = "thx.MapIIterator"
__thx_MapIIterator.prototype = _hx_e();
__thx_MapIIterator.prototype.base= nil;
__thx_MapIIterator.prototype.f= nil;
__thx_MapIIterator.prototype.i= nil;
__thx_MapIIterator.prototype.next = function(self) 
  local result = self.f(self.base:next(), self.i);
  self.i = self.i + 1;
  do return result end
end
__thx_MapIIterator.prototype.hasNext = function(self) 
  do return self.base:hasNext() end
end

__thx_MapIIterator.prototype.__class__ =  __thx_MapIIterator

__thx_Maps.new = {}
__thx_Maps.__name__ = "thx.Maps"
__thx_Maps.copyTo = function(src,dst) 
  local key = src:keys();
  while (key:hasNext()) do _hx_do_first_1 = false;
    
    local key = key:next();
    dst:set(key, src:get(key));
  end;
  do return dst end;
end
__thx_Maps.tuples = function(map) 
  do return __thx_Iterators.map(map:keys(), function(key) 
    do return _hx_o({__fields__={_0=true,_1=true},_0=key,_1=map:get(key)}) end;
  end) end;
end
__thx_Maps.mapValues = function(map,f,acc) 
  do return __thx_Maps.reduce(map, function(m,t) 
    m:set(t._0, f(t._1));
    do return m end;
  end, acc) end;
end
__thx_Maps.reduce = function(map,f,acc) 
  do return __thx_Arrays.reduce(__thx_Maps.tuples(map), f, acc) end;
end
__thx_Maps.values = function(map) 
  do return __thx_Iterators.map(map:keys(), function(key) 
    do return map:get(key) end;
  end) end;
end
__thx_Maps.fromArray = function(array,toKey,toVal) 
  do return __thx_Arrays.reduce(array, function(acc,curr) 
    local key = toKey(curr);
    local value = toVal(curr);
    local key = key;
    if (value == nil) then 
      acc.h[key] = __haxe_ds_StringMap.tnull;
    else
      acc.h[key] = value;
    end;
    do return acc end;
  end, __haxe_ds_StringMap.new()) end;
end
__thx_Maps.foldLeftWithKeys = function(map,f,acc) 
  do return __thx_Iterators.reduce(map:keys(), function(acc,k) 
    do return f(acc, k, map:get(k)) end;
  end, acc) end;
end
__thx_Maps.getOption = function(map,key) 
  local value = map:get(key);
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Maps.toObject = function(map) 
  do return __thx_Arrays.reduce(__thx_Maps.tuples(map), function(o,t) 
    o[t._0] = t._1;
    do return o end;
  end, _hx_e()) end;
end
__thx_Maps.getAlt = function(map,key,alt) 
  local v = map:get(key);
  if (nil == v) then 
    do return alt end;
  else
    do return v end;
  end;
end
__thx_Maps.getAltSet = function(map,key,alt) 
  local v = map:get(key);
  if (v ~= nil) then 
    do return v end;
  else
    map:set(key, alt);
    do return alt end;
  end;
end
__thx_Maps.isEmpty = function(map) 
  do return not map:iterator():hasNext() end;
end
__thx_Maps.isMap = function(v) 
  do return __lua_Boot.__instanceof(v, __haxe_IMap) end;
end
__thx_Maps.string = function(m) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Maps.tuples(m);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(Std.string(Std.string(__thx_Dynamics.string(i._0)) .. Std.string(" => ")) .. Std.string(__thx_Dynamics.string(i._1)));
  end;
  do return Std.string(Std.string("[") .. Std.string(_g:join(", "))) .. Std.string("]") end;
end
__thx_Maps.merge = function(dest,sources) 
  do return __thx_Arrays.reduce(sources, function(result,source) 
    do return __thx_Iterators.reduce(source:keys(), function(result,key) 
      result:set(key, source:get(key));
      do return result end;
    end, result) end;
  end, dest) end;
end

__thx__Monoid_Monoid_Impl_.new = {}
__thx__Monoid_Monoid_Impl_.__name__ = "thx._Monoid.Monoid_Impl_"
__thx__Monoid_Monoid_Impl_.get_semigroup = function(this1) 
  do return _hx_bind(this1,this1.append) end;
end
__thx__Monoid_Monoid_Impl_.get_zero = function(this1) 
  do return this1.zero end;
end
__thx__Monoid_Monoid_Impl_.append = function(this1,a0,a1) 
  do return this1:append(a0, a1) end;
end

__thx__Nel_Nel_Impl_.new = {}
__thx__Nel_Nel_Impl_.__name__ = "thx._Nel.Nel_Impl_"
__thx__Nel_Nel_Impl_.nel = function(hd,tl) 
  local _g = __thx__Nel_Nel_Impl_.fromArray(tl);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local nel = _g[2];
    do return __thx__Nel_Nel_Impl_.cons(hd, nel) end;
  elseif (tmp) == 1 then 
    do return __thx__Nel_Nel_Impl_.pure(hd) end; end;
end
__thx__Nel_Nel_Impl_.pure = function(a) 
  do return __thx_NonEmptyList.Single(a) end;
end
__thx__Nel_Nel_Impl_.cons = function(a,nl) 
  do return __thx_NonEmptyList.ConsNel(a, nl) end;
end
__thx__Nel_Nel_Impl_.fromArray = function(arr) 
  if (arr.length == 0) then 
    do return __haxe_ds_Option.None end;
  else
    local res = __thx_NonEmptyList.Single(arr[arr.length - 1]);
    local i = __thx_Ints.rangeIter(arr.length - 2, -1, -1);
    while (i:hasNext()) do _hx_do_first_1 = false;
      
      local i = i:next();
      res = __thx_NonEmptyList.ConsNel(arr[i], res);
    end;
    do return __haxe_ds_Option.Some(res) end;
  end;
end
__thx__Nel_Nel_Impl_.map = function(this1,f) 
  local fb = f;
  do return __thx__Nel_Nel_Impl_.flatMap(this1, function(v) 
    do return __thx__Nel_Nel_Impl_.pure(fb(v)) end;
  end) end;
end
__thx__Nel_Nel_Impl_.flatMap = function(this1,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return f(x) end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return __thx__Nel_Nel_Impl_.append(f(x), __thx__Nel_Nel_Impl_.flatMap(xs, f)) end; end;
end
__thx__Nel_Nel_Impl_.fold = function(this1,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return x end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return f(x, __thx__Nel_Nel_Impl_.fold(xs, f)) end; end;
end
__thx__Nel_Nel_Impl_.append = function(this1,nel) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return __thx_NonEmptyList.ConsNel(x, nel) end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return __thx_NonEmptyList.ConsNel(x, __thx__Nel_Nel_Impl_.append(xs, nel)) end; end;
end
__thx__Nel_Nel_Impl_.concat = function(this1,xs) 
  local _g = __thx__Nel_Nel_Impl_.fromArray(xs);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local other = _g[2];
    do return __thx__Nel_Nel_Impl_.append(this1, other) end;
  elseif (tmp) == 1 then 
    do return this1 end; end;
end
__thx__Nel_Nel_Impl_.head = function(this1) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return x end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return x end; end;
end
__thx__Nel_Nel_Impl_.tail = function(this1) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return _hx_tab_array({}, 0) end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return __thx__Nel_Nel_Impl_.toArray(xs) end; end;
end
__thx__Nel_Nel_Impl_.init = function(this1) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return _hx_tab_array({}, 0) end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return _hx_tab_array({[0]=x}, 1):concat(__thx__Nel_Nel_Impl_.init(xs)) end; end;
end
__thx__Nel_Nel_Impl_.last = function(this1) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return x end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return __thx__Nel_Nel_Impl_.last(xs) end; end;
end
__thx__Nel_Nel_Impl_.push = function(this1,a) 
  do return __thx__Nel_Nel_Impl_.append(this1, __thx_NonEmptyList.Single(a)) end;
end
__thx__Nel_Nel_Impl_.pop = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=__thx__Nel_Nel_Impl_.last(this1),_1=__thx__Nel_Nel_Impl_.init(this1)}) end;
end
__thx__Nel_Nel_Impl_.unshift = function(this1,a) 
  do return __thx_NonEmptyList.ConsNel(a, this1) end;
end
__thx__Nel_Nel_Impl_.shift = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=__thx__Nel_Nel_Impl_.head(this1),_1=__thx__Nel_Nel_Impl_.tail(this1)}) end;
end
__thx__Nel_Nel_Impl_.toArray = function(this1) 
  local go = nil;
  go = function(acc,xs) 
    local go1 = xs[1];
    if (go1) == 0 then 
      local x = xs[2];
      do return __thx_Arrays.append(acc, x) end;
    elseif (go1) == 1 then 
      local x = xs[2];
      local xs = xs[3];
      do return go(__thx_Arrays.append(acc, x), xs) end; end;
  end;
  do return go(_hx_tab_array({}, 0), this1) end;
end
__thx__Nel_Nel_Impl_.intersperse = function(this1,a) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local x = this1[2];
    do return __thx_NonEmptyList.Single(x) end;
  elseif (tmp) == 1 then 
    local x = this1[2];
    local xs = this1[3];
    do return __thx_NonEmptyList.ConsNel(x, __thx_NonEmptyList.ConsNel(a, __thx__Nel_Nel_Impl_.intersperse(xs, a))) end; end;
end
__thx__Nel_Nel_Impl_.semigroup = function() 
  do return function(nl,nr) 
    do return __thx__Nel_Nel_Impl_.append(nl, nr) end;
  end end;
end
_hxClasses["thx.NonEmptyList"] = { __ename__ = "thx.NonEmptyList", __constructs__ = _hx_tab_array({[0]="Single","ConsNel"},2)}
__thx_NonEmptyList = _hxClasses["thx.NonEmptyList"];
__thx_NonEmptyList.Single = function(x) local _x = _hx_tab_array({[0]="Single",0,x,__enum__=__thx_NonEmptyList}, 3); return _x; end 
__thx_NonEmptyList.ConsNel = function(x,xs) local _x = _hx_tab_array({[0]="ConsNel",1,x,xs,__enum__=__thx_NonEmptyList}, 4); return _x; end 
_hxClasses["thx.Nil"] = { __ename__ = "thx.Nil", __constructs__ = _hx_tab_array({[0]="nil"},1)}
__thx_Nil = _hxClasses["thx.Nil"];
__thx_Nil["nil"] = _hx_tab_array({[0]="nil",0,__enum__ = __thx_Nil},2)


__thx_Objects.new = {}
__thx_Objects.__name__ = "thx.Objects"
__thx_Objects.compare = function(a,b) 
  local fields = Reflect.fields(a);
  local v = __thx_Arrays.compare(fields, Reflect.fields(b));
  if (v ~= 0) then 
    do return v end;
  end;
  local _g = 0;
  while (_g < fields.length) do _hx_do_first_1 = false;
    
    local field = fields[_g];
    _g = _g + 1;
    v = __thx_Dynamics.compare(Reflect.field(a, field), Reflect.field(b, field));
    if (v ~= 0) then 
      do return v end;
    end;
  end;
  do return 0 end;
end
__thx_Objects.isEmpty = function(o) 
  do return Reflect.fields(o).length == 0 end;
end
__thx_Objects.exists = function(o,name) 
  local o = o;
  if ((_G.type(o) == "function") and not ((function() 
    local _hx_1
    if (_G.type(o) ~= "table") then 
    _hx_1 = false; else 
    _hx_1 = o.__name__; end
    return _hx_1
  end )() or (function() 
    local _hx_2
    if (_G.type(o) ~= "table") then 
    _hx_2 = false; else 
    _hx_2 = o.__ename__; end
    return _hx_2
  end )())) then 
    do return false end;
  else
    if ((_G.type(o) == "string") and ((String.prototype[name] ~= nil) or (name == "length"))) then 
      do return true end;
    else
      if (o.__fields__ ~= nil) then 
        do return o.__fields__[name] ~= nil end;
      else
        do return o[name] ~= nil end;
      end;
    end;
  end;
end
__thx_Objects.fields = function(o) 
  do return Reflect.fields(o) end;
end
__thx_Objects.deflate = function(o,flattenArrays) 
  if (flattenArrays == nil) then 
    flattenArrays = true;
  end;
  local f = nil;
  f = function(v) 
    if (__lua_Boot.__instanceof(v, Array)) then 
      if (flattenArrays) then 
        if (_hx_wrap_if_string_field(v,'length') == 0) then 
          do return __thx_Either.Left(_hx_tab_array({}, 0)) end;
        else
          local a = v;
          do return __thx_Either.Right(__thx_Arrays.reducei(a, function(map,value,i) 
            local _g = f(value);
            local f = _g[1];
            if (f) == 0 then 
              local v = _g[2];
              local key = Std.string("") .. Std.string(i);
              if (v == nil) then 
                map.h[key] = __haxe_ds_StringMap.tnull;
              else
                map.h[key] = v;
              end;
            elseif (f) == 1 then 
              local m = _g[2];
              local k = m:keys();
              while (k:hasNext()) do _hx_do_first_1 = false;
                
                local k = k:next();
                local ret = m.h[k];
                local key = Std.string(Std.string(Std.string("") .. Std.string(i)) .. Std.string(".")) .. Std.string(k);
                local value = (function() 
                  local _hx_1
                  if (ret == __haxe_ds_StringMap.tnull) then 
                  _hx_1 = nil; else 
                  _hx_1 = ret; end
                  return _hx_1
                end )();
                if (value == nil) then 
                  map.h[key] = __haxe_ds_StringMap.tnull;
                else
                  map.h[key] = value;
                end;
              end; end;
            do return map end;
          end, __haxe_ds_StringMap.new())) end;
        end;
      else
        do return __thx_Either.Left(v) end;
      end;
    else
      if (Reflect.isObject(v) and (nil == Type.getClass(v))) then 
        do return __thx_Either.Right(__thx_Arrays.reduce(Reflect.fields(v), function(map,key) 
          local _g = f(Reflect.field(v, key));
          local f = _g[1];
          if (f) == 0 then 
            local v = _g[2];
            local key = Std.string("") .. Std.string(key);
            if (v == nil) then 
              map.h[key] = __haxe_ds_StringMap.tnull;
            else
              map.h[key] = v;
            end;
          elseif (f) == 1 then 
            local m = _g[2];
            if (not m:iterator():hasNext()) then 
              local key = Std.string("") .. Std.string(key);
              local value = _hx_e();
              if (value == nil) then 
                map.h[key] = __haxe_ds_StringMap.tnull;
              else
                map.h[key] = value;
              end;
            else
              local k = m:keys();
              while (k:hasNext()) do _hx_do_first_1 = false;
                
                local k = k:next();
                local ret = m.h[k];
                local key = Std.string(Std.string(Std.string("") .. Std.string(key)) .. Std.string(".")) .. Std.string(k);
                local value = (function() 
                  local _hx_2
                  if (ret == __haxe_ds_StringMap.tnull) then 
                  _hx_2 = nil; else 
                  _hx_2 = ret; end
                  return _hx_2
                end )();
                if (value == nil) then 
                  map.h[key] = __haxe_ds_StringMap.tnull;
                else
                  map.h[key] = value;
                end;
              end;
            end; end;
          do return map end;
        end, __haxe_ds_StringMap.new())) end;
      else
        do return __thx_Either.Left(v) end;
      end;
    end;
  end;
  local _g = f(o);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local v = _g[2];
    do return v end;
  elseif (tmp) == 1 then 
    local m = _g[2];
    do return __thx_Maps.toObject(m) end; end;
end
__thx_Objects.inflate = function(o) 
  do return __thx_Arrays.reduce(Reflect.fields(o), function(acc,field) 
    do return __thx_Objects.setPath(acc, field, Reflect.field(o, field)) end;
  end, _hx_e()) end;
end
__thx_Objects.combine = function(first,second) 
  do return __thx_Objects.shallowCombine(first, second) end;
end
__thx_Objects.shallowCombine = function(first,second) 
  local to = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(first);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local field = _g1[_g];
    _g = _g + 1;
    to[field] = Reflect.field(first, field);
  end;
  local _g = 0;
  local _g1 = Reflect.fields(second);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local field = _g1[_g];
    _g = _g + 1;
    to[field] = Reflect.field(second, field);
  end;
  do return to end;
end
__thx_Objects.deepCombine = function(first,second) 
  do return __thx_Objects.copyTo(second, first, true) end;
end
__thx_Objects.assign = function(to,from,replacef) 
  if (nil == replacef) then 
    replacef = function(field,oldv,newv) 
      do return newv end;
    end;
  end;
  local _g = 0;
  local _g1 = Reflect.fields(from);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local field = _g1[_g];
    _g = _g + 1;
    local newv = Reflect.field(from, field);
    local o = to;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "function") and not ((function() 
        local _hx_2
        if (_G.type(o) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = o.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (_G.type(o) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = o.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      to[field] = replacef(field, Reflect.field(to, field), newv);
    else
      to[field] = newv;
    end;
  end;
  do return to end;
end
__thx_Objects.copyTo = function(src,dst,cloneInstances) 
  if (cloneInstances == nil) then 
    cloneInstances = false;
  end;
  local _g = 0;
  local _g1 = Reflect.fields(src);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local field = _g1[_g];
    _g = _g + 1;
    local sv = __thx_Dynamics.clone(Reflect.field(src, field), cloneInstances);
    local dv = Reflect.field(dst, field);
    local tmp;
    local v = sv;
    if (Reflect.isObject(v) and (nil == Type.getClass(v))) then 
      local v = dv;
      tmp = Reflect.isObject(v) and (nil == Type.getClass(v));
    else
      tmp = false;
    end;
    if (tmp) then 
      __thx_Objects.copyTo(sv, dv);
    else
      dst[field] = sv;
    end;
  end;
  do return dst end;
end
__thx_Objects.clone = function(src,cloneInstances) 
  if (cloneInstances == nil) then 
    cloneInstances = false;
  end;
  do return __thx_Dynamics.clone(src, cloneInstances) end;
end
__thx_Objects.toMap = function(o) 
  do return __thx_Arrays.reduce(__thx_Objects.tuples(o), function(map,t) 
    local key = t._0;
    local value = t._1;
    if (value == nil) then 
      map.h[key] = __haxe_ds_StringMap.tnull;
    else
      map.h[key] = value;
    end;
    do return map end;
  end, __haxe_ds_StringMap.new()) end;
end
__thx_Objects.size = function(o) 
  do return Reflect.fields(o).length end;
end
__thx_Objects.string = function(o) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = Reflect.fields(o);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    local v = Reflect.field(o, i);
    local s = (function() 
      local _hx_1
      if (__lua_Boot.__instanceof(v, String)) then 
      _hx_1 = __thx_Strings.quote(v); else 
      _hx_1 = __thx_Dynamics.string(v); end
      return _hx_1
    end )();
    _g:push(Std.string(Std.string(Std.string("") .. Std.string(i)) .. Std.string(" : ")) .. Std.string(s));
  end;
  do return Std.string(Std.string("{") .. Std.string(_g:join(", "))) .. Std.string("}") end;
end
__thx_Objects.stringImpl = function(o,cache) 
end
__thx_Objects.values = function(o) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = Reflect.fields(o);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(Reflect.field(o, i));
  end;
  do return _g end;
end
__thx_Objects.tuples = function(o) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = Reflect.fields(o);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(_hx_o({__fields__={_0=true,_1=true},_0=i,_1=Reflect.field(o, i)}));
  end;
  do return _g end;
end
__thx_Objects.hasPath = function(o,path) 
  path = EReg.new("\\[(\\d+)\\]", "g"):replace(path, ".$1");
  local paths = String.prototype.split(path, ".");
  local current = o;
  local _g = 0;
  while (_g < paths.length) do _hx_do_first_1 = false;
    
    local currentPath = paths[_g];
    _g = _g + 1;
    if (__thx_Strings.DIGITS:match(currentPath)) then 
      local index = Std.parseInt(currentPath);
      local value = current;
      local arr = (function() 
        local _hx_1
        if (__lua_Boot.__instanceof(value, Array)) then 
        _hx_1 = value; else 
        _hx_1 = nil; end
        return _hx_1
      end )();
      if ((nil == arr) or (arr.length <= index)) then 
        do return false end;
      end;
      current = arr[index];
    else
      if ((function() 
        local _hx_2
        if ((_G.type(current) == "function") and not ((function() 
          local _hx_3
          if (_G.type(current) ~= "table") then 
          _hx_3 = false; else 
          _hx_3 = current.__name__; end
          return _hx_3
        end )() or (function() 
          local _hx_4
          if (_G.type(current) ~= "table") then 
          _hx_4 = false; else 
          _hx_4 = current.__ename__; end
          return _hx_4
        end )())) then 
        _hx_2 = false; elseif ((_G.type(current) == "string") and ((String.prototype[currentPath] ~= nil) or (currentPath == "length"))) then 
        _hx_2 = true; elseif (current.__fields__ ~= nil) then 
        _hx_2 = current.__fields__[currentPath] ~= nil; else 
        _hx_2 = current[currentPath] ~= nil; end
        return _hx_2
      end )()) then 
        current = Reflect.field(current, currentPath);
      else
        do return false end;
      end;
    end;
  end;
  do return true end;
end
__thx_Objects.hasPathValue = function(o,path) 
  do return __thx_Objects.getPath(o, path) ~= nil end;
end
__thx_Objects.getPath = function(o,path) 
  path = EReg.new("\\[(\\d+)\\]", "g"):replace(path, ".$1");
  local paths = String.prototype.split(path, ".");
  local current = o;
  local _g = 0;
  while (_g < paths.length) do _hx_do_first_1 = false;
    
    local currentPath = paths[_g];
    _g = _g + 1;
    if (current == nil) then 
      do return nil end;
    else
      if (__thx_Strings.DIGITS:match(currentPath)) then 
        local index = Std.parseInt(currentPath);
        local value = current;
        local arr = (function() 
          local _hx_1
          if (__lua_Boot.__instanceof(value, Array)) then 
          _hx_1 = value; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
        if (nil == arr) then 
          do return nil end;
        end;
        current = arr[index];
      else
        if ((function() 
          local _hx_2
          if ((_G.type(current) == "function") and not ((function() 
            local _hx_3
            if (_G.type(current) ~= "table") then 
            _hx_3 = false; else 
            _hx_3 = current.__name__; end
            return _hx_3
          end )() or (function() 
            local _hx_4
            if (_G.type(current) ~= "table") then 
            _hx_4 = false; else 
            _hx_4 = current.__ename__; end
            return _hx_4
          end )())) then 
          _hx_2 = false; elseif ((_G.type(current) == "string") and ((String.prototype[currentPath] ~= nil) or (currentPath == "length"))) then 
          _hx_2 = true; elseif (current.__fields__ ~= nil) then 
          _hx_2 = current.__fields__[currentPath] ~= nil; else 
          _hx_2 = current[currentPath] ~= nil; end
          return _hx_2
        end )()) then 
          current = Reflect.field(current, currentPath);
        else
          do return nil end;
        end;
      end;
    end;
  end;
  do return current end;
end
__thx_Objects.getPathOption = function(o,path) 
  local value = __thx_Objects.getPath(o, path);
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Objects.parsePath = function(o,path,parse) 
  local this1 = __thx_Options.toSuccessNel(__thx_Objects.getPathOption(o, path), Std.string("Object does not contain path ") .. Std.string(path));
  local tmp = this1[1];
  if (tmp) == 0 then 
    local a = this1[2];
    do return __thx_Either.Left(a) end;
  elseif (tmp) == 1 then 
    local b = this1[2];
    do return parse(b) end; end;
end
__thx_Objects.getPathOr = function(o,path,alt) 
  do return __thx_Options.getOrElse(__thx_Objects.getPathOption(o, path), alt) end;
end
__thx_Objects.setPath = function(o,path,val) 
  path = EReg.new("\\[(\\d+)\\]", "g"):replace(path, ".$1");
  local paths = String.prototype.split(path, ".");
  local current = o;
  local _g = 0;
  local _g1 = paths.length - 1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local currentPath = paths[i];
    local nextPath = paths[i + 1];
    if (__thx_Strings.DIGITS:match(currentPath) or (currentPath == "*")) then 
      local index = (function() 
        local _hx_1
        if (currentPath == "*") then 
        _hx_1 = current.length; else 
        _hx_1 = Std.parseInt(currentPath); end
        return _hx_1
      end )();
      if (current[index] == nil) then 
        if (__thx_Strings.DIGITS:match(nextPath) or (nextPath == "*")) then 
          current[index] = _hx_tab_array({}, 0);
        else
          current[index] = _hx_e();
        end;
      end;
      current = current[index];
    else
      if (not ((function() 
        local _hx_2
        if ((_G.type(current) == "function") and not ((function() 
          local _hx_3
          if (_G.type(current) ~= "table") then 
          _hx_3 = false; else 
          _hx_3 = current.__name__; end
          return _hx_3
        end )() or (function() 
          local _hx_4
          if (_G.type(current) ~= "table") then 
          _hx_4 = false; else 
          _hx_4 = current.__ename__; end
          return _hx_4
        end )())) then 
        _hx_2 = false; elseif ((_G.type(current) == "string") and ((String.prototype[currentPath] ~= nil) or (currentPath == "length"))) then 
        _hx_2 = true; elseif (current.__fields__ ~= nil) then 
        _hx_2 = current.__fields__[currentPath] ~= nil; else 
        _hx_2 = current[currentPath] ~= nil; end
        return _hx_2
      end )())) then 
        if (__thx_Strings.DIGITS:match(nextPath) or (nextPath == "*")) then 
          current[currentPath] = _hx_tab_array({}, 0);
        else
          current[currentPath] = _hx_e();
        end;
      end;
      current = Reflect.field(current, currentPath);
    end;
  end;
  local p = paths[paths.length - 1];
  if (__thx_Strings.DIGITS:match(p)) then 
    local index = Std.parseInt(p);
    current[index] = val;
  else
    if (p == "*") then 
      current:push(val);
    else
      current[p] = val;
    end;
  end;
  do return o end;
end
__thx_Objects.removePath = function(o,path) 
  path = EReg.new("\\[(\\d+)\\]", "g"):replace(path, ".$1");
  local paths = String.prototype.split(path, ".");
  local target = paths:pop();
  local _hx_status, _hx_result = pcall(function() 
  
      local sub = __thx_Arrays.reduce(paths, function(existing,nextPath) 
        if (nextPath == "*") then 
          do return existing:pop() end;
        else
          if (__thx_Strings.DIGITS:match(nextPath)) then 
            local current = existing;
            local index = Std.parseInt(nextPath);
            do return current[index] end;
          else
            do return Reflect.field(existing, nextPath) end;
          end;
        end;
      end, o);
      if (nil ~= sub) then 
        Reflect.deleteField(sub, target);
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return o end;
end
__thx_Objects.normalizePath = function(path) 
  do return EReg.new("\\[(\\d+)\\]", "g"):replace(path, ".$1") end;
end

__thx_Options.new = {}
__thx_Options.__name__ = "thx.Options"
__thx_Options.ofValue = function(value) 
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Options.maybe = function(value) 
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Options.equals = function(a,b,eq) 
  local tmp = a[1];
  if (tmp) == 0 then 
    if (b[1] == 0) then 
      local b = b[2];
      local a = a[2];
      if (nil == eq) then 
        eq = function(a,b) 
          do return a == b end;
        end;
      end;
      do return eq(a, b) end;
    else
      do return false end;
    end;
  elseif (tmp) == 1 then 
    if (b[1] == 1) then 
      do return true end;
    else
      do return false end;
    end; end;
end
__thx_Options.equalsValue = function(a,b,eq) 
  do return __thx_Options.equals(a, (function() 
    local _hx_1
    if (nil == b) then 
    _hx_1 = __haxe_ds_Option.None; else 
    _hx_1 = __haxe_ds_Option.Some(b); end
    return _hx_1
  end )(), eq) end;
end
__thx_Options.map = function(option,callback) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __haxe_ds_Option.Some(callback(v)) end;
  elseif (tmp) == 1 then 
    do return __haxe_ds_Option.None end; end;
end
__thx_Options.ap = function(option,fopt) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __thx_Options.map(fopt, function(f) 
      do return f(v) end;
    end) end;
  elseif (tmp) == 1 then 
    do return __haxe_ds_Option.None end; end;
end
__thx_Options.flatMap = function(option,callback) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return callback(v) end;
  elseif (tmp) == 1 then 
    do return __haxe_ds_Option.None end; end;
end
__thx_Options.join = function(option) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return v end;
  elseif (tmp) == 1 then 
    do return __haxe_ds_Option.None end; end;
end
__thx_Options.cata = function(option,ifNone,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return f(v) end;
  elseif (tmp) == 1 then 
    do return ifNone end; end;
end
__thx_Options.cataf = function(option,ifNone,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return f(v) end;
  elseif (tmp) == 1 then 
    do return ifNone() end; end;
end
__thx_Options.foldLeft = function(option,b,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return f(b, v) end;
  elseif (tmp) == 1 then 
    do return b end; end;
end
__thx_Options.foldLeftf = function(option,b,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return f(b(), v) end;
  elseif (tmp) == 1 then 
    do return b() end; end;
end
__thx_Options.foldMap = function(option,f,m) 
  local _e = m;
  local tmp = function(a0,a1) 
    do return __thx__Monoid_Monoid_Impl_.append(_e, a0, a1) end;
  end;
  do return __thx_Options.foldLeft(__thx_Options.map(option, f), __thx__Monoid_Monoid_Impl_.get_zero(m), tmp) end;
end
__thx_Options.filter = function(option,f) 
  if (option[1] == 0) then 
    local v = option[2];
    if (f(v)) then 
      do return option end;
    else
      do return __haxe_ds_Option.None end;
    end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__thx_Options.toArray = function(option) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return _hx_tab_array({[0]=v}, 1) end;
  elseif (tmp) == 1 then 
    do return _hx_tab_array({}, 0) end; end;
end
__thx_Options.toBool = function(option) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local _g = option[2];
    do return true end;
  elseif (tmp) == 1 then 
    do return false end; end;
end
__thx_Options.isNone = function(option) 
  do return not __thx_Options.toBool(option) end;
end
__thx_Options.toOption = function(value) 
  if (nil == value) then 
    do return __haxe_ds_Option.None end;
  else
    do return __haxe_ds_Option.Some(value) end;
  end;
end
__thx_Options.get = function(option) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return v end;
  elseif (tmp) == 1 then 
    do return nil end; end;
end
__thx_Options.getOrElse = function(option,alt) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return v end;
  elseif (tmp) == 1 then 
    do return alt end; end;
end
__thx_Options.getOrElseF = function(option,alt) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return v end;
  elseif (tmp) == 1 then 
    do return alt() end; end;
end
__thx_Options.getOrThrow = function(option,err,posInfo) 
  if (nil == err) then 
    err = __thx_Error.new("Could not extract value from option", nil, posInfo);
  end;
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return v end;
  elseif (tmp) == 1 then 
    _G.error(__haxe_Exception.thrown(err),0); end;
end
__thx_Options.getOrFail = function(option,msg,posInfo) 
  do return __thx_Options.getOrThrow(option, __thx_Error.new(msg, nil, posInfo), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/Options.hx",lineNumber=208,className="thx.Options",methodName="getOrFail"})) end;
end
__thx_Options.orElse = function(option,alt) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local _g = option[2];
    do return option end;
  elseif (tmp) == 1 then 
    do return alt end; end;
end
__thx_Options.orElseF = function(option,alt) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local _g = option[2];
    do return option end;
  elseif (tmp) == 1 then 
    do return alt() end; end;
end
__thx_Options.all = function(option,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return f(v) end;
  elseif (tmp) == 1 then 
    do return true end; end;
end
__thx_Options.any = function(option,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return f(v) end;
  elseif (tmp) == 1 then 
    do return false end; end;
end
__thx_Options.traverseValidation = function(option,f) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __thx__Validation_Validation_Impl_.map(f(v), function(v) 
      do return __haxe_ds_Option.Some(v) end;
    end) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Right(__haxe_ds_Option.None) end; end;
end
__thx_Options.toSuccess = function(option,error) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __thx_Either.Right(v) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Left(error) end; end;
end
__thx_Options.toLazySuccess = function(option,error) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __thx_Either.Right(v) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Left(error()) end; end;
end
__thx_Options.toSuccessNel = function(option,error) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __thx_Either.Right(v) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Left(__thx__Nel_Nel_Impl_.pure(error)) end; end;
end
__thx_Options.toLazySuccessNel = function(option,error) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local v = option[2];
    do return __thx_Either.Right(v) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Left(__thx__Nel_Nel_Impl_.pure(error())) end; end;
end
__thx_Options.toFailure = function(error,value) 
  local tmp = error[1];
  if (tmp) == 0 then 
    local e = error[2];
    do return __thx_Either.Left(e) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Right(value) end; end;
end
__thx_Options.toFailureNel = function(error,value) 
  local tmp = error[1];
  if (tmp) == 0 then 
    local e = error[2];
    do return __thx_Either.Left(__thx__Nel_Nel_Impl_.pure(e)) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Right(value) end; end;
end
__thx_Options.toRight = function(opt,left) 
  local tmp = opt[1];
  if (tmp) == 0 then 
    local r = opt[2];
    do return __thx_Either.Right(r) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Left(left) end; end;
end
__thx_Options.toLazyRight = function(opt,left) 
  local tmp = opt[1];
  if (tmp) == 0 then 
    local r = opt[2];
    do return __thx_Either.Right(r) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Left(left()) end; end;
end
__thx_Options.toLeft = function(opt,right) 
  local tmp = opt[1];
  if (tmp) == 0 then 
    local l = opt[2];
    do return __thx_Either.Left(l) end;
  elseif (tmp) == 1 then 
    do return __thx_Either.Right(right) end; end;
end
__thx_Options.each = function(o,f) 
  local tmp = o[1];
  if (tmp) == 0 then 
    local v = o[2];
    f(v);
    do return o end;
  elseif (tmp) == 1 then 
    do return o end; end;
end
__thx_Options.alt2 = function(a,b) 
  if (a[1] == 1) then 
    local r = b;
    do return r end;
  else
    local l = a;
    do return l end;
  end;
end
__thx_Options.alt3 = function(a,b,c) 
  local a1;
  if (a[1] == 1) then 
    local r = b;
    a1 = r;
  else
    local l = a;
    a1 = l;
  end;
  if (a1[1] == 1) then 
    local r = c;
    do return r end;
  else
    local l = a1;
    do return l end;
  end;
end
__thx_Options.alt4 = function(a,b,c,d) 
  local a1;
  if (a[1] == 1) then 
    local r = b;
    a1 = r;
  else
    local l = a;
    a1 = l;
  end;
  local a;
  if (a1[1] == 1) then 
    local r = c;
    a = r;
  else
    local l = a1;
    a = l;
  end;
  if (a[1] == 1) then 
    local r = d;
    do return r end;
  else
    local l = a;
    do return l end;
  end;
end
__thx_Options.alts = function(as) 
  do return __thx_Arrays.reduce(as, __thx_Options.alt2, __haxe_ds_Option.None) end;
end
__thx_Options.altsF = function(fs) 
  do return __thx_Arrays.reduce(fs, __thx_Options.orElseF, __haxe_ds_Option.None) end;
end
__thx_Options.ap2 = function(f,v1,v2) 
  do return __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(f))) end;
end
__thx_Options.ap3 = function(f,v1,v2,v3) 
  local f = f;
  do return __thx_Options.ap(v3, __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)))) end;
end
__thx_Options.ap4 = function(f,v1,v2,v3,v4) 
  local f = f;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(v4, __thx_Options.ap(v3, __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end))))) end;
end
__thx_Options.ap5 = function(f,v1,v2,v3,v4,v5) 
  local f = f;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(v5, __thx_Options.ap(v4, __thx_Options.ap(v3, __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)))))) end;
end
__thx_Options.ap6 = function(f,v1,v2,v3,v4,v5,v6) 
  local f = f;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(v6, __thx_Options.ap(v5, __thx_Options.ap(v4, __thx_Options.ap(v3, __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end))))))) end;
end
__thx_Options.ap7 = function(f,v1,v2,v3,v4,v5,v6,v7) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(v7, __thx_Options.ap(v6, __thx_Options.ap(v5, __thx_Options.ap(v4, __thx_Options.ap(v3, __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)))))))) end;
end
__thx_Options.ap8 = function(f,v1,v2,v3,v4,v5,v6,v7,v8) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(v8, __thx_Options.ap(v7, __thx_Options.ap(v6, __thx_Options.ap(v5, __thx_Options.ap(v4, __thx_Options.ap(v3, __thx_Options.ap(v2, __thx_Options.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end))))))))) end;
end
__thx_Options.combine = function(a,b) 
  do return __thx_Options.ap(b, __thx_Options.map(a, __thx_Functions2.curry(__thx__Tuple_Tuple2_Impl_.of))) end;
end
__thx_Options.combine2 = function(a,b) 
  do return __thx_Options.ap(b, __thx_Options.map(a, __thx_Functions2.curry(__thx__Tuple_Tuple2_Impl_.of))) end;
end
__thx_Options.combine3 = function(a,b,c) 
  local f = __thx__Tuple_Tuple3_Impl_.of;
  do return __thx_Options.ap(c, __thx_Options.ap(b, __thx_Options.map(a, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)))) end;
end
__thx_Options.combine4 = function(a,b,c,d) 
  local f = __thx__Tuple_Tuple4_Impl_.of;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(d, __thx_Options.ap(c, __thx_Options.ap(b, __thx_Options.map(a, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end))))) end;
end
__thx_Options.combine5 = function(a,b,c,d,e) 
  local f = __thx__Tuple_Tuple5_Impl_.of;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(e, __thx_Options.ap(d, __thx_Options.ap(c, __thx_Options.ap(b, __thx_Options.map(a, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)))))) end;
end
__thx_Options.combine6 = function(a,b,c,d,e,f) 
  local f1 = __thx__Tuple_Tuple6_Impl_.of;
  local f2 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f2(a, b, c, d, e) end;
    end end;
  end;
  local f2 = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx_Options.ap(f, __thx_Options.ap(e, __thx_Options.ap(d, __thx_Options.ap(c, __thx_Options.ap(b, __thx_Options.map(a, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f2(a, b, c) end;
    end end;
  end))))))) end;
end
__thx_Options.spread2 = function(v,f) 
  do return __thx_Options.map(v, function(t) 
    do return f(t._0, t._1) end;
  end) end;
end
__thx_Options.spread = function(v,f) 
  local f = f;
  do return __thx_Options.map(v, function(t) 
    do return f(t._0, t._1) end;
  end) end;
end
__thx_Options.spread3 = function(v,f) 
  do return __thx_Options.map(v, function(t) 
    do return f(t._0, t._1, t._2) end;
  end) end;
end
__thx_Options.spread4 = function(v,f) 
  do return __thx_Options.map(v, function(t) 
    do return f(t._0, t._1, t._2, t._3) end;
  end) end;
end
__thx_Options.spread5 = function(v,f) 
  do return __thx_Options.map(v, function(t) 
    do return f(t._0, t._1, t._2, t._3, t._4) end;
  end) end;
end
__thx_Options.spread6 = function(v,f) 
  do return __thx_Options.map(v, function(t) 
    do return f(t._0, t._1, t._2, t._3, t._4, t._5) end;
  end) end;
end

__thx_Orderings.new = {}
__thx_Orderings.__name__ = "thx.Orderings"
__thx_Orderings.negate = function(o) 
  local tmp = o[1];
  if (tmp) == 0 then 
    do return __thx_OrderingImpl.GT end;
  elseif (tmp) == 1 then 
    do return __thx_OrderingImpl.LT end;
  elseif (tmp) == 2 then 
    do return __thx_OrderingImpl.EQ end; end;
end

__thx__ReadonlyArray_ReadonlyArray_Impl_.new = {}
__thx__ReadonlyArray_ReadonlyArray_Impl_.__name__ = "thx._ReadonlyArray.ReadonlyArray_Impl_"
__thx__ReadonlyArray_ReadonlyArray_Impl_.empty = function() 
  do return _hx_tab_array({}, 0) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.flatten = function(array) 
  do return __thx_Arrays.reduce(array, function(acc,element) 
    do return acc:concat(element) end;
  end, _hx_tab_array({}, 0)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.indexOf = function(this1,el,eq) 
  if (nil == eq) then 
    eq = __thx_Functions.equality;
  end;
  local _g = 0;
  local _g1 = this1.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (eq(el, this1[i])) then 
      do return i end;
    end;
  end;
  do return -1 end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.lastIndexOf = function(this1,el,eq) 
  if (nil == eq) then 
    eq = __thx_Functions.equality;
  end;
  local len = this1.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (eq(el, this1[(len - i) - 1])) then 
      do return i end;
    end;
  end;
  do return -1 end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.get_length = function(this1) 
  do return this1.length end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.get = function(this1,i) 
  do return this1[i] end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.head = function(this1) 
  do return this1[0] end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.tail = function(this1) 
  do return this1:slice(1) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.reduce = function(this1,f,initial) 
  local _g = 0;
  while (_g < this1.length) do _hx_do_first_1 = false;
    
    local v = this1[_g];
    _g = _g + 1;
    initial = f(initial, v);
  end;
  do return initial end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.reducei = function(this1,f,initial) 
  local _g = 0;
  local _g1 = this1.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    initial = f(initial, this1[i], i);
  end;
  do return initial end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.reverse = function(this1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = this1;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local arr = _g;
  arr:reverse();
  do return arr end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.toArray = function(this1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = this1;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.unsafe = function(this1) 
  do return this1 end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.concat = function(this1,that) 
  do return this1:concat(that) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.insertAt = function(this1,pos,el) 
  do return this1:slice(0, pos):concat(_hx_tab_array({[0]=el}, 1)):concat(this1:slice(pos)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.insertAfter = function(this1,ref,el,eq) 
  local pos = _hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(this1, ref, eq);
  if (pos < 0) then 
    pos = this1.length - 1;
  end;
  local pos = pos + 1;
  do return this1:slice(0, pos):concat(_hx_tab_array({[0]=el}, 1)):concat(this1:slice(pos)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.insertBefore = function(this1,ref,el,eq) 
  local pos = _hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(this1, ref, eq);
  do return this1:slice(0, pos):concat(_hx_tab_array({[0]=el}, 1)):concat(this1:slice(pos)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.replace = function(this1,ref,el,eq) 
  local pos = _hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(this1, ref, eq);
  if (pos < 0) then 
    _G.error(__haxe_Exception.thrown(__thx_Error.new("unable to find reference element", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/ReadonlyArray.hx",lineNumber=94,className="thx._ReadonlyArray.ReadonlyArray_Impl_",methodName="replace"}))),0);
  end;
  do return this1:slice(0, pos):concat(_hx_tab_array({[0]=el}, 1)):concat(this1:slice(pos + 1)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.replaceAt = function(this1,pos,el) 
  do return this1:slice(0, pos):concat(_hx_tab_array({[0]=el}, 1)):concat(this1:slice(pos + 1)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.remove = function(this1,el,eq) 
  local pos = _hx_wrap_if_string_field(__thx__ReadonlyArray_ReadonlyArray_Impl_,'indexOf')(this1, el, eq);
  do return this1:slice(0, pos):concat(this1:slice(pos + 1)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.removeAt = function(this1,pos) 
  do return this1:slice(0, pos):concat(this1:slice(pos + 1)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.prepend = function(this1,el) 
  do return _hx_tab_array({[0]=el}, 1):concat(this1) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.append = function(this1,el) 
  do return this1:concat(_hx_tab_array({[0]=el}, 1)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.unshift = function(this1,el) 
  do return _hx_tab_array({[0]=el}, 1):concat(this1) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.shift = function(this1) 
  if (this1.length == 0) then 
    local _0 = nil;
    do return _hx_o({__fields__={_0=true,_1=true},_0=_0,_1=this1}) end;
  end;
  local value = this1[0];
  local array = this1:slice(0, 0):concat(this1:slice(1));
  do return _hx_o({__fields__={_0=true,_1=true},_0=value,_1=array}) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.push = function(this1,el) 
  do return this1:concat(_hx_tab_array({[0]=el}, 1)) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.pop = function(this1) 
  if (this1.length == 0) then 
    local _0 = nil;
    do return _hx_o({__fields__={_0=true,_1=true},_0=_0,_1=this1}) end;
  end;
  local value = this1[this1.length - 1];
  local pos = this1.length - 1;
  local array = this1:slice(0, pos):concat(this1:slice(pos + 1));
  do return _hx_o({__fields__={_0=true,_1=true},_0=value,_1=array}) end;
end
__thx__ReadonlyArray_ReadonlyArray_Impl_.iterator = function(this1) 
  do return __haxe_iterators_ArrayIterator.new(this1) end;
end

__thx__Semigroup_Semigroup_Impl_.new = {}
__thx__Semigroup_Semigroup_Impl_.__name__ = "thx._Semigroup.Semigroup_Impl_"
__thx__Semigroup_Semigroup_Impl_.get_append = function(this1) 
  do return this1 end;
end

__thx__Set_Set_Impl_.new = {}
__thx__Set_Set_Impl_.__name__ = "thx._Set.Set_Impl_"
__thx__Set_Set_Impl_.createString = function(it) 
  local map = __haxe_ds_StringMap.new();
  local set = map;
  if (nil ~= it) then 
    __thx__Set_Set_Impl_.pushMany(set, it);
  end;
  do return set end;
end
__thx__Set_Set_Impl_.createInt = function(it) 
  local map = __haxe_ds_IntMap.new();
  local set = map;
  if (nil ~= it) then 
    __thx__Set_Set_Impl_.pushMany(set, it);
  end;
  do return set end;
end
__thx__Set_Set_Impl_.createObject = function(it) 
  local map = __haxe_ds_ObjectMap.new();
  local set = map;
  if (nil ~= it) then 
    __thx__Set_Set_Impl_.pushMany(set, it);
  end;
  do return set end;
end
__thx__Set_Set_Impl_.createEnum = function(arr) 
  local map = __haxe_ds_EnumValueMap.new();
  local set = map;
  if (nil ~= arr) then 
    __thx__Set_Set_Impl_.pushMany(set, arr);
  end;
  do return set end;
end
__thx__Set_Set_Impl_._new = function(map) 
  do return map end;
end
__thx__Set_Set_Impl_.add = function(this1,v) 
  if (this1:exists(v)) then 
    do return false end;
  else
    this1:set(v, true);
    do return true end;
  end;
end
__thx__Set_Set_Impl_.copy = function(this1) 
  local inst = __thx__Set_Set_Impl_.empty(this1);
  local k = this1:keys();
  while (k:hasNext()) do _hx_do_first_1 = false;
    
    local k = k:next();
    inst:set(k, true);
  end;
  do return inst end;
end
__thx__Set_Set_Impl_.empty = function(this1) 
  local inst = Type.createInstance(Type.getClass(this1), _hx_tab_array({}, 0));
  do return inst end;
end
__thx__Set_Set_Impl_.difference = function(this1,set) 
  local result = __thx__Set_Set_Impl_.copy(this1);
  local item = __thx__Set_Set_Impl_.iterator(set);
  while (item:hasNext()) do _hx_do_first_1 = false;
    
    local item = item:next();
    result:remove(item);
  end;
  do return result end;
end
__thx__Set_Set_Impl_.filter = function(this1,predicate) 
  do return __thx__Set_Set_Impl_.reduce(this1, function(acc,v) 
    if (predicate(v)) then 
      __thx__Set_Set_Impl_.add(acc, v);
    end;
    do return acc end;
  end, __thx__Set_Set_Impl_.empty(this1)) end;
end
__thx__Set_Set_Impl_.map = function(this1,f) 
  do return __thx__Set_Set_Impl_.reduce(this1, function(acc,v) 
    acc:push(f(v));
    do return acc end;
  end, _hx_tab_array({}, 0)) end;
end
__thx__Set_Set_Impl_.exists = function(this1,v) 
  do return this1:exists(v) end;
end
__thx__Set_Set_Impl_.remove = function(this1,v) 
  do return this1:remove(v) end;
end
__thx__Set_Set_Impl_.intersection = function(this1,set) 
  local result = __thx__Set_Set_Impl_.empty(this1);
  local item = __thx__Set_Set_Impl_.iterator(this1);
  while (item:hasNext()) do _hx_do_first_1 = false;
    
    local item = item:next();
    if (set:exists(item)) then 
      result:set(item, true);
    end;
  end;
  do return result end;
end
__thx__Set_Set_Impl_.push = function(this1,v) 
  this1:set(v, true);
end
__thx__Set_Set_Impl_.pushMany = function(this1,values) 
  local value = values:iterator();
  while (value:hasNext()) do _hx_do_first_1 = false;
    
    local value = value:next();
    this1:set(value, true);
  end;
end
__thx__Set_Set_Impl_.reduce = function(this1,handler,acc) 
  local v = __thx__Set_Set_Impl_.iterator(this1);
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    acc = handler(acc, v);
  end;
  do return acc end;
end
__thx__Set_Set_Impl_.iterator = function(this1) 
  do return this1:keys() end;
end
__thx__Set_Set_Impl_.union = function(this1,set) 
  local newset = __thx__Set_Set_Impl_.copy(this1);
  __thx__Set_Set_Impl_.pushMany(newset, __thx__Set_Set_Impl_.toArray(set));
  do return newset end;
end
__thx__Set_Set_Impl_.toArray = function(this1) 
  local arr = _hx_tab_array({}, 0);
  local k = this1:keys();
  while (k:hasNext()) do _hx_do_first_1 = false;
    
    local k = k:next();
    arr:push(k);
  end;
  do return arr end;
end
__thx__Set_Set_Impl_.toString = function(this1) 
  do return Std.string(Std.string("{") .. Std.string(__thx__Set_Set_Impl_.toArray(this1):join(", "))) .. Std.string("}") end;
end
__thx__Set_Set_Impl_.get_length = function(this1) 
  local l = 0;
  local i = this1:iterator();
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    l = l + 1;
  end;
  do return l end;
end

__thx_Strings.new = {}
__thx_Strings.__name__ = "thx.Strings"
__thx_Strings.after = function(value,searchFor) 
  local pos = String.prototype.indexOf(value, searchFor);
  if (pos < 0) then 
    do return "" end;
  else
    do return String.prototype.substring(value, pos + __lua_lib_luautf8_Utf8.len(searchFor)) end;
  end;
end
__thx_Strings.afterLast = function(value,searchFor) 
  local pos = String.prototype.lastIndexOf(value, searchFor);
  if (pos < 0) then 
    do return "" end;
  else
    do return String.prototype.substring(value, pos + __lua_lib_luautf8_Utf8.len(searchFor)) end;
  end;
end
__thx_Strings.before = function(value,searchFor) 
  local pos = String.prototype.indexOf(value, searchFor);
  if (pos < 0) then 
    do return "" end;
  else
    do return String.prototype.substring(value, 0, pos) end;
  end;
end
__thx_Strings.beforeLast = function(value,searchFor) 
  local pos = String.prototype.lastIndexOf(value, searchFor);
  if (pos < 0) then 
    do return "" end;
  else
    do return String.prototype.substring(value, 0, pos) end;
  end;
end
__thx_Strings.capitalize = function(s) 
  do return Std.string(__lua_lib_luautf8_Utf8.upper(String.prototype.substr(s, 0, 1))) .. Std.string(String.prototype.substr(s, 1)) end;
end
__thx_Strings.capitalizeWords = function(value,whiteSpaceOnly) 
  if (whiteSpaceOnly == nil) then 
    whiteSpaceOnly = false;
  end;
  if (whiteSpaceOnly) then 
    do return __thx_Strings.UCWORDSWS:map(Std.string(__lua_lib_luautf8_Utf8.upper(String.prototype.substr(value, 0, 1))) .. Std.string(String.prototype.substr(value, 1)), __thx_Strings.upperMatch) end;
  else
    do return __thx_Strings.UCWORDS:map(Std.string(__lua_lib_luautf8_Utf8.upper(String.prototype.substr(value, 0, 1))) .. Std.string(String.prototype.substr(value, 1)), __thx_Strings.upperMatch) end;
  end;
end
__thx_Strings.canonicalizeNewlines = function(value) 
  do return __thx_Strings.CANONICALIZE_LINES:replace(value, "\n") end;
end
__thx_Strings.caseInsensitiveCompare = function(a,b) 
  if ((nil == a) and (nil == b)) then 
    do return 0 end;
  end;
  if (nil == a) then 
    do return -1 end;
  else
    if (nil == b) then 
      do return 1 end;
    end;
  end;
  local a = __lua_lib_luautf8_Utf8.lower(a);
  local b = __lua_lib_luautf8_Utf8.lower(b);
  if (a < b) then 
    do return -1 end;
  else
    if (a > b) then 
      do return 1 end;
    else
      do return 0 end;
    end;
  end;
end
__thx_Strings.caseInsensitiveEndsWith = function(s,_end) 
  do return StringTools.endsWith(__lua_lib_luautf8_Utf8.lower(s), __lua_lib_luautf8_Utf8.lower(_end)) end;
end
__thx_Strings.caseInsensitiveEndsWithAny = function(s,values) 
  local tmp = __lua_lib_luautf8_Utf8.lower(s);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = values;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__lua_lib_luautf8_Utf8.lower(i));
  end;
  do return __thx_Strings.endsWithAny(tmp, _g) end;
end
__thx_Strings.caseInsensitiveStartsWith = function(s,start) 
  do return StringTools.startsWith(__lua_lib_luautf8_Utf8.lower(s), __lua_lib_luautf8_Utf8.lower(start)) end;
end
__thx_Strings.caseInsensitiveStartsWithAny = function(s,values) 
  local tmp = __lua_lib_luautf8_Utf8.lower(s);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = values;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__lua_lib_luautf8_Utf8.lower(i));
  end;
  do return __thx_Strings.startsWithAny(tmp, _g) end;
end
__thx_Strings.collapse = function(value) 
  do return __thx_Strings.WSG:replace(StringTools.trim(value), " ") end;
end
__thx_Strings.compare = function(a,b) 
  if (a < b) then 
    do return -1 end;
  else
    if (a > b) then 
      do return 1 end;
    else
      do return 0 end;
    end;
  end;
end
__thx_Strings.caseInsensitiveContains = function(s,test) 
  do return String.prototype.indexOf(__lua_lib_luautf8_Utf8.lower(s), __lua_lib_luautf8_Utf8.lower(test)) >= 0 end;
end
__thx_Strings.contains = function(s,test) 
  do return String.prototype.indexOf(s, test) >= 0 end;
end
__thx_Strings.count = function(s,test) 
  do return String.prototype.split(s, test).length - 1 end;
end
__thx_Strings.caseInsensitiveContainsAny = function(s,tests) 
  local s = s;
  do return __thx_Arrays.any(tests, function(test) 
    do return String.prototype.indexOf(__lua_lib_luautf8_Utf8.lower(s), __lua_lib_luautf8_Utf8.lower(test)) >= 0 end;
  end) end;
end
__thx_Strings.containsAny = function(s,tests) 
  local s = s;
  do return __thx_Arrays.any(tests, function(test) 
    do return String.prototype.indexOf(s, test) >= 0 end;
  end) end;
end
__thx_Strings.caseInsensitiveContainsAll = function(s,tests) 
  local s = s;
  do return __thx_Arrays.all(tests, function(test) 
    do return String.prototype.indexOf(__lua_lib_luautf8_Utf8.lower(s), __lua_lib_luautf8_Utf8.lower(test)) >= 0 end;
  end) end;
end
__thx_Strings.containsAll = function(s,tests) 
  local s = s;
  do return __thx_Arrays.all(tests, function(test) 
    do return String.prototype.indexOf(s, test) >= 0 end;
  end) end;
end
__thx_Strings.dasherize = function(s) 
  do return StringTools.replace(s, "_", "-") end;
end
__thx_Strings.diffAt = function(a,b) 
  local a1 = __lua_lib_luautf8_Utf8.len(a);
  local b1 = __lua_lib_luautf8_Utf8.len(b);
  local min = (function() 
    local _hx_1
    if (a1 < b1) then 
    _hx_1 = a1; else 
    _hx_1 = b1; end
    return _hx_1
  end )();
  local _g = 0;
  local _g1 = min;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (String.prototype.substring(a, i, i + 1) ~= String.prototype.substring(b, i, i + 1)) then 
      do return i end;
    end;
  end;
  do return min end;
end
__thx_Strings.ellipsis = function(s,maxlen,symbol) 
  if (symbol == nil) then 
    symbol = "…";
  end;
  if (maxlen == nil) then 
    maxlen = 20;
  end;
  local sl = __lua_lib_luautf8_Utf8.len(s);
  local symboll = __lua_lib_luautf8_Utf8.len(symbol);
  if (sl > maxlen) then 
    if (maxlen < symboll) then 
      do return String.prototype.substr(symbol, symboll - maxlen, maxlen) end;
    else
      do return Std.string(String.prototype.substr(s, 0, maxlen - symboll)) .. Std.string(symbol) end;
    end;
  else
    do return s end;
  end;
end
__thx_Strings.ellipsisMiddle = function(s,maxlen,symbol) 
  if (symbol == nil) then 
    symbol = "…";
  end;
  if (maxlen == nil) then 
    maxlen = 20;
  end;
  local sl = __lua_lib_luautf8_Utf8.len(s);
  local symboll = __lua_lib_luautf8_Utf8.len(symbol);
  if (sl > maxlen) then 
    if (maxlen <= symboll) then 
      do return __thx_Strings.ellipsis(s, maxlen, symbol) end;
    end;
    local hll = _G.math.ceil((maxlen - symboll) / 2);
    local hlr = _G.math.floor((maxlen - symboll) / 2);
    do return Std.string(Std.string(String.prototype.substr(s, 0, hll)) .. Std.string(symbol)) .. Std.string(String.prototype.substr(s, sl - hlr, hlr)) end;
  else
    do return s end;
  end;
end
__thx_Strings.endsWithAny = function(s,values) 
  do return __thx_Iterables.any(values, function(_end) 
    do return StringTools.endsWith(s, _end) end;
  end) end;
end
__thx_Strings.filter = function(s,predicate) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = String.prototype.split(s, "");
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (predicate(i)) then 
      _g:push(i);
    end;
  end;
  do return _g:join("") end;
end
__thx_Strings.filterCharcode = function(s,predicate) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Strings.map(s, function(s) 
    do return __lua_lib_luautf8_Utf8.byte(s, 1) end;
  end);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (predicate(i)) then 
      _g:push(i);
    end;
  end;
  local codes = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = codes;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__lua_lib_luautf8_Utf8.char(i));
  end;
  do return _g:join("") end;
end
__thx_Strings.from = function(value,searchFor) 
  local pos = String.prototype.indexOf(value, searchFor);
  if (pos < 0) then 
    do return "" end;
  else
    do return String.prototype.substring(value, pos) end;
  end;
end
__thx_Strings.hashCode = function(value) 
  local code = 0;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(value);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local c = __lua_lib_luautf8_Utf8.byte(value, i + 1);
    code = _G.math.fmod(__haxe__Int32_Int32_Impl_.clamp(__haxe__Int32_Int32_Impl_.mul(__thx_Strings.HASCODE_MUL, code) + c), __thx_Strings.HASCODE_MAX);
  end;
  do return code end;
end
__thx_Strings.hasContent = function(value) 
  if (value ~= nil) then 
    do return __lua_lib_luautf8_Utf8.len(value) > 0 end;
  else
    do return false end;
  end;
end
__thx_Strings.humanize = function(s) 
  do return StringTools.replace(__thx_Strings.underscore(s), "_", " ") end;
end
__thx_Strings.isAlpha = function(s) 
  if (__lua_lib_luautf8_Utf8.len(s) > 0) then 
    do return not __thx_Strings.IS_ALPHA:match(s) end;
  else
    do return false end;
  end;
end
__thx_Strings.isAlphaNum = function(value) 
  do return __thx_Strings.ALPHANUM:match(value) end;
end
__thx_Strings.isBreakingWhitespace = function(value) 
  do return not __thx_Strings.IS_BREAKINGWHITESPACE:match(value) end;
end
__thx_Strings.isLowerCase = function(value) 
  do return __lua_lib_luautf8_Utf8.lower(value) == value end;
end
__thx_Strings.isUpperCase = function(value) 
  do return __lua_lib_luautf8_Utf8.upper(value) == value end;
end
__thx_Strings.ifEmpty = function(value,alt) 
  if ((nil ~= value) and ("" ~= value)) then 
    do return value end;
  else
    do return alt end;
  end;
end
__thx_Strings.isDigitsOnly = function(value) 
  do return __thx_Strings.DIGITS:match(value) end;
end
__thx_Strings.isEmpty = function(value) 
  if (value ~= nil) then 
    do return value == "" end;
  else
    do return true end;
  end;
end
__thx_Strings.lowerCaseFirst = function(value) 
  do return Std.string(__lua_lib_luautf8_Utf8.lower(String.prototype.substring(value, 0, 1))) .. Std.string(String.prototype.substring(value, 1)) end;
end
__thx_Strings.random = function(value,length) 
  if (length == nil) then 
    length = 1;
  end;
  do return String.prototype.substr(value, _G.math.floor(((__lua_lib_luautf8_Utf8.len(value) - length) + 1) * _G.math.random()), length) end;
end
__thx_Strings.randomSequence = function(seed,length) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Ints.range(0, length);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__thx_Strings.random(seed));
  end;
  do return _g:join("") end;
end
__thx_Strings.randomSequence64 = function(length) 
  do return __thx_Strings.randomSequence(__haxe_crypto_Base64.CHARS, length) end;
end
__thx_Strings.iterator = function(s) 
  do return __haxe_iterators_ArrayIterator.new(String.prototype.split(s, "")) end;
end
__thx_Strings.map = function(value,callback) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = String.prototype.split(value, "");
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(callback(i));
  end;
  do return _g end;
end
__thx_Strings.remove = function(value,toremove) 
  do return StringTools.replace(value, toremove, "") end;
end
__thx_Strings.removeAfter = function(value,toremove) 
  if (StringTools.endsWith(value, toremove)) then 
    do return String.prototype.substring(value, 0, __lua_lib_luautf8_Utf8.len(value) - __lua_lib_luautf8_Utf8.len(toremove)) end;
  else
    do return value end;
  end;
end
__thx_Strings.removeAt = function(value,index,length) 
  do return Std.string(String.prototype.substring(value, 0, index)) .. Std.string(String.prototype.substring(value, index + length)) end;
end
__thx_Strings.removeBefore = function(value,toremove) 
  if (StringTools.startsWith(value, toremove)) then 
    do return String.prototype.substring(value, __lua_lib_luautf8_Utf8.len(toremove)) end;
  else
    do return value end;
  end;
end
__thx_Strings.removeOne = function(value,toremove) 
  local pos = String.prototype.indexOf(value, toremove);
  if (pos < 0) then 
    do return value end;
  end;
  do return Std.string(String.prototype.substring(value, 0, pos)) .. Std.string(String.prototype.substring(value, pos + __lua_lib_luautf8_Utf8.len(toremove))) end;
end
__thx_Strings["repeat"] = function(s,times) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = times;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(s);
  end;
  do return _g:join("") end;
end
__thx_Strings.reverse = function(s) 
  local arr = String.prototype.split(s, "");
  arr:reverse();
  do return arr:join("") end;
end
__thx_Strings.quote = function(s) 
  if (String.prototype.indexOf(s, "\"") < 0) then 
    do return Std.string(Std.string("\"") .. Std.string(s)) .. Std.string("\"") end;
  else
    if (String.prototype.indexOf(s, "'") < 0) then 
      do return Std.string(Std.string("'") .. Std.string(s)) .. Std.string("'") end;
    else
      do return Std.string(Std.string("\"") .. Std.string(StringTools.replace(s, "\"", "\\\""))) .. Std.string("\"") end;
    end;
  end;
end
__thx_Strings.splitOnce = function(s,separator) 
  local pos = String.prototype.indexOf(s, separator);
  if (pos < 0) then 
    do return _hx_tab_array({[0]=s}, 1) end;
  end;
  do return _hx_tab_array({[0]=String.prototype.substring(s, 0, pos), String.prototype.substring(s, pos + __lua_lib_luautf8_Utf8.len(separator))}, 2) end;
end
__thx_Strings.startsWithAny = function(s,values) 
  do return __thx_Iterables.any(values, function(start) 
    do return StringTools.startsWith(s, start) end;
  end) end;
end
__thx_Strings.stripTags = function(s) 
  do return __thx_Strings.STRIPTAGS:replace(s, "") end;
end
__thx_Strings.surround = function(s,left,right) 
  do return Std.string(Std.string(Std.string("") .. Std.string(left)) .. Std.string(s)) .. Std.string(((function() 
    local _hx_1
    if (nil == right) then 
    _hx_1 = left; else 
    _hx_1 = right; end
    return _hx_1
  end )())) end;
end
__thx_Strings.toArray = function(s) 
  do return String.prototype.split(s, "") end;
end
__thx_Strings.toCharcodes = function(s) 
  do return __thx_Strings.map(s, function(s) 
    do return __lua_lib_luautf8_Utf8.byte(s, 1) end;
  end) end;
end
__thx_Strings.toChunks = function(s,len) 
  local chunks = _hx_tab_array({}, 0);
  while (__lua_lib_luautf8_Utf8.len(s) > 0) do _hx_do_first_1 = false;
    
    chunks:push(String.prototype.substr(s, 0, len));
    s = String.prototype.substr(s, len, __lua_lib_luautf8_Utf8.len(s) - len);
  end;
  do return chunks end;
end
__thx_Strings.toLines = function(s) 
  do return __thx_Strings.SPLIT_LINES:split(s) end;
end
__thx_Strings.trimChars = function(value,charlist) 
  do return __thx_Strings.trimCharsRight(__thx_Strings.trimCharsLeft(value, charlist), charlist) end;
end
__thx_Strings.trimCharsLeft = function(value,charlist) 
  local pos = 0;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(value);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (String.prototype.indexOf(charlist, __lua_lib_luautf8_Utf8.sub(value, i + 1, i + 1)) >= 0) then 
      pos = pos + 1;
    else
      break;
    end;
  end;
  do return String.prototype.substring(value, pos) end;
end
__thx_Strings.trimCharsRight = function(value,charlist) 
  local len = __lua_lib_luautf8_Utf8.len(value);
  local pos = len;
  local i;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local j = _g - 1;
    i = (len - j) - 1;
    if (String.prototype.indexOf(charlist, __lua_lib_luautf8_Utf8.sub(value, i + 1, i + 1)) >= 0) then 
      pos = i;
    else
      break;
    end;
  end;
  do return String.prototype.substring(value, 0, pos) end;
end
__thx_Strings.underscore = function(s) 
  s = EReg.new("::", "g"):replace(s, "/");
  s = EReg.new("([A-Z]+)([A-Z][a-z])", "g"):replace(s, "$1_$2");
  s = EReg.new("([a-z\\d])([A-Z])", "g"):replace(s, "$1_$2");
  s = EReg.new("-", "g"):replace(s, "_");
  do return __lua_lib_luautf8_Utf8.lower(s) end;
end
__thx_Strings.upperCaseFirst = function(value) 
  do return Std.string(__lua_lib_luautf8_Utf8.upper(String.prototype.substring(value, 0, 1))) .. Std.string(String.prototype.substring(value, 1)) end;
end
__thx_Strings.upTo = function(value,searchFor) 
  local pos = String.prototype.indexOf(value, searchFor);
  if (pos < 0) then 
    do return value end;
  else
    do return String.prototype.substring(value, 0, pos) end;
  end;
end
__thx_Strings.wrapColumns = function(s,columns,indent,newline) 
  if (newline == nil) then 
    newline = "\n";
  end;
  if (indent == nil) then 
    indent = "";
  end;
  if (columns == nil) then 
    columns = 78;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __thx_Strings.SPLIT_LINES:split(s);
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(__thx_Strings.wrapLine(StringTools.trim(__thx_Strings.WSG:replace(i, " ")), columns, indent, newline));
  end;
  do return _g:join(newline) end;
end
__thx_Strings.upperMatch = function(re) 
  do return __lua_lib_luautf8_Utf8.upper(re:matched(0)) end;
end
__thx_Strings.wrapLine = function(s,columns,indent,newline) 
  local parts = _hx_tab_array({}, 0);
  local pos = 0;
  local len = __lua_lib_luautf8_Utf8.len(s);
  local ilen = __lua_lib_luautf8_Utf8.len(indent);
  columns = columns - ilen;
  while (true) do _hx_do_first_1 = false;
    
    if ((pos + columns) >= (len - ilen)) then 
      parts:push(String.prototype.substring(s, pos));
      break;
    end;
    local i = 0;
    while (not StringTools.isSpace(s, (pos + columns) - i) and (i < columns)) do _hx_do_first_2 = false;
      
      i = i + 1;
    end;
    if (i == columns) then 
      i = 0;
      while (not StringTools.isSpace(s, (pos + columns) + i) and (((pos + columns) + i) < len)) do _hx_do_first_2 = false;
        
        i = i + 1;
      end;
      parts:push(String.prototype.substring(s, pos, (pos + columns) + i));
      pos = pos + ((columns + i) + 1);
    else
      parts:push(String.prototype.substring(s, pos, (pos + columns) - i));
      pos = pos + ((columns - i) + 1);
    end;
  end;
  do return Std.string(indent) .. Std.string(parts:join(Std.string(newline) .. Std.string(indent))) end;
end
__thx_Strings.lpad = function(s,char,length) 
  local diff = length - __lua_lib_luautf8_Utf8.len(s);
  if (diff > 0) then 
    do return Std.string(__thx_Strings["repeat"](char, diff)) .. Std.string(s) end;
  else
    do return s end;
  end;
end
__thx_Strings.rpad = function(s,char,length) 
  local diff = length - __lua_lib_luautf8_Utf8.len(s);
  if (diff > 0) then 
    do return Std.string(s) .. Std.string(__thx_Strings["repeat"](char, diff)) end;
  else
    do return s end;
  end;
end
_hxClasses["thx.TimePeriod"] = { __ename__ = "thx.TimePeriod", __constructs__ = _hx_tab_array({[0]="Second","Minute","Hour","Day","Week","Month","Year"},7)}
__thx_TimePeriod = _hxClasses["thx.TimePeriod"];
__thx_TimePeriod.Second = _hx_tab_array({[0]="Second",0,__enum__ = __thx_TimePeriod},2)

__thx_TimePeriod.Minute = _hx_tab_array({[0]="Minute",1,__enum__ = __thx_TimePeriod},2)

__thx_TimePeriod.Hour = _hx_tab_array({[0]="Hour",2,__enum__ = __thx_TimePeriod},2)

__thx_TimePeriod.Day = _hx_tab_array({[0]="Day",3,__enum__ = __thx_TimePeriod},2)

__thx_TimePeriod.Week = _hx_tab_array({[0]="Week",4,__enum__ = __thx_TimePeriod},2)

__thx_TimePeriod.Month = _hx_tab_array({[0]="Month",5,__enum__ = __thx_TimePeriod},2)

__thx_TimePeriod.Year = _hx_tab_array({[0]="Year",6,__enum__ = __thx_TimePeriod},2)


__thx__Timestamp_Timestamp_Impl_.new = {}
__thx__Timestamp_Timestamp_Impl_.__name__ = "thx._Timestamp.Timestamp_Impl_"
__thx__Timestamp_Timestamp_Impl_.create = function(year,month,day,hour,minute,second) 
  do return __thx_Dates.create(year, month, day, hour, minute, second):getTime() end;
end
__thx__Timestamp_Timestamp_Impl_.now = function() 
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d:getTime() end;
end
__thx__Timestamp_Timestamp_Impl_.fromDate = function(d) 
  do return d:getTime() end;
end
__thx__Timestamp_Timestamp_Impl_.fromString = function(s) 
  do return __lua_Boot.strDate(s):getTime() end;
end
__thx__Timestamp_Timestamp_Impl_.toDate = function(this1) 
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = this1 / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d end;
end
__thx__Timestamp_Timestamp_Impl_.toString = function(this1) 
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = this1 / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return __lua_Boot.dateStr(d) end;
end
__thx__Timestamp_Timestamp_Impl_.snapNext = function(this1,period) 
  local tmp = period[1];
  if (tmp) == 0 then 
    do return _G.math.ceil(this1 / 1000.0) * 1000.0 end;
  elseif (tmp) == 1 then 
    do return _G.math.ceil(this1 / 60000.0) * 60000.0 end;
  elseif (tmp) == 2 then 
    do return _G.math.ceil(this1 / 3600000.0) * 3600000.0 end;
  elseif (tmp) == 3 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), d:getDate() + 1, 0, 0, 0):getTime() end;
  elseif (tmp) == 4 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    local wd = d:getDay();
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), (d:getDate() + 7) - wd, 0, 0, 0):getTime() end;
  elseif (tmp) == 5 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    do return __thx_Dates.create(d:getFullYear(), d:getMonth() + 1, 1, 0, 0, 0):getTime() end;
  elseif (tmp) == 6 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    do return __thx_Dates.create(d:getFullYear() + 1, 0, 1, 0, 0, 0):getTime() end; end;
end
__thx__Timestamp_Timestamp_Impl_.snapPrev = function(this1,period) 
  local tmp = period[1];
  if (tmp) == 0 then 
    do return _G.math.floor(this1 / 1000.0) * 1000.0 end;
  elseif (tmp) == 1 then 
    do return _G.math.floor(this1 / 60000.0) * 60000.0 end;
  elseif (tmp) == 2 then 
    do return _G.math.floor(this1 / 3600000.0) * 3600000.0 end;
  elseif (tmp) == 3 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), d:getDate(), 0, 0, 0):getTime() end;
  elseif (tmp) == 4 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    local wd = d:getDay();
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), d:getDate() - wd, 0, 0, 0):getTime() end;
  elseif (tmp) == 5 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), 1, 0, 0, 0):getTime() end;
  elseif (tmp) == 6 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    do return __thx_Dates.create(d:getFullYear(), 0, 1, 0, 0, 0):getTime() end; end;
end
__thx__Timestamp_Timestamp_Impl_.snapTo = function(this1,period) 
  local tmp = period[1];
  if (tmp) == 0 then 
    do return _G.math.floor((this1 / 1000.0) + 0.5) * 1000.0 end;
  elseif (tmp) == 1 then 
    do return _G.math.floor((this1 / 60000.0) + 0.5) * 60000.0 end;
  elseif (tmp) == 2 then 
    do return _G.math.floor((this1 / 3600000.0) + 0.5) * 3600000.0 end;
  elseif (tmp) == 3 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    local mod = (function() 
      local _hx_1
      if (d:getHours() >= 12) then 
      _hx_1 = 1; else 
      _hx_1 = 0; end
      return _hx_1
    end )();
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), d:getDate() + mod, 0, 0, 0):getTime() end;
  elseif (tmp) == 4 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    local wd = d:getDay();
    local mod = (function() 
      local _hx_2
      if (wd < 3) then 
      _hx_2 = -wd; elseif (wd > 3) then 
      _hx_2 = 7 - wd; elseif (d:getHours() < 12) then 
      _hx_2 = -wd; else 
      _hx_2 = 7 - wd; end
      return _hx_2
    end )();
    do return __thx_Dates.create(d:getFullYear(), d:getMonth(), d:getDate() + mod, 0, 0, 0):getTime() end;
  elseif (tmp) == 5 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    local mod = (function() 
      local _hx_3
      if (d:getDate() > _G.math.floor((DateTools.getMonthDays(d) / 2) + 0.5)) then 
      _hx_3 = 1; else 
      _hx_3 = 0; end
      return _hx_3
    end )();
    do return __thx_Dates.create(d:getFullYear(), d:getMonth() + mod, 1, 0, 0, 0):getTime() end;
  elseif (tmp) == 6 then 
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = this1 / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local d = d;
    local mod = (function() 
      local _hx_4
      if (this1 > Date.new(d:getFullYear(), 6, 2, 0, 0, 0):getTime()) then 
      _hx_4 = 1; else 
      _hx_4 = 0; end
      return _hx_4
    end )();
    do return __thx_Dates.create(d:getFullYear() + mod, 0, 1, 0, 0, 0):getTime() end; end;
end
__thx__Timestamp_Timestamp_Impl_.r = function(t,v) 
  do return _G.math.floor((t / v) + 0.5) * v end;
end
__thx__Timestamp_Timestamp_Impl_.f = function(t,v) 
  do return _G.math.floor(t / v) * v end;
end
__thx__Timestamp_Timestamp_Impl_.c = function(t,v) 
  do return _G.math.ceil(t / v) * v end;
end

__thx__Tuple_Tuple0_Impl_.new = {}
__thx__Tuple_Tuple0_Impl_.__name__ = "thx._Tuple.Tuple0_Impl_"
__thx__Tuple_Tuple0_Impl_._new = function() 
  do return __thx_Nil["nil"] end;
end
__thx__Tuple_Tuple0_Impl_.with = function(this1,v) 
  do return v end;
end
__thx__Tuple_Tuple0_Impl_.toString = function(this1) 
  do return "Tuple0()" end;
end
__thx__Tuple_Tuple0_Impl_.toNil = function(this1) 
  do return this1 end;
end
__thx__Tuple_Tuple0_Impl_.nilToTuple = function(v) 
  do return __thx_Nil["nil"] end;
end

__thx__Tuple_Tuple1_Impl_.new = {}
__thx__Tuple_Tuple1_Impl_.__name__ = "thx._Tuple.Tuple1_Impl_"
__thx__Tuple_Tuple1_Impl_._new = function(_0) 
  do return _0 end;
end
__thx__Tuple_Tuple1_Impl_.get__0 = function(this1) 
  do return this1 end;
end
__thx__Tuple_Tuple1_Impl_.with = function(this1,v) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=this1,_1=v}) end;
end
__thx__Tuple_Tuple1_Impl_.toString = function(this1) 
  do return Std.string(Std.string("Tuple1(") .. Std.string(Std.string(this1))) .. Std.string(")") end;
end
__thx__Tuple_Tuple1_Impl_.arrayToTuple = function(v) 
  do return v[0] end;
end

__thx__Tuple_Tuple2_Impl_.new = {}
__thx__Tuple_Tuple2_Impl_.__name__ = "thx._Tuple.Tuple2_Impl_"
__thx__Tuple_Tuple2_Impl_.of = function(_0,_1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=_0,_1=_1}) end;
end
__thx__Tuple_Tuple2_Impl_._new = function(_0,_1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=_0,_1=_1}) end;
end
__thx__Tuple_Tuple2_Impl_.get_left = function(this1) 
  do return this1._0 end;
end
__thx__Tuple_Tuple2_Impl_.get_right = function(this1) 
  do return this1._1 end;
end
__thx__Tuple_Tuple2_Impl_.flip = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=this1._1,_1=this1._0}) end;
end
__thx__Tuple_Tuple2_Impl_.dropLeft = function(this1) 
  do return this1._1 end;
end
__thx__Tuple_Tuple2_Impl_.dropRight = function(this1) 
  do return this1._0 end;
end
__thx__Tuple_Tuple2_Impl_.with = function(this1,v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=this1._0,_1=this1._1,_2=v}) end;
end
__thx__Tuple_Tuple2_Impl_.toString = function(this1) 
  do return Std.string(Std.string(Std.string(Std.string("Tuple2(") .. Std.string(Std.string(this1._0))) .. Std.string(",")) .. Std.string(Std.string(this1._1))) .. Std.string(")") end;
end
__thx__Tuple_Tuple2_Impl_.map = function(this1,f) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=this1._0,_1=f(this1._1)}) end;
end
__thx__Tuple_Tuple2_Impl_.squeeze = function(f) 
  do return function(tp) 
    do return f(tp._0, tp._1) end;
  end end;
end
__thx__Tuple_Tuple2_Impl_.arrayToTuple2 = function(v) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=v[0],_1=v[1]}) end;
end

__thx__Tuple_Tuple3_Impl_.new = {}
__thx__Tuple_Tuple3_Impl_.__name__ = "thx._Tuple.Tuple3_Impl_"
__thx__Tuple_Tuple3_Impl_.of = function(_0,_1,_2) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=_0,_1=_1,_2=_2}) end;
end
__thx__Tuple_Tuple3_Impl_._new = function(_0,_1,_2) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=_0,_1=_1,_2=_2}) end;
end
__thx__Tuple_Tuple3_Impl_.flip = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=this1._2,_1=this1._1,_2=this1._0}) end;
end
__thx__Tuple_Tuple3_Impl_.dropLeft = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=this1._1,_1=this1._2}) end;
end
__thx__Tuple_Tuple3_Impl_.dropRight = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true},_0=this1._0,_1=this1._1}) end;
end
__thx__Tuple_Tuple3_Impl_.with = function(this1,v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=this1._0,_1=this1._1,_2=this1._2,_3=v}) end;
end
__thx__Tuple_Tuple3_Impl_.toString = function(this1) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Tuple3(") .. Std.string(Std.string(this1._0))) .. Std.string(",")) .. Std.string(Std.string(this1._1))) .. Std.string(",")) .. Std.string(Std.string(this1._2))) .. Std.string(")") end;
end
__thx__Tuple_Tuple3_Impl_.arrayToTuple3 = function(v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=v[0],_1=v[1],_2=v[2]}) end;
end
__thx__Tuple_Tuple3_Impl_.map = function(this1,f) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=this1._0,_1=this1._1,_2=f(this1._2)}) end;
end

__thx__Tuple_Tuple4_Impl_.new = {}
__thx__Tuple_Tuple4_Impl_.__name__ = "thx._Tuple.Tuple4_Impl_"
__thx__Tuple_Tuple4_Impl_.of = function(_0,_1,_2,_3) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=_0,_1=_1,_2=_2,_3=_3}) end;
end
__thx__Tuple_Tuple4_Impl_._new = function(_0,_1,_2,_3) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=_0,_1=_1,_2=_2,_3=_3}) end;
end
__thx__Tuple_Tuple4_Impl_.flip = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=this1._3,_1=this1._2,_2=this1._1,_3=this1._0}) end;
end
__thx__Tuple_Tuple4_Impl_.dropLeft = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=this1._1,_1=this1._2,_2=this1._3}) end;
end
__thx__Tuple_Tuple4_Impl_.dropRight = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true},_0=this1._0,_1=this1._1,_2=this1._2}) end;
end
__thx__Tuple_Tuple4_Impl_.with = function(this1,v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=this1._0,_1=this1._1,_2=this1._2,_3=this1._3,_4=v}) end;
end
__thx__Tuple_Tuple4_Impl_.toString = function(this1) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Tuple4(") .. Std.string(Std.string(this1._0))) .. Std.string(",")) .. Std.string(Std.string(this1._1))) .. Std.string(",")) .. Std.string(Std.string(this1._2))) .. Std.string(",")) .. Std.string(Std.string(this1._3))) .. Std.string(")") end;
end
__thx__Tuple_Tuple4_Impl_.arrayToTuple4 = function(v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=v[0],_1=v[1],_2=v[2],_3=v[3]}) end;
end

__thx__Tuple_Tuple5_Impl_.new = {}
__thx__Tuple_Tuple5_Impl_.__name__ = "thx._Tuple.Tuple5_Impl_"
__thx__Tuple_Tuple5_Impl_.of = function(_0,_1,_2,_3,_4) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=_0,_1=_1,_2=_2,_3=_3,_4=_4}) end;
end
__thx__Tuple_Tuple5_Impl_._new = function(_0,_1,_2,_3,_4) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=_0,_1=_1,_2=_2,_3=_3,_4=_4}) end;
end
__thx__Tuple_Tuple5_Impl_.flip = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=this1._4,_1=this1._3,_2=this1._2,_3=this1._1,_4=this1._0}) end;
end
__thx__Tuple_Tuple5_Impl_.dropLeft = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=this1._1,_1=this1._2,_2=this1._3,_3=this1._4}) end;
end
__thx__Tuple_Tuple5_Impl_.dropRight = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true},_0=this1._0,_1=this1._1,_2=this1._2,_3=this1._3}) end;
end
__thx__Tuple_Tuple5_Impl_.with = function(this1,v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true,_5=true},_0=this1._0,_1=this1._1,_2=this1._2,_3=this1._3,_4=this1._4,_5=v}) end;
end
__thx__Tuple_Tuple5_Impl_.toString = function(this1) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Tuple5(") .. Std.string(Std.string(this1._0))) .. Std.string(",")) .. Std.string(Std.string(this1._1))) .. Std.string(",")) .. Std.string(Std.string(this1._2))) .. Std.string(",")) .. Std.string(Std.string(this1._3))) .. Std.string(",")) .. Std.string(Std.string(this1._4))) .. Std.string(")") end;
end
__thx__Tuple_Tuple5_Impl_.arrayToTuple5 = function(v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=v[0],_1=v[1],_2=v[2],_3=v[3],_4=v[4]}) end;
end

__thx__Tuple_Tuple6_Impl_.new = {}
__thx__Tuple_Tuple6_Impl_.__name__ = "thx._Tuple.Tuple6_Impl_"
__thx__Tuple_Tuple6_Impl_.of = function(_0,_1,_2,_3,_4,_5) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true,_5=true},_0=_0,_1=_1,_2=_2,_3=_3,_4=_4,_5=_5}) end;
end
__thx__Tuple_Tuple6_Impl_._new = function(_0,_1,_2,_3,_4,_5) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true,_5=true},_0=_0,_1=_1,_2=_2,_3=_3,_4=_4,_5=_5}) end;
end
__thx__Tuple_Tuple6_Impl_.flip = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true,_5=true},_0=this1._5,_1=this1._4,_2=this1._3,_3=this1._2,_4=this1._1,_5=this1._0}) end;
end
__thx__Tuple_Tuple6_Impl_.dropLeft = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=this1._1,_1=this1._2,_2=this1._3,_3=this1._4,_4=this1._5}) end;
end
__thx__Tuple_Tuple6_Impl_.dropRight = function(this1) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true},_0=this1._0,_1=this1._1,_2=this1._2,_3=this1._3,_4=this1._4}) end;
end
__thx__Tuple_Tuple6_Impl_.toString = function(this1) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Tuple6(") .. Std.string(Std.string(this1._0))) .. Std.string(",")) .. Std.string(Std.string(this1._1))) .. Std.string(",")) .. Std.string(Std.string(this1._2))) .. Std.string(",")) .. Std.string(Std.string(this1._3))) .. Std.string(",")) .. Std.string(Std.string(this1._4))) .. Std.string(",")) .. Std.string(Std.string(this1._5))) .. Std.string(")") end;
end
__thx__Tuple_Tuple6_Impl_.arrayToTuple6 = function(v) 
  do return _hx_o({__fields__={_0=true,_1=true,_2=true,_3=true,_4=true,_5=true},_0=v[0],_1=v[1],_2=v[2],_3=v[3],_4=v[4],_5=v[5]}) end;
end

__thx_Types.new = {}
__thx_Types.__name__ = "thx.Types"
__thx_Types.isAnonymousObject = function(v) 
  if (Reflect.isObject(v)) then 
    do return nil == Type.getClass(v) end;
  else
    do return false end;
  end;
end
__thx_Types.isObject = function(v) 
  if (Reflect.isObject(v)) then 
    do return not __thx_Types.isPrimitive(v) end;
  else
    do return false end;
  end;
end
__thx_Types.isPrimitive = function(v) 
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 1 or (tmp) == 2 or (tmp) == 3 then 
    do return true end;
  elseif (tmp) == 6 then 
    local _g = _g[2];
    local c = _g;
    if (c.__name__ == "String") then 
      do return true end;
    else
      local c = _g;
      if (c.__name__ == "Date") then 
        do return true end;
      else
        do return false end;
      end;
    end;
  elseif (tmp) == 7 then 
    local _g = _g[2];
    do return false end;
  elseif (tmp) == 0 or (tmp) == 4 or (tmp) == 5 or (tmp) == 8 then 
    do return false end; end;
end
__thx_Types.isEnumValue = function(v) 
  local _g = Type.typeof(v);
  if (_g[1] == 7) then 
    local _g = _g[2];
    do return true end;
  else
    do return false end;
  end;
end
__thx_Types.hasSuperClass = function(cls,sup) 
  while (nil ~= cls) do _hx_do_first_1 = false;
    
    if (cls == sup) then 
      do return true end;
    end;
    cls = Type.getSuperClass(cls);
  end;
  do return false end;
end
__thx_Types.sameType = function(a,b) 
  do return _hx_wrap_if_string_field(__thx_Types,'toString')(Type.typeof(a)) == _hx_wrap_if_string_field(__thx_Types,'toString')(Type.typeof(b)) end;
end
__thx_Types.typeInheritance = function(type) 
  local tmp = type[1];
  if (tmp) == 1 then 
    do return _hx_tab_array({[0]="Int"}, 1) end;
  elseif (tmp) == 2 then 
    do return _hx_tab_array({[0]="Float"}, 1) end;
  elseif (tmp) == 3 then 
    do return _hx_tab_array({[0]="Bool"}, 1) end;
  elseif (tmp) == 4 then 
    do return _hx_tab_array({[0]="{}"}, 1) end;
  elseif (tmp) == 5 then 
    do return _hx_tab_array({[0]="Function"}, 1) end;
  elseif (tmp) == 6 then 
    local c = type[2];
    local classes = _hx_tab_array({}, 0);
    while (nil ~= c) do _hx_do_first_1 = false;
      
      classes:push(c);
      c = Type.getSuperClass(c);
    end;
    local f = Type.getClassName;
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = classes;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(f(i));
    end;
    do return _g end;
  elseif (tmp) == 7 then 
    local e = type[2];
    do return _hx_tab_array({[0]=Type.getEnumName(e)}, 1) end;else
  _G.error(__haxe_Exception.thrown(Std.string("invalid type ") .. Std.string(Std.string(type))),0); end;
end
__thx_Types.toString = function(type) 
  local tmp = type[1];
  if (tmp) == 0 then 
    do return "Null" end;
  elseif (tmp) == 1 then 
    do return "Int" end;
  elseif (tmp) == 2 then 
    do return "Float" end;
  elseif (tmp) == 3 then 
    do return "Bool" end;
  elseif (tmp) == 4 then 
    do return "{}" end;
  elseif (tmp) == 5 then 
    do return "Function" end;
  elseif (tmp) == 6 then 
    local c = type[2];
    do return c.__name__ end;
  elseif (tmp) == 7 then 
    local e = type[2];
    do return Type.getEnumName(e) end;else
  _G.error(__haxe_Exception.thrown(Std.string("invalid type ") .. Std.string(Std.string(type))),0); end;
end
__thx_Types.valueTypeInheritance = function(value) 
  do return __thx_Types.typeInheritance(Type.typeof(value)) end;
end
__thx_Types.valueTypeToString = function(value) 
  do return _hx_wrap_if_string_field(__thx_Types,'toString')(Type.typeof(value)) end;
end
__thx_Types.anyValueToString = function(value) 
  if (__lua_Boot.__instanceof(value, ValueType)) then 
    do return _hx_wrap_if_string_field(__thx_Types,'toString')(value) end;
  end;
  if (__lua_Boot.__instanceof(value, Class)) then 
    do return value.__name__ end;
  end;
  if (__lua_Boot.__instanceof(value, Enum)) then 
    do return Type.getEnumName(value) end;
  end;
  do return _hx_wrap_if_string_field(__thx_Types,'toString')(Type.typeof(value)) end;
end

__thx__Validation_Validation_Impl_.new = {}
__thx__Validation_Validation_Impl_.__name__ = "thx._Validation.Validation_Impl_"
__thx__Validation_Validation_Impl_.get_either = function(this1) 
  do return this1 end;
end
__thx__Validation_Validation_Impl_.pure = function(a) 
  do return __thx_Either.Right(a) end;
end
__thx__Validation_Validation_Impl_.success = function(a) 
  do return __thx_Either.Right(a) end;
end
__thx__Validation_Validation_Impl_.failure = function(e) 
  do return __thx_Either.Left(e) end;
end
__thx__Validation_Validation_Impl_.successNel = function(a) 
  do return __thx_Either.Right(a) end;
end
__thx__Validation_Validation_Impl_.failureNel = function(e) 
  do return __thx_Either.Left(__thx__Nel_Nel_Impl_.pure(e)) end;
end
__thx__Validation_Validation_Impl_.nn = function(a,e) 
  if (a == nil) then 
    do return __thx_Either.Left(e) end;
  else
    do return __thx_Either.Right(a) end;
  end;
end
__thx__Validation_Validation_Impl_.nnNel = function(a,e) 
  if (a == nil) then 
    do return __thx_Either.Left(__thx__Nel_Nel_Impl_.pure(e)) end;
  else
    do return __thx_Either.Right(a) end;
  end;
end
__thx__Validation_Validation_Impl_.map = function(this1,f) 
  do return __thx_Eithers.map(this1, f) end;
end
__thx__Validation_Validation_Impl_.ap = function(this1,v,s) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local e0 = this1[2];
    local _g = v;
    local tmp = _g[1];
    if (tmp) == 0 then 
      local e1 = _g[2];
      do return __thx_Either.Left((__thx__Semigroup_Semigroup_Impl_.get_append(s))(e0, e1)) end;
    elseif (tmp) == 1 then 
      local b = _g[2];
      do return __thx_Either.Left(e0) end; end;
  elseif (tmp) == 1 then 
    local a = this1[2];
    local _g = v;
    local tmp = _g[1];
    if (tmp) == 0 then 
      local e = _g[2];
      do return __thx_Either.Left(e) end;
    elseif (tmp) == 1 then 
      local f = _g[2];
      do return __thx_Either.Right(f(a)) end; end; end;
end
__thx__Validation_Validation_Impl_.flatMapV = function(this1,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    local a = this1[2];
    do return __thx_Either.Left(a) end;
  elseif (tmp) == 1 then 
    local b = this1[2];
    do return f(b) end; end;
end
__thx__Validation_Validation_Impl_.orElseV = function(this1,other,s) 
  local _g = other;
  local tmp = this1[1];
  if (tmp) == 0 then 
    local _g1 = this1[2];
    local tmp = _g[1];
    if (tmp) == 0 then 
      local e2 = _g[2];
      local e1 = _g1;
      do return __thx_Either.Left((__thx__Semigroup_Semigroup_Impl_.get_append(s))(e1, e2)) end;
    elseif (tmp) == 1 then 
      local _g = _g[2];
      do return other end; end;
  elseif (tmp) == 1 then 
    local _g = this1[2];
    do return this1 end; end;
end
__thx__Validation_Validation_Impl_.foldLeft = function(this1,b,f) 
  do return __thx_Eithers.foldLeft(this1, b, f) end;
end
__thx__Validation_Validation_Impl_.foldMap = function(this1,f,m) 
  do return __thx_Eithers.foldMap(this1, f, m) end;
end
__thx__Validation_Validation_Impl_.leftMap = function(this1,f) 
  do return __thx_Eithers.leftMap(this1, f) end;
end
__thx__Validation_Validation_Impl_.wrapNel = function(this1) 
  do return __thx_Eithers.leftMap(this1, __thx__Nel_Nel_Impl_.pure) end;
end
__thx__Validation_Validation_Impl_.ensure = function(this1,p,error) 
  do return __thx_Eithers.ensure(this1, p, error) end;
end
__thx__Validation_Validation_Impl_.vnel = function(e) 
  do return e end;
end
__thx__Validation_Validation_Impl_.val1 = function(f,v1) 
  do return __thx__Validation_Validation_Impl_.map(v1, f) end;
end
__thx__Validation_Validation_Impl_.val2 = function(f,v1,v2,s) 
  do return __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(f)), s) end;
end
__thx__Validation_Validation_Impl_.val3 = function(f,v1,v2,v3,s) 
  local f = f;
  do return __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s) end;
end
__thx__Validation_Validation_Impl_.val4 = function(f,v1,v2,v3,v4,s) 
  local f = f;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val5 = function(f,v1,v2,v3,v4,v5,s) 
  local f = f;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val6 = function(f,v1,v2,v3,v4,v5,v6,s) 
  local f = f;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val7 = function(f,v1,v2,v3,v4,v5,v6,v7,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val8 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val9 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f1(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val10 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f1(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val11 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f1(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f1(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val12 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f1(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val13 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f1(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f1(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val14 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f1(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val15 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f1(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f1(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v15, __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val16 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o) 
    do return function(p) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f1(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v16, __thx__Validation_Validation_Impl_.ap(v15, __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val17 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p) 
    do return function(q) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o) 
    do return function(p) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f1(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f1(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v17, __thx__Validation_Validation_Impl_.ap(v16, __thx__Validation_Validation_Impl_.ap(v15, __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val18 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,v18,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q) 
    do return function(r) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p) 
    do return function(q) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o) 
    do return function(p) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f1(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v18, __thx__Validation_Validation_Impl_.ap(v17, __thx__Validation_Validation_Impl_.ap(v16, __thx__Validation_Validation_Impl_.ap(v15, __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val19 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,v18,v19,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q,r) 
    do return function(s) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r, s) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q) 
    do return function(r) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p) 
    do return function(q) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o) 
    do return function(p) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f1(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f1(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f = function(a,b,c,d,e) 
    do return function(f0) 
      do return f1(a, b, c, d, e, f0) end;
    end end;
  end;
  local f1 = function(a,b,c,d) 
    do return function(e) 
      do return f(a, b, c, d, e) end;
    end end;
  end;
  local f = function(a,b,c) 
    do return function(d) 
      do return f1(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v19, __thx__Validation_Validation_Impl_.ap(v18, __thx__Validation_Validation_Impl_.ap(v17, __thx__Validation_Validation_Impl_.ap(v16, __thx__Validation_Validation_Impl_.ap(v15, __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end
__thx__Validation_Validation_Impl_.val20 = function(f,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16,v17,v18,v19,v20,s) 
  local f = f;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q,r,s) 
    do return function(t) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r, s, t) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q,r) 
    do return function(s) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r, s) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p,q) 
    do return function(r) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q, r) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o,p) 
    do return function(q) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p, q) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n,o) 
    do return function(p) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o, p) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l,m,n) 
    do return function(o) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m, n, o) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k,l,m) 
    do return function(n) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l, m, n) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j,k,l) 
    do return function(m) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k, l, m) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i,j,k) 
    do return function(l) 
      do return f(a, b, c, d, e, f0, g, h, i, j, k, l) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h,i,j) 
    do return function(k) 
      do return f1(a, b, c, d, e, f0, g, h, i, j, k) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g,h,i) 
    do return function(j) 
      do return f(a, b, c, d, e, f0, g, h, i, j) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0,g,h) 
    do return function(i) 
      do return f1(a, b, c, d, e, f0, g, h, i) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e,f0,g) 
    do return function(h) 
      do return f(a, b, c, d, e, f0, g, h) end;
    end end;
  end;
  local f = function(a,b,c,d,e,f0) 
    do return function(g) 
      do return f1(a, b, c, d, e, f0, g) end;
    end end;
  end;
  local f1 = function(a,b,c,d,e) 
    do return function(f0) 
      do return f(a, b, c, d, e, f0) end;
    end end;
  end;
  local f = function(a,b,c,d) 
    do return function(e) 
      do return f1(a, b, c, d, e) end;
    end end;
  end;
  local f1 = function(a,b,c) 
    do return function(d) 
      do return f(a, b, c, d) end;
    end end;
  end;
  do return __thx__Validation_Validation_Impl_.ap(v20, __thx__Validation_Validation_Impl_.ap(v19, __thx__Validation_Validation_Impl_.ap(v18, __thx__Validation_Validation_Impl_.ap(v17, __thx__Validation_Validation_Impl_.ap(v16, __thx__Validation_Validation_Impl_.ap(v15, __thx__Validation_Validation_Impl_.ap(v14, __thx__Validation_Validation_Impl_.ap(v13, __thx__Validation_Validation_Impl_.ap(v12, __thx__Validation_Validation_Impl_.ap(v11, __thx__Validation_Validation_Impl_.ap(v10, __thx__Validation_Validation_Impl_.ap(v9, __thx__Validation_Validation_Impl_.ap(v8, __thx__Validation_Validation_Impl_.ap(v7, __thx__Validation_Validation_Impl_.ap(v6, __thx__Validation_Validation_Impl_.ap(v5, __thx__Validation_Validation_Impl_.ap(v4, __thx__Validation_Validation_Impl_.ap(v3, __thx__Validation_Validation_Impl_.ap(v2, __thx__Validation_Validation_Impl_.map(v1, __thx_Functions2.curry(function(a,b) 
    do return function(c) 
      do return f1(a, b, c) end;
    end end;
  end)), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s), s) end;
end

__thx_ValidationExtensions.new = {}
__thx_ValidationExtensions.__name__ = "thx.ValidationExtensions"
__thx_ValidationExtensions.leftMapNel = function(n,f) 
  do return __thx_Eithers.leftMap(n, function(n) 
    do return __thx__Nel_Nel_Impl_.map(n, f) end;
  end) end;
end
__thx_ValidationExtensions.ensureNel = function(v,p,error) 
  if (v[1] == 1) then 
    local a = v[2];
    if (p(a)) then 
      do return v end;
    else
      do return __thx_Either.Left(__thx__Nel_Nel_Impl_.pure(error)) end;
    end;
  else
    local left = v;
    do return left end;
  end;
end
__thx_ValidationExtensions.appendVNel = function(target,item) 
  local tmp = target[1];
  if (tmp) == 0 then 
    local _g = target[2];
    local tmp = item[1];
    if (tmp) == 0 then 
      local errors2 = item[2];
      local errors1 = _g;
      do return __thx_Either.Left(__thx__Nel_Nel_Impl_.append(errors1, errors2)) end;
    elseif (tmp) == 1 then 
      local value = item[2];
      local errors = _g;
      do return __thx_Either.Left(errors) end; end;
  elseif (tmp) == 1 then 
    local _g = target[2];
    local tmp = item[1];
    if (tmp) == 0 then 
      local errors = item[2];
      local values = _g;
      do return __thx_Either.Left(errors) end;
    elseif (tmp) == 1 then 
      local value = item[2];
      local values = _g;
      do return __thx_Either.Right(__thx_Arrays.append(values, value)) end; end; end;
end
__thx_ValidationExtensions.appendValidation = function(target,item) 
  do return __thx_ValidationExtensions.appendVNel(target, __thx_Eithers.toVNel(item)) end;
end
__thx_ValidationExtensions.appendVNels = function(target,items) 
  do return __thx_Arrays.reduce(items, __thx_ValidationExtensions.appendVNel, target) end;
end
__thx_ValidationExtensions.appendValidations = function(target,items) 
  do return __thx_Arrays.reduce(items, __thx_ValidationExtensions.appendValidation, target) end;
end

__thx_error_ErrorWrapper.new = function(message,innerError,stack,pos) 
  local self = _hx_new(__thx_error_ErrorWrapper.prototype)
  __thx_error_ErrorWrapper.super(self,message,innerError,stack,pos)
  return self
end
__thx_error_ErrorWrapper.super = function(self,message,innerError,stack,pos) 
  __thx_Error.super(self,message,stack,pos);
  self.innerError = innerError;
end
__thx_error_ErrorWrapper.__name__ = "thx.error.ErrorWrapper"
__thx_error_ErrorWrapper.prototype = _hx_e();
__thx_error_ErrorWrapper.prototype.innerError= nil;

__thx_error_ErrorWrapper.prototype.__class__ =  __thx_error_ErrorWrapper
__thx_error_ErrorWrapper.__super__ = __thx_Error
setmetatable(__thx_error_ErrorWrapper.prototype,{__index=__thx_Error.prototype})

__thx_fp__Map_Map_Impl_.new = {}
__thx_fp__Map_Map_Impl_.__name__ = "thx.fp._Map.Map_Impl_"
__thx_fp__Map_Map_Impl_.empty = function() 
  do return __thx_fp_MapImpl.Tip end;
end
__thx_fp__Map_Map_Impl_.singleton = function(k,v) 
  do return __thx_fp_MapImpl.Bin(1, k, v, __thx_fp_MapImpl.Tip, __thx_fp_MapImpl.Tip) end;
end
__thx_fp__Map_Map_Impl_.bin = function(k,v,lhs,rhs) 
  do return __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(lhs) + __thx_fp__Map_Map_Impl_.size(rhs)) + 1, k, v, lhs, rhs) end;
end
__thx_fp__Map_Map_Impl_.fromNative = function(map,comparator) 
  local r = __thx_fp_MapImpl.Tip;
  local key = map:keys();
  while (key:hasNext()) do _hx_do_first_1 = false;
    
    local key = key:next();
    r = __thx_fp__Map_Map_Impl_.insert(r, key, map:get(key), comparator);
  end;
  do return r end;
end
__thx_fp__Map_Map_Impl_.lookup = function(this1,key,comparator) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return __haxe_ds_Option.None end;
  elseif (tmp) == 1 then 
    local size = this1[2];
    local xkey = this1[3];
    local xvalue = this1[4];
    local lhs = this1[5];
    local rhs = this1[6];
    local c = comparator(key, xkey);
    local tmp = c[1];
    if (tmp) == 0 then 
      do return __thx_fp__Map_Map_Impl_.lookup(lhs, key, comparator) end;
    elseif (tmp) == 1 then 
      do return __thx_fp__Map_Map_Impl_.lookup(rhs, key, comparator) end;
    elseif (tmp) == 2 then 
      do return __haxe_ds_Option.Some(xvalue) end; end; end;
end
__thx_fp__Map_Map_Impl_.lookupTuple = function(this1,key,comparator) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return __haxe_ds_Option.None end;
  elseif (tmp) == 1 then 
    local size = this1[2];
    local xkey = this1[3];
    local xvalue = this1[4];
    local lhs = this1[5];
    local rhs = this1[6];
    local c = comparator(key, xkey);
    local tmp = c[1];
    if (tmp) == 0 then 
      do return __thx_fp__Map_Map_Impl_.lookupTuple(lhs, key, comparator) end;
    elseif (tmp) == 1 then 
      do return __thx_fp__Map_Map_Impl_.lookupTuple(rhs, key, comparator) end;
    elseif (tmp) == 2 then 
      do return __haxe_ds_Option.Some(_hx_o({__fields__={_0=true,_1=true},_0=xkey,_1=xvalue})) end; end; end;
end
__thx_fp__Map_Map_Impl_.delete = function(this1,key,comparator) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return __thx_fp_MapImpl.Tip end;
  elseif (tmp) == 1 then 
    local size = this1[2];
    local kx = this1[3];
    local x = this1[4];
    local lhs = this1[5];
    local rhs = this1[6];
    local tmp = comparator(key, kx)[1];
    if (tmp) == 0 then 
      do return __thx_fp__Map_Map_Impl_.balance(kx, x, __thx_fp__Map_Map_Impl_.delete(lhs, key, comparator), rhs) end;
    elseif (tmp) == 1 then 
      do return __thx_fp__Map_Map_Impl_.balance(kx, x, lhs, __thx_fp__Map_Map_Impl_.delete(rhs, key, comparator)) end;
    elseif (tmp) == 2 then 
      do return __thx_fp__Map_Map_Impl_.glue(lhs, rhs) end; end; end;
end
__thx_fp__Map_Map_Impl_.insert = function(this1,kx,x,comparator) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return __thx_fp_MapImpl.Bin(1, kx, x, __thx_fp_MapImpl.Tip, __thx_fp_MapImpl.Tip) end;
  elseif (tmp) == 1 then 
    local sz = this1[2];
    local ky = this1[3];
    local y = this1[4];
    local lhs = this1[5];
    local rhs = this1[6];
    local tmp = comparator(kx, ky)[1];
    if (tmp) == 0 then 
      do return __thx_fp__Map_Map_Impl_.balance(ky, y, __thx_fp__Map_Map_Impl_.insert(lhs, kx, x, comparator), rhs) end;
    elseif (tmp) == 1 then 
      do return __thx_fp__Map_Map_Impl_.balance(ky, y, lhs, __thx_fp__Map_Map_Impl_.insert(rhs, kx, x, comparator)) end;
    elseif (tmp) == 2 then 
      do return __thx_fp_MapImpl.Bin(sz, kx, x, lhs, rhs) end; end; end;
end
__thx_fp__Map_Map_Impl_.foldLeft = function(this1,b,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return b end;
  elseif (tmp) == 1 then 
    local _g = this1[2];
    local _g = this1[3];
    local x = this1[4];
    local l = this1[5];
    local r = this1[6];
    do return __thx_fp__Map_Map_Impl_.foldLeft(r, __thx_fp__Map_Map_Impl_.foldLeft(l, f(b, x), f), f) end; end;
end
__thx_fp__Map_Map_Impl_.map = function(this1,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return __thx_fp_MapImpl.Tip end;
  elseif (tmp) == 1 then 
    local sz = this1[2];
    local ky = this1[3];
    local y = this1[4];
    local lhs = this1[5];
    local rhs = this1[6];
    do return __thx_fp_MapImpl.Bin(sz, ky, f(y), __thx_fp__Map_Map_Impl_.map(lhs, f), __thx_fp__Map_Map_Impl_.map(rhs, f)) end; end;
end
__thx_fp__Map_Map_Impl_.values = function(this1) 
  do return __thx_fp__Map_Map_Impl_.foldLeft(this1, _hx_tab_array({}, 0), function(acc,v) 
    acc:push(v);
    do return acc end;
  end) end;
end
__thx_fp__Map_Map_Impl_.foldLeftKeys = function(this1,b,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return b end;
  elseif (tmp) == 1 then 
    local _g = this1[2];
    local _g = this1[4];
    local kx = this1[3];
    local l = this1[5];
    local r = this1[6];
    do return __thx_fp__Map_Map_Impl_.foldLeftKeys(r, __thx_fp__Map_Map_Impl_.foldLeftKeys(l, f(b, kx), f), f) end; end;
end
__thx_fp__Map_Map_Impl_.foldLeftAll = function(this1,b,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return b end;
  elseif (tmp) == 1 then 
    local _g = this1[2];
    local kx = this1[3];
    local x = this1[4];
    local l = this1[5];
    local r = this1[6];
    do return __thx_fp__Map_Map_Impl_.foldLeftAll(r, __thx_fp__Map_Map_Impl_.foldLeftAll(l, f(b, kx, x), f), f) end; end;
end
__thx_fp__Map_Map_Impl_.foldLeftTuples = function(this1,b,f) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return b end;
  elseif (tmp) == 1 then 
    local _g = this1[2];
    local kx = this1[3];
    local x = this1[4];
    local l = this1[5];
    local r = this1[6];
    do return __thx_fp__Map_Map_Impl_.foldLeftTuples(r, __thx_fp__Map_Map_Impl_.foldLeftTuples(l, f(b, _hx_o({__fields__={_0=true,_1=true},_0=kx,_1=x})), f), f) end; end;
end
__thx_fp__Map_Map_Impl_.size = function(this1) 
  local tmp = this1[1];
  if (tmp) == 0 then 
    do return 0 end;
  elseif (tmp) == 1 then 
    local _g = this1[3];
    local _g = this1[4];
    local _g = this1[5];
    local _g = this1[6];
    local size = this1[2];
    do return size end; end;
end
__thx_fp__Map_Map_Impl_.balance = function(k,x,lhs,rhs) 
  local ls = __thx_fp__Map_Map_Impl_.size(lhs);
  local rs = __thx_fp__Map_Map_Impl_.size(rhs);
  local xs = (ls + rs) + 1;
  if ((ls + rs) <= 1) then 
    do return __thx_fp_MapImpl.Bin(xs, k, x, lhs, rhs) end;
  else
    if (rs >= (5 * ls)) then 
      do return __thx_fp__Map_Map_Impl_.rotateLeft(k, x, lhs, rhs) end;
    else
      if (ls >= (5 * rs)) then 
        do return __thx_fp__Map_Map_Impl_.rotateRight(k, x, lhs, rhs) end;
      else
        do return __thx_fp_MapImpl.Bin(xs, k, x, lhs, rhs) end;
      end;
    end;
  end;
end
__thx_fp__Map_Map_Impl_.glue = function(this1,that) 
  if (this1[1] == 0) then 
    do return that end;
  else
    if (that[1] == 0) then 
      do return this1 end;
    else
      local l = this1;
      local r = that;
      if (__thx_fp__Map_Map_Impl_.size(l) > __thx_fp__Map_Map_Impl_.size(r)) then 
        local t = __thx_fp__Map_Map_Impl_.deleteFindMax(l);
        do return __thx_fp__Map_Map_Impl_.balance(t.k, t.x, t.t, r) end;
      else
        local l = this1;
        local r = that;
        local t = __thx_fp__Map_Map_Impl_.deleteFindMin(r);
        do return __thx_fp__Map_Map_Impl_.balance(t.k, t.x, l, t.t) end;
      end;
    end;
  end;
end
__thx_fp__Map_Map_Impl_.deleteFindMin = function(map) 
  local tmp = map[1];
  if (tmp) == 0 then 
    _G.error(__haxe_Exception.thrown(__thx_Error.new("can not return the minimal element of an empty map", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=161,className="thx.fp._Map.Map_Impl_",methodName="deleteFindMin"}))),0);
  elseif (tmp) == 1 then 
    local _g = map[2];
    local _g = map[3];
    local _g1 = map[4];
    local _g2 = map[5];
    local _g3 = map[6];
    if (_g2[1] == 0) then 
      local x = _g1;
      local k = _g;
      local r = _g3;
      do return _hx_o({__fields__={k=true,x=true,t=true},k=k,x=x,t=r}) end;
    else
      local l = _g2;
      local x = _g1;
      local k = _g;
      local r = _g3;
      local t = __thx_fp__Map_Map_Impl_.deleteFindMin(l);
      do return _hx_o({__fields__={k=true,x=true,t=true},k=t.k,x=t.x,t=__thx_fp__Map_Map_Impl_.balance(k, x, t.t, r)}) end;
    end; end;
end
__thx_fp__Map_Map_Impl_.deleteFindMax = function(map) 
  local tmp = map[1];
  if (tmp) == 0 then 
    _G.error(__haxe_Exception.thrown(__thx_Error.new("can not return the maximal element of an empty map", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=171,className="thx.fp._Map.Map_Impl_",methodName="deleteFindMax"}))),0);
  elseif (tmp) == 1 then 
    local _g = map[2];
    local _g = map[3];
    local _g1 = map[4];
    local _g2 = map[5];
    local _g3 = map[6];
    if (_g3[1] == 0) then 
      local l = _g2;
      local x = _g1;
      local k = _g;
      do return _hx_o({__fields__={k=true,x=true,t=true},k=k,x=x,t=l}) end;
    else
      local r = _g3;
      local l = _g2;
      local x = _g1;
      local k = _g;
      local t = __thx_fp__Map_Map_Impl_.deleteFindMax(r);
      do return _hx_o({__fields__={k=true,x=true,t=true},k=t.k,x=t.x,t=__thx_fp__Map_Map_Impl_.balance(k, x, l, t.t)}) end;
    end; end;
end
__thx_fp__Map_Map_Impl_.rotateLeft = function(k,x,lhs,rhs) 
  if (rhs[1] == 1) then 
    local _g = rhs[2];
    local _g = rhs[3];
    local _g = rhs[4];
    local ly = rhs[5];
    local ry = rhs[6];
    if (__thx_fp__Map_Map_Impl_.size(ly) < (2 * __thx_fp__Map_Map_Impl_.size(ry))) then 
      do return __thx_fp__Map_Map_Impl_.singleLeft(k, x, lhs, rhs) end;
    else
      do return __thx_fp__Map_Map_Impl_.doubleLeft(k, x, lhs, rhs) end;
    end;
  else
    do return __thx_fp__Map_Map_Impl_.doubleLeft(k, x, lhs, rhs) end;
  end;
end
__thx_fp__Map_Map_Impl_.rotateRight = function(k,x,lhs,rhs) 
  if (lhs[1] == 1) then 
    local _g = lhs[2];
    local _g = lhs[3];
    local _g = lhs[4];
    local ly = lhs[5];
    local ry = lhs[6];
    if (__thx_fp__Map_Map_Impl_.size(ry) < (2 * __thx_fp__Map_Map_Impl_.size(ly))) then 
      do return __thx_fp__Map_Map_Impl_.singleRight(k, x, lhs, rhs) end;
    else
      do return __thx_fp__Map_Map_Impl_.doubleRight(k, x, lhs, rhs) end;
    end;
  else
    do return __thx_fp__Map_Map_Impl_.doubleRight(k, x, lhs, rhs) end;
  end;
end
__thx_fp__Map_Map_Impl_.singleLeft = function(k1,x1,t1,rhs) 
  if (rhs[1] == 1) then 
    local _g = rhs[2];
    local k2 = rhs[3];
    local x2 = rhs[4];
    local t2 = rhs[5];
    local t3 = rhs[6];
    local lhs = __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t1) + __thx_fp__Map_Map_Impl_.size(t2)) + 1, k1, x1, t1, t2);
    do return __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(lhs) + __thx_fp__Map_Map_Impl_.size(t3)) + 1, k2, x2, lhs, t3) end;
  else
    _G.error(__haxe_Exception.thrown(__thx_Error.new("damn it, this should never happen", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=193,className="thx.fp._Map.Map_Impl_",methodName="singleLeft"}))),0);
  end;
end
__thx_fp__Map_Map_Impl_.singleRight = function(k1,x1,lhs,t3) 
  if (lhs[1] == 1) then 
    local _g = lhs[2];
    local k2 = lhs[3];
    local x2 = lhs[4];
    local t1 = lhs[5];
    local t2 = lhs[6];
    local rhs = __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t2) + __thx_fp__Map_Map_Impl_.size(t3)) + 1, k1, x1, t2, t3);
    do return __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t1) + __thx_fp__Map_Map_Impl_.size(rhs)) + 1, k2, x2, t1, rhs) end;
  else
    _G.error(__haxe_Exception.thrown(__thx_Error.new("damn it, this should never happen", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=199,className="thx.fp._Map.Map_Impl_",methodName="singleRight"}))),0);
  end;
end
__thx_fp__Map_Map_Impl_.doubleLeft = function(k1,x1,t1,rhs) 
  if (rhs[1] == 1) then 
    local _g = rhs[2];
    local _g = rhs[5];
    if (_g[1] == 1) then 
      local _g1 = _g[2];
      local k3 = _g[3];
      local x3 = _g[4];
      local t2 = _g[5];
      local t3 = _g[6];
      local x2 = rhs[4];
      local k2 = rhs[3];
      local t4 = rhs[6];
      local lhs = __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t1) + __thx_fp__Map_Map_Impl_.size(t2)) + 1, k1, x1, t1, t2);
      local rhs = __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t3) + __thx_fp__Map_Map_Impl_.size(t4)) + 1, k2, x2, t3, t4);
      do return __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(lhs) + __thx_fp__Map_Map_Impl_.size(rhs)) + 1, k3, x3, lhs, rhs) end;
    else
      _G.error(__haxe_Exception.thrown(__thx_Error.new("damn it, this should never happen", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=206,className="thx.fp._Map.Map_Impl_",methodName="doubleLeft"}))),0);
    end;
  else
    _G.error(__haxe_Exception.thrown(__thx_Error.new("damn it, this should never happen", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=206,className="thx.fp._Map.Map_Impl_",methodName="doubleLeft"}))),0);
  end;
end
__thx_fp__Map_Map_Impl_.doubleRight = function(k1,x1,lhs,t4) 
  if (lhs[1] == 1) then 
    local _g = lhs[2];
    local _g = lhs[6];
    if (_g[1] == 1) then 
      local _g1 = _g[2];
      local k3 = _g[3];
      local x3 = _g[4];
      local t2 = _g[5];
      local t3 = _g[6];
      local t1 = lhs[5];
      local x2 = lhs[4];
      local k2 = lhs[3];
      local lhs = __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t1) + __thx_fp__Map_Map_Impl_.size(t2)) + 1, k2, x2, t1, t2);
      local rhs = __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(t3) + __thx_fp__Map_Map_Impl_.size(t4)) + 1, k1, x1, t3, t4);
      do return __thx_fp_MapImpl.Bin((__thx_fp__Map_Map_Impl_.size(lhs) + __thx_fp__Map_Map_Impl_.size(rhs)) + 1, k3, x3, lhs, rhs) end;
    else
      _G.error(__haxe_Exception.thrown(__thx_Error.new("damn it, this should never happen", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=213,className="thx.fp._Map.Map_Impl_",methodName="doubleRight"}))),0);
    end;
  else
    _G.error(__haxe_Exception.thrown(__thx_Error.new("damn it, this should never happen", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="thx/fp/Map.hx",lineNumber=213,className="thx.fp._Map.Map_Impl_",methodName="doubleRight"}))),0);
  end;
end
_hxClasses["thx.fp.MapImpl"] = { __ename__ = "thx.fp.MapImpl", __constructs__ = _hx_tab_array({[0]="Tip","Bin"},2)}
__thx_fp_MapImpl = _hxClasses["thx.fp.MapImpl"];
__thx_fp_MapImpl.Tip = _hx_tab_array({[0]="Tip",0,__enum__ = __thx_fp_MapImpl},2)

__thx_fp_MapImpl.Bin = function(size,key,value,lhs,rhs) local _x = _hx_tab_array({[0]="Bin",1,size,key,value,lhs,rhs,__enum__=__thx_fp_MapImpl}, 7); return _x; end 

__tokenizers_LineTokenizer.new = function(text) 
  local self = _hx_new(__tokenizers_LineTokenizer.prototype)
  __tokenizers_LineTokenizer.super(self,text)
  return self
end
__tokenizers_LineTokenizer.super = function(self,text) 
  self.myText = text;
  self.myOffset = 0;
  self:advance();
end
__tokenizers_LineTokenizer.__name__ = "tokenizers.LineTokenizer"
__tokenizers_LineTokenizer.tokenizeA = function(chars,includeSeparators) 
  do return __tokenizers_LineTokenizer.tokenizeB(chars, includeSeparators, true) end;
end
__tokenizers_LineTokenizer.tokenizeB = function(chars,includeSeparators,skipLastEmptyLine) 
  do return __tokenizers_LineTokenizer.tokenizeIntoListB(chars, includeSeparators, skipLastEmptyLine) end;
end
__tokenizers_LineTokenizer.tokenizeIntoListA = function(chars,includeSeparators) 
  do return __tokenizers_LineTokenizer.tokenizeIntoListB(chars, includeSeparators, true) end;
end
__tokenizers_LineTokenizer.tokenizeIntoListB = function(chars,includeSeparators,skipLastEmptyLine) 
  if ((chars == nil) or (__lua_lib_luautf8_Utf8.len(chars) == 0)) then 
    do return Array.new() end;
  end;
  local tokenizer = __tokenizers_LineTokenizer.new(chars);
  local lines = Array.new();
  while (not tokenizer:atEnd()) do _hx_do_first_1 = false;
    
    local offset = tokenizer:getOffset();
    local line;
    if (includeSeparators) then 
      line = String.prototype.substring(chars, offset, (offset + tokenizer:getLength()) + tokenizer:getLineSeparatorLength());
    else
      line = String.prototype.substring(chars, offset, offset + tokenizer:getLength());
    end;
    lines:push(line);
    tokenizer:advance();
  end;
  if (not skipLastEmptyLine and __tokenizers_LineTokenizer.stringEndsWithSeparator(tokenizer)) then 
    lines:push("");
  end;
  do return lines end;
end
__tokenizers_LineTokenizer.calcLineCount = function(chars,skipLastEmptyLine) 
  local lineCount = 0;
  if (__lua_lib_luautf8_Utf8.len(chars) ~= 0) then 
    local tokenizer = __tokenizers_LineTokenizer.new(chars);
    while (not tokenizer:atEnd()) do _hx_do_first_1 = false;
      
      lineCount = lineCount + 1;
      tokenizer:advance();
    end;
    if (not skipLastEmptyLine and __tokenizers_LineTokenizer.stringEndsWithSeparator(tokenizer)) then 
      lineCount = lineCount + 1;
    end;
  end;
  do return lineCount end;
end
__tokenizers_LineTokenizer.tokenizeC = function(chars,includeSeparators) 
  do return __tokenizers_LineTokenizer.tokenizeD(chars, includeSeparators, true) end;
end
__tokenizers_LineTokenizer.tokenizeD = function(chars,includeSeparators,skipLastEmptyLine) 
  do return __tokenizers_LineTokenizer.tokenizeE(chars, 0, chars.length, includeSeparators, skipLastEmptyLine) end;
end
__tokenizers_LineTokenizer.tokenizeE = function(chars,startOffset,endOffset,includeSeparators,skipLastEmptyLine) 
  do return __tokenizers_LineTokenizer.tokenizeD(chars:splice(startOffset, startOffset + endOffset), includeSeparators, skipLastEmptyLine) end;
end
__tokenizers_LineTokenizer.stringEndsWithSeparator = function(tokenizer) 
  do return tokenizer:getLineSeparatorLength() > 0 end;
end
__tokenizers_LineTokenizer.tokenizeF = function(chars,startOffset,endOffset,includeSeparators) 
  do return __tokenizers_LineTokenizer.tokenizeE(chars, startOffset, endOffset, includeSeparators, true) end;
end
__tokenizers_LineTokenizer.prototype = _hx_e();
__tokenizers_LineTokenizer.prototype.myOffset= nil;
__tokenizers_LineTokenizer.prototype.myLength= nil;
__tokenizers_LineTokenizer.prototype.myLineSeparatorLength= nil;
__tokenizers_LineTokenizer.prototype.isAtEnd= nil;
__tokenizers_LineTokenizer.prototype.myText= nil;
__tokenizers_LineTokenizer.prototype.atEnd = function(self) 
  do return self.isAtEnd end
end
__tokenizers_LineTokenizer.prototype.getOffset = function(self) 
  do return self.myOffset end
end
__tokenizers_LineTokenizer.prototype.getLength = function(self) 
  do return self.myLength end
end
__tokenizers_LineTokenizer.prototype.getLineSeparatorLength = function(self) 
  do return self.myLineSeparatorLength end
end
__tokenizers_LineTokenizer.prototype.advance = function(self) 
  local i = (self.myOffset + self.myLength) + self.myLineSeparatorLength;
  local textLength = __lua_lib_luautf8_Utf8.len(self.myText);
  if (i >= textLength) then 
    self.isAtEnd = true;
    do return end;
  end;
  while (i < textLength) do _hx_do_first_1 = false;
    
    local c = __lua_lib_luautf8_Utf8.sub(self.myText, i + 1, i + 1);
    if ((c == "\r") or (c == "\n")) then 
      break;
    end;
    i = i + 1;
  end;
  local tmp = self;
  tmp.myOffset = tmp.myOffset + (self.myLength + self.myLineSeparatorLength);
  self.myLength = i - self.myOffset;
  self.myLineSeparatorLength = 0;
  if (i == textLength) then 
    do return end;
  end;
  local first = __lua_lib_luautf8_Utf8.sub(self.myText, i + 1, i + 1);
  if ((first == "\r") or (first == "\n")) then 
    self.myLineSeparatorLength = 1;
  end;
  i = i + 1;
  if (i == textLength) then 
    do return end;
  end;
  local second = __lua_lib_luautf8_Utf8.sub(self.myText, i + 1, i + 1);
  if ((first == "\r") and (second == "\n")) then 
    self.myLineSeparatorLength = 2;
  end;
end

__tokenizers_LineTokenizer.prototype.__class__ =  __tokenizers_LineTokenizer

__util__HashableString_HashableStringArray_Impl_.new = {}
__util__HashableString_HashableStringArray_Impl_.__name__ = "util._HashableString.HashableStringArray_Impl_"
__util__HashableString_HashableStringArray_Impl_.toHashable = function(this1) 
  do return this1 end;
end
__util__HashableString_HashableStringArray_Impl_.get = function(this1,index) 
  do return this1[index] end;
end

__util__HashableString_HashableString_Impl_.new = {}
__util__HashableString_HashableString_Impl_.__name__ = "util._HashableString.HashableString_Impl_"
__util__HashableString_HashableString_Impl_._new = function(s) 
  do return s end;
end
__util__HashableString_HashableString_Impl_.toHashable = function(this1) 
  do return this1 end;
end
__util__HashableString_HashableString_Impl_.hashCode = function(this1) 
  local hash = 7;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(this1);
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    hash = (hash * 31) + __lua_lib_luautf8_Utf8.byte(this1, i + 1);
  end;
  do return hash end;
end

__util_SafeBitSetAt.new = {}
__util_SafeBitSetAt.__name__ = "util.SafeBitSetAt"
__util_SafeBitSetAt.safeAt = function(bs,index) 
  if ((index < 0) or (index >= __thx__BitSet_BitSet_Impl_.get_length(bs))) then 
    do return false end;
  end;
  do return __thx__BitSet_BitSet_Impl_.at(bs, index) end;
end

__util_diff_Diff.new = {}
__util_diff_Diff.__name__ = "util.diff.Diff"
__util_diff_Diff.buildChangesB_diffB_T = function(objects1,objects2) 
  local startShift = __util_diff_Diff.getStartShiftA_buildChangesB_T(objects1, objects2);
  local endCut = __util_diff_Diff.getEndCutA_buildChangesB_T(objects1, objects2, startShift);
  local changeRef = __util_diff_Diff.doBuildChangesFast(objects1.length, objects2.length, startShift, endCut);
  if (changeRef ~= nil) then 
    do return changeRef:get() end;
  end;
  local trimmedLength = ((objects1.length + objects2.length) - (2 * startShift)) - (2 * endCut);
  local enumerator = __ds_Enumerator.new(trimmedLength);
  local Ints1 = enumerator:enumerateB(objects1, startShift, endCut);
  local Ints2 = enumerator:enumerateB(objects2, startShift, endCut);
  do return __util_diff_Diff.doBuildChanges(Ints1, Ints2, __util_diff_ChangeBuilder.new(startShift)) end;
end
__util_diff_Diff.buildChangesB_util_HashableType = function(objects1,objects2) 
  local startShift = __util_diff_Diff.getStartShiftA_buildChangesB_T(objects1, objects2);
  local endCut = __util_diff_Diff.getEndCutA_buildChangesB_T(objects1, objects2, startShift);
  local changeRef = __util_diff_Diff.doBuildChangesFast(objects1.length, objects2.length, startShift, endCut);
  if (changeRef ~= nil) then 
    do return changeRef:get() end;
  end;
  local trimmedLength = ((objects1.length + objects2.length) - (2 * startShift)) - (2 * endCut);
  local enumerator = __ds_Enumerator_util_HashableType.new(trimmedLength);
  local Ints1 = enumerator:enumerateB(objects1, startShift, endCut);
  local Ints2 = enumerator:enumerateB(objects2, startShift, endCut);
  do return __util_diff_Diff.doBuildChanges(Ints1, Ints2, __util_diff_ChangeBuilder.new(startShift)) end;
end
__util_diff_Diff.getEndCutA_buildChangesB_T = function(o1,o2,startShift) 
  local size = Std.int(Math.min(o1.length, o2.length) - startShift);
  local x = 2;
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local one = o1[(o1.length - i) - 1];
    local two = o2[(o2.length - i) - 1];
    if (one ~= two) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end;
end
__util_diff_Diff.getStartShiftA_buildChangesB_T = function(o1,o2) 
  local size = Std.int(Math.min(o1.length, o2.length));
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (o1[i] ~= o2[i]) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end;
end
__util_diff_Diff.getEndCutA_Int = function(o1,o2,startShift) 
  local size = Std.int(Math.min(o1.length, o2.length) - startShift);
  local x = 2;
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local one = o1[(o1.length - i) - 1];
    local two = o2[(o2.length - i) - 1];
    if (one ~= two) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end;
end
__util_diff_Diff.getStartShiftA_Int = function(o1,o2) 
  local size = Std.int(Math.min(o1.length, o2.length));
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (o1[i] ~= o2[i]) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end;
end
__util_diff_Diff.buildChangesX_diffX_T = function(objects1,objects2) 
  local startShift = __util_diff_Diff.getStartShiftX_buildChangesX_T(objects1, objects2);
  local endCut = __util_diff_Diff.getEndCutX(objects1, objects2, startShift);
  local changeRef = __util_diff_Diff.doBuildChangesFast(objects1.length, objects2.length, startShift, endCut);
  if (changeRef ~= nil) then 
    do return changeRef:get() end;
  end;
  local trimmedLength = ((objects1.length + objects2.length) - (2 * startShift)) - (2 * endCut);
  local enumerator = __ds_Enumerator.new(trimmedLength);
  local Ints1 = enumerator:enumerateB(objects1, startShift, endCut);
  local Ints2 = enumerator:enumerateB(objects2, startShift, endCut);
  do return __util_diff_Diff.doBuildChanges(Ints1, Ints2, __util_diff_ChangeBuilder.new(startShift)) end;
end
__util_diff_Diff.getStartShiftX_buildChangesX_T = function(o1,o2) 
  local size = Std.int(Math.min(o1.length, o2.length));
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local one = o1[i];
    local two = o2[i];
    if (not one:equals(two)) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end;
end
__util_diff_Diff.buildChangesA = function(before,after) 
  local hashableBefore = __util_diff_Diff.splitLines(before);
  local hashableAfter = __util_diff_Diff.splitLines(after);
  do return __util_diff_Diff.buildChangesB_util_HashableType(__util__HashableString_HashableStringArray_Impl_.toHashable(hashableBefore), __util__HashableString_HashableStringArray_Impl_.toHashable(hashableAfter)) end;
end
__util_diff_Diff.splitLines = function(s) 
  if (__lua_lib_luautf8_Utf8.len(s) == 0) then 
    do return _hx_tab_array({[0]=""}, 1) end;
  else
    do return __tokenizers_LineTokenizer.tokenizeB(s, false, false) end;
  end;
end
__util_diff_Diff.buildChangesC = function(array1,array2) 
  local startShift = __util_diff_Diff.getStartShiftA_Int(array1, array2);
  local endCut = __util_diff_Diff.getEndCutA_Int(array1, array2, startShift);
  local changeRef = __util_diff_Diff.doBuildChangesFast(array1.length, array2.length, startShift, endCut);
  if (changeRef ~= nil) then 
    do return changeRef:get() end;
  end;
  local copyArray = (startShift ~= 0) or (endCut ~= 0);
  local Ints1 = (function() 
    local _hx_1
    if (copyArray) then 
    _hx_1 = array1:slice(startShift, Std.int(array1.length - endCut)); else 
    _hx_1 = array1; end
    return _hx_1
  end )();
  local Ints2 = (function() 
    local _hx_2
    if (copyArray) then 
    _hx_2 = array2:slice(startShift, Std.int(array2.length - endCut)); else 
    _hx_2 = array2; end
    return _hx_2
  end )();
  do return __util_diff_Diff.doBuildChanges(Ints1, Ints2, __util_diff_ChangeBuilder.new(startShift)) end;
end
__util_diff_Diff.doBuildChangesFast = function(length1,length2,startShift,endCut) 
  local trimmedLength1 = (length1 - startShift) - endCut;
  local trimmedLength2 = (length2 - startShift) - endCut;
  if ((trimmedLength1 ~= 0) and (trimmedLength2 ~= 0)) then 
    do return nil end;
  end;
  local change = (function() 
    local _hx_1
    if ((trimmedLength1 ~= 0) or (trimmedLength2 ~= 0)) then 
    _hx_1 = __util_diff_Change.new(startShift, startShift, trimmedLength1, trimmedLength2, nil); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  do return __ds_Ref_util_diff_Change.new(change) end;
end
__util_diff_Diff.doBuildChanges = function(Ints1,Ints2,builder) 
  local reindexer = __util_diff_Reindexer.new();
  local discarded = reindexer:discardUnique(Ints1, Ints2);
  if ((discarded[0].length == 0) and (discarded[1].length == 0)) then 
    builder:addChange(Ints1.length, Ints2.length);
    do return builder:getFirstChange() end;
  end;
  local changes;
  if (__config_DiffConfig.USE_PATIENCE_ALG) then 
    local patienceIntLCS = __util_diff_PatienceIntLCS.new(discarded[0], discarded[1]);
    patienceIntLCS:executeA();
    changes = patienceIntLCS:getChanges();
  else
    local _hx_status, _hx_result = pcall(function() 
    
        local IntLCS = __util_diff_MyersLCS.new(discarded[0], discarded[1]);
        IntLCS:executeWithThreshold();
        changes = IntLCS:getChanges();
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
        local patienceIntLCS = __util_diff_PatienceIntLCS.new(discarded[0], discarded[1]);
        patienceIntLCS:executeB(true);
        changes = patienceIntLCS:getChanges();
        __haxe_Log.trace("Successful fallback to patience diff", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/util/diff/Diff.hx",lineNumber=132,className="util.diff.Diff",methodName="doBuildChanges"}));
      else
        _G.error(_g,0);
      end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
  reindexer:reindex(changes, builder);
  do return builder:getFirstChange() end;
end
__util_diff_Diff.getEndCutX = function(o1,o2,startShift) 
  local size = Std.int(Math.min(o1.length, o2.length) - startShift);
  local x = 2;
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local one = o1[(o1.length - i) - 1];
    local two = o2[(o2.length - i) - 1];
    if (not one:equals(two)) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end;
end
__util_diff_Diff.translateLineA = function(before,after,line,approximate) 
  local strings1 = __tokenizers_LineTokenizer.tokenizeA(before, false);
  local strings2 = __tokenizers_LineTokenizer.tokenizeA(after, false);
  if (approximate) then 
    strings1 = __util_diff_Diff.trim(strings1);
    strings2 = __util_diff_Diff.trim(strings2);
  end;
  local change = __util_diff_Diff.buildChangesB_util_HashableType(__util__HashableString_HashableStringArray_Impl_.toHashable(strings2), __util__HashableString_HashableStringArray_Impl_.toHashable(strings2));
  do return __util_diff_Diff.translateLineC(change, line, approximate) end;
end
__util_diff_Diff.trim = function(lines) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = lines.length;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push("");
  end;
  local result = _g;
  local _g = 0;
  local _g1 = lines.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    result[i] = StringTools.trim(lines[i]);
  end;
  do return result end;
end
__util_diff_Diff.translateLineB = function(change,line) 
  do return __util_diff_Diff.translateLineC(change, line, false) end;
end
__util_diff_Diff.translateLineC = function(change,line,approximate) 
  local result = line;
  local currentChange = change;
  while (currentChange ~= nil) do _hx_do_first_1 = false;
    
    if (line < currentChange.line0) then 
      break;
    end;
    if (line >= (currentChange.line0 + currentChange.deleted)) then 
      result = result + (currentChange.inserted - currentChange.deleted);
    else
      if (approximate) then 
        do return currentChange.line1 end;
      else
        do return -1 end;
      end;
    end;
    currentChange = currentChange.link;
  end;
  do return result end;
end
__util_diff_Diff.linesDiff = function(lines1,lines2) 
  local ch = __util_diff_Diff.buildChangesB_util_HashableType(__util__HashableString_HashableStringArray_Impl_.toHashable(lines1), __util__HashableString_HashableStringArray_Impl_.toHashable(lines2));
  if (ch == nil) then 
    do return nil end;
  end;
  local sb_b = ({});
  local sb_length = 0;
  while (ch ~= nil) do _hx_do_first_1 = false;
    
    if (sb_length ~= 0) then 
      local str = "====================";
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
      local str = "\n";
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local _g = ch.line0;
    local _g1 = ch.line0 + ch.deleted;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local str = "-";
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
      local str = Std.string(lines1[i]);
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
      local str = "\n";
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local _g = ch.line1;
    local _g1 = ch.line1 + ch.inserted;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local str = "+";
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
      local str = Std.string(lines2[i]);
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
      local str = "\n";
      _G.table.insert(sb_b, str);
      sb_length = sb_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    ch = ch.link;
  end;
  do return _G.table.concat(sb_b) end;
end

__util_diff_Change.new = function(line0,line1,deleted,inserted,old) 
  local self = _hx_new(__util_diff_Change.prototype)
  __util_diff_Change.super(self,line0,line1,deleted,inserted,old)
  return self
end
__util_diff_Change.super = function(self,line0,line1,deleted,inserted,old) 
  self.line0 = line0;
  self.line1 = line1;
  self.inserted = inserted;
  self.deleted = deleted;
  self.link = old;
end
__util_diff_Change.__name__ = "util.diff.Change"
__util_diff_Change.prototype = _hx_e();
__util_diff_Change.prototype.link= nil;
__util_diff_Change.prototype.inserted= nil;
__util_diff_Change.prototype.deleted= nil;
__util_diff_Change.prototype.line0= nil;
__util_diff_Change.prototype.line1= nil;
__util_diff_Change.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("change[") .. Std.string("inserted=")) .. Std.string(self.inserted)) .. Std.string(", deleted=")) .. Std.string(self.deleted)) .. Std.string(", line0=")) .. Std.string(self.line0)) .. Std.string(", line1=")) .. Std.string(self.line1)) .. Std.string("]") end
end
__util_diff_Change.prototype.toList = function(self) 
  local result = Array.new();
  local current = self;
  while (current ~= nil) do _hx_do_first_1 = false;
    
    result:push(current);
    current = current.link;
  end;
  do return result end
end

__util_diff_Change.prototype.__class__ =  __util_diff_Change

__util_diff_LCSBuilder.new = {}
__util_diff_LCSBuilder.__name__ = "util.diff.LCSBuilder"
__util_diff_LCSBuilder.prototype = _hx_e();
__util_diff_LCSBuilder.prototype.addEqual= nil;
__util_diff_LCSBuilder.prototype.addChange= nil;

__util_diff_LCSBuilder.prototype.__class__ =  __util_diff_LCSBuilder

__util_diff_ChangeBuilder.new = function(startShift) 
  local self = _hx_new(__util_diff_ChangeBuilder.prototype)
  __util_diff_ChangeBuilder.super(self,startShift)
  return self
end
__util_diff_ChangeBuilder.super = function(self,startShift) 
  self.myIndex2 = 0;
  self.myIndex1 = 0;
  self:skip(startShift, startShift);
end
__util_diff_ChangeBuilder.__name__ = "util.diff.ChangeBuilder"
__util_diff_ChangeBuilder.__interfaces__ = {__util_diff_LCSBuilder}
__util_diff_ChangeBuilder.prototype = _hx_e();
__util_diff_ChangeBuilder.prototype.myIndex1= nil;
__util_diff_ChangeBuilder.prototype.myIndex2= nil;
__util_diff_ChangeBuilder.prototype.myFirstChange= nil;
__util_diff_ChangeBuilder.prototype.myLastChange= nil;
__util_diff_ChangeBuilder.prototype.addChange = function(self,first,second) 
  local change = __util_diff_Change.new(self.myIndex1, self.myIndex2, first, second, nil);
  if (self.myLastChange ~= nil) then 
    self.myLastChange.link = change;
  else
    self.myFirstChange = change;
  end;
  self.myLastChange = change;
  self:skip(first, second);
end
__util_diff_ChangeBuilder.prototype.skip = function(self,first,second) 
  local tmp = self;
  tmp.myIndex1 = tmp.myIndex1 + first;
  local tmp = self;
  tmp.myIndex2 = tmp.myIndex2 + second;
end
__util_diff_ChangeBuilder.prototype.addEqual = function(self,length) 
  self:skip(length, length);
end
__util_diff_ChangeBuilder.prototype.getFirstChange = function(self) 
  do return self.myFirstChange end
end

__util_diff_ChangeBuilder.prototype.__class__ =  __util_diff_ChangeBuilder

__util_diff_FilesTooBigForDiffException.new = function(message,previous,native) 
  local self = _hx_new(__util_diff_FilesTooBigForDiffException.prototype)
  __util_diff_FilesTooBigForDiffException.super(self,message,previous,native)
  return self
end
__util_diff_FilesTooBigForDiffException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__util_diff_FilesTooBigForDiffException.__name__ = "util.diff.FilesTooBigForDiffException"
__util_diff_FilesTooBigForDiffException.prototype = _hx_e();

__util_diff_FilesTooBigForDiffException.prototype.__class__ =  __util_diff_FilesTooBigForDiffException
__util_diff_FilesTooBigForDiffException.__super__ = __haxe_Exception
setmetatable(__util_diff_FilesTooBigForDiffException.prototype,{__index=__haxe_Exception.prototype})

__util_diff_MyersLCS.new = function(first,second,start1,count1,start2,count2,changes1,changes2) 
  local self = _hx_new(__util_diff_MyersLCS.prototype)
  __util_diff_MyersLCS.super(self,first,second,start1,count1,start2,count2,changes1,changes2)
  return self
end
__util_diff_MyersLCS.super = function(self,first,second,start1,count1,start2,count2,changes1,changes2) 
  self.myFirst = first;
  self.mySecond = second;
  if ((((((start1 == nil) and (count1 == nil)) and (start2 == nil)) and (count2 == nil)) and (changes1 == nil)) and (changes2 == nil)) then 
    self.myStart1 = 0;
    self.myStart2 = 0;
    self.myCount1 = first.length;
    self.myCount2 = second.length;
    local length = first.length;
    local this1 = _hx_tab_array({[0]=length}, 1);
    local size = Std.int(length / 32) + 1;
    __thx_Arrays.resize(this1, size + 1, 0);
    self.myChanges1 = this1;
    local length = second.length;
    local this1 = _hx_tab_array({[0]=length}, 1);
    local size = Std.int(length / 32) + 1;
    __thx_Arrays.resize(this1, size + 1, 0);
    self.myChanges2 = this1;
  else
    self.myStart1 = start1;
    self.myStart2 = start2;
    self.myCount1 = count1;
    self.myCount2 = count2;
    self.myChanges1 = changes1;
    self.myChanges2 = changes2;
  end;
  local _g = self.myStart1;
  local _g1 = self.myStart1 + self.myCount1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(self.myChanges1, i, true);
  end;
  local _g = self.myStart2;
  local _g1 = self.myStart2 + self.myCount2;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(self.myChanges2, i, true);
  end;
  local totalSequenceLength = self.myCount1 + self.myCount2;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = totalSequenceLength + 1;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  self.VForward = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = totalSequenceLength + 1;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  self.VBackward = _g;
end
__util_diff_MyersLCS.__name__ = "util.diff.MyersLCS"
__util_diff_MyersLCS.prototype = _hx_e();
__util_diff_MyersLCS.prototype.myFirst= nil;
__util_diff_MyersLCS.prototype.mySecond= nil;
__util_diff_MyersLCS.prototype.myStart1= nil;
__util_diff_MyersLCS.prototype.myStart2= nil;
__util_diff_MyersLCS.prototype.myCount1= nil;
__util_diff_MyersLCS.prototype.myCount2= nil;
__util_diff_MyersLCS.prototype.myChanges1= nil;
__util_diff_MyersLCS.prototype.myChanges2= nil;
__util_diff_MyersLCS.prototype.VForward= nil;
__util_diff_MyersLCS.prototype.VBackward= nil;
__util_diff_MyersLCS.prototype.executeLinear = function(self) 
  local _hx_status, _hx_result = pcall(function() 
  
      local threshold = 20000 + (10 * Std.int(_G.math.sqrt(self.myCount1 + self.myCount2)));
      self:executeB(threshold, false);
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
      _G.error(__exceptions_IllegalStateException.new(""),0);
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__util_diff_MyersLCS.prototype.executeA = function(self) 
  local _hx_status, _hx_result = pcall(function() 
  
      self:executeB(self.myCount1 + self.myCount2, false);
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g), __util_diff_FilesTooBigForDiffException)) then 
      _G.error(__exceptions_IllegalStateException.new(""),0);
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__util_diff_MyersLCS.prototype.executeWithThreshold = function(self) 
  local threshold = Std.int(Math.max(20000 + (10 * _G.math.sqrt(self.myCount1 + self.myCount2)), __config_DiffConfig.DELTA_THRESHOLD_SIZE));
  self:executeB(threshold, true);
end
__util_diff_MyersLCS.prototype.executeB = function(self,threshold,throwException) 
  if ((self.myCount1 == 0) or (self.myCount2 == 0)) then 
    do return end;
  end;
  self:executeC(0, self.myCount1, 0, self.myCount2, Std.int(Math.min(threshold, self.myCount1 + self.myCount2)), throwException);
end
__util_diff_MyersLCS.prototype.executeC = function(self,oldStart,oldEnd,newStart,newEnd,differenceEstimate,throwException) 
  if ((oldStart < oldEnd) and (newStart < newEnd)) then 
    local oldLength = oldEnd - oldStart;
    local newLength = newEnd - newStart;
    self.VForward[newLength + 1] = 0;
    self.VBackward[newLength + 1] = 0;
    local halfD = Std.int((differenceEstimate + 1) / 2);
    local td = -1;
    local kk = td;
    local xx = kk;
    local _g = 0;
    local _g1 = halfD + 1;
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local d = _g - 1;
      local L = newLength + Std.int(Math.max(-d, -newLength + (_hx_bit.band((_hx_bit.bxor(d,newLength)),1))));
      local R = newLength + Std.int(Math.min(d, oldLength - (_hx_bit.band((_hx_bit.bxor(d,oldLength)),1))));
      local k = __iterators_StepIterator.new(L, R, 2, true);
      while (k:hasNext()) do _hx_do_first_2 = false;
        
        local k = k:next();
        local x = (function() 
          local _hx_1
          if ((k == L) or ((k ~= R) and (self.VForward[k - 1] < self.VForward[k + 1]))) then 
          _hx_1 = self.VForward[k + 1]; else 
          _hx_1 = self.VForward[k - 1] + 1; end
          return _hx_1
        end )();
        local y = (x - k) + newLength;
        x = x + self:commonSubsequenceLengthForward(oldStart + x, newStart + y, Std.int(Math.min((oldEnd - oldStart) - x, (newEnd - newStart) - y)));
        self.VForward[k] = x;
      end;
      if ((_G.math.fmod((oldLength - newLength), 2)) ~= 0) then 
        local b = false;
        local k = __iterators_StepIterator.new(L, R, 2, true);
        while (k:hasNext()) do _hx_do_first_2 = false;
          
          local k = k:next();
          if (((oldLength - (d - 1)) <= k) and (k <= (oldLength + (d - 1)))) then 
            if ((self.VForward[k] + self.VBackward[(newLength + oldLength) - k]) >= oldLength) then 
              xx = self.VForward[k];
              kk = k;
              td = (2 * d) - 1;
              b = true;
              break;
            end;
          end;
        end;
        if (b) then 
          break;
        end;
      end;
      local k = __iterators_StepIterator.new(L, R, 2, true);
      while (k:hasNext()) do _hx_do_first_2 = false;
        
        local k = k:next();
        local x = (function() 
          local _hx_2
          if ((k == L) or ((k ~= R) and (self.VBackward[k - 1] < self.VBackward[k + 1]))) then 
          _hx_2 = self.VBackward[k + 1]; else 
          _hx_2 = self.VBackward[k - 1] + 1; end
          return _hx_2
        end )();
        local y = (x - k) + newLength;
        x = x + self:commonSubsequenceLengthBackward((oldEnd - 1) - x, (newEnd - 1) - y, Std.int(Math.min((oldEnd - oldStart) - x, (newEnd - newStart) - y)));
        self.VBackward[k] = x;
      end;
      if ((_G.math.fmod((oldLength - newLength), 2)) == 0) then 
        local b = false;
        local k = __iterators_StepIterator.new(L, R, 2, true);
        while (k:hasNext()) do _hx_do_first_2 = false;
          
          local k = k:next();
          if (((oldLength - d) <= k) and (k <= (oldLength + d))) then 
            if ((self.VForward[(oldLength + newLength) - k] + self.VBackward[k]) >= oldLength) then 
              xx = oldLength - self.VBackward[k];
              kk = (oldLength + newLength) - k;
              td = 2 * d;
              b = true;
              break;
            end;
          end;
        end;
        if (b) then 
          break;
        end;
      end;
    end;
    if (td > 1) then 
      local yy = (xx - kk) + newLength;
      local oldDiff = Std.int((td + 1) / 2);
      if ((0 < xx) and (0 < yy)) then 
        self:executeC(oldStart, oldStart + xx, newStart, newStart + yy, oldDiff, throwException);
      end;
      if (((oldStart + xx) < oldEnd) and ((newStart + yy) < newEnd)) then 
        self:executeC(oldStart + xx, oldEnd, newStart + yy, newEnd, td - oldDiff, throwException);
      end;
    else
      if (td >= 0) then 
        local x = oldStart;
        local y = newStart;
        while ((x < oldEnd) and (y < newEnd)) do _hx_do_first_1 = false;
          
          local commonLength = self:commonSubsequenceLengthForward(x, y, Std.int(Math.min(oldEnd - x, newEnd - y)));
          if (commonLength > 0) then 
            self:addUnchanged(x, y, commonLength);
            x = x + commonLength;
            y = y + commonLength;
          else
            if ((oldEnd - oldStart) > (newEnd - newStart)) then 
              x = x + 1;
            else
              y = y + 1;
            end;
          end;
        end;
      else
        if (throwException) then 
          _G.error(__util_diff_FilesTooBigForDiffException.new(""),0);
        end;
      end;
    end;
  end;
end
__util_diff_MyersLCS.prototype.addUnchanged = function(self,start1,start2,count) 
  local _g = self.myStart1 + start1;
  local _g1 = (self.myStart1 + start1) + count;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(self.myChanges1, i, false);
  end;
  local _g = self.myStart2 + start2;
  local _g1 = (self.myStart2 + start2) + count;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(self.myChanges2, i, false);
  end;
end
__util_diff_MyersLCS.prototype.commonSubsequenceLengthForward = function(self,oldIndex,newIndex,maxLength) 
  local x = oldIndex;
  local y = newIndex;
  maxLength = Std.int(Math.min(maxLength, Math.min(self.myCount1 - oldIndex, self.myCount2 - newIndex)));
  while (((x - oldIndex) < maxLength) and (self.myFirst[self.myStart1 + x] == self.mySecond[self.myStart2 + y])) do _hx_do_first_1 = false;
    
    x = x + 1;
    y = y + 1;
  end;
  do return x - oldIndex end
end
__util_diff_MyersLCS.prototype.commonSubsequenceLengthBackward = function(self,oldIndex,newIndex,maxLength) 
  local x = oldIndex;
  local y = newIndex;
  maxLength = Std.int(Math.min(maxLength, Math.min(oldIndex, newIndex) + 1));
  while (((oldIndex - x) < maxLength) and (self.myFirst[self.myStart1 + x] == self.mySecond[self.myStart2 + y])) do _hx_do_first_1 = false;
    
    x = x - 1;
    y = y - 1;
  end;
  do return oldIndex - x end
end
__util_diff_MyersLCS.prototype.getChanges = function(self) 
  do return _hx_tab_array({[0]=self.myChanges1, self.myChanges2}, 2) end
end

__util_diff_MyersLCS.prototype.__class__ =  __util_diff_MyersLCS

__util_diff_PatienceIntLCS.new = function(first,second,start1,count1,start2,count2,changes1,changes2) 
  local self = _hx_new(__util_diff_PatienceIntLCS.prototype)
  __util_diff_PatienceIntLCS.super(self,first,second,start1,count1,start2,count2,changes1,changes2)
  return self
end
__util_diff_PatienceIntLCS.super = function(self,first,second,start1,count1,start2,count2,changes1,changes2) 
  self.myFirst = first;
  self.mySecond = second;
  if ((((((start1 == nil) and (count1 == nil)) and (start2 == nil)) and (count2 == nil)) and (changes1 == nil)) and (changes2 == nil)) then 
    self.myStart1 = 0;
    self.myStart2 = first.length;
    self.myCount1 = 0;
    self.myCount2 = second.length;
    local length = first.length;
    local this1 = _hx_tab_array({[0]=length}, 1);
    local size = Std.int(length / 32) + 1;
    __thx_Arrays.resize(this1, size + 1, 0);
    self.myChanges1 = this1;
    local length = second.length;
    local this1 = _hx_tab_array({[0]=length}, 1);
    local size = Std.int(length / 32) + 1;
    __thx_Arrays.resize(this1, size + 1, 0);
    self.myChanges2 = this1;
    do return end;
  end;
  self.myStart1 = start1;
  self.myStart2 = start2;
  self.myCount1 = count1;
  self.myCount2 = count2;
  self.myChanges1 = changes1;
  self.myChanges2 = changes2;
end
__util_diff_PatienceIntLCS.__name__ = "util.diff.PatienceIntLCS"
__util_diff_PatienceIntLCS.prototype = _hx_e();
__util_diff_PatienceIntLCS.prototype.myFirst= nil;
__util_diff_PatienceIntLCS.prototype.mySecond= nil;
__util_diff_PatienceIntLCS.prototype.myStart1= nil;
__util_diff_PatienceIntLCS.prototype.myStart2= nil;
__util_diff_PatienceIntLCS.prototype.myCount1= nil;
__util_diff_PatienceIntLCS.prototype.myCount2= nil;
__util_diff_PatienceIntLCS.prototype.myChanges1= nil;
__util_diff_PatienceIntLCS.prototype.myChanges2= nil;
__util_diff_PatienceIntLCS.prototype.executeA = function(self) 
  self:executeB(false);
end
__util_diff_PatienceIntLCS.prototype.executeB = function(self,failOnSmallReduction) 
  local thresholdCheckCounter = (function() 
    local _hx_1
    if (failOnSmallReduction) then 
    _hx_1 = 2; else 
    _hx_1 = -1; end
    return _hx_1
  end )();
  self:executeC(self.myStart1, self.myCount1, self.myStart2, self.myCount2, thresholdCheckCounter);
end
__util_diff_PatienceIntLCS.prototype.executeC = function(self,start1,count1,start2,count2,thresholdCheckCounter) 
  if ((count1 == 0) and (count2 == 0)) then 
    do return end;
  end;
  if ((count1 == 0) or (count2 == 0)) then 
    self:addChange(start1, count1, start2, count2);
    do return end;
  end;
  local startOffset = self:matchForward(start1, count1, start2, count2);
  start1 = start1 + startOffset;
  start2 = start2 + startOffset;
  count1 = count1 - startOffset;
  count2 = count2 - startOffset;
  local endOffset = self:matchBackward(start1, count1, start2, count2);
  count1 = count1 - endOffset;
  count2 = count2 - endOffset;
  if ((count1 == 0) or (count2 == 0)) then 
    self:addChange(start1, count1, start2, count2);
  else
    if (thresholdCheckCounter == 0) then 
      self:checkReduction(count1, count2);
    end;
    thresholdCheckCounter = Std.int(Math.max(-1, thresholdCheckCounter - 1));
    local uniqueLCS = __util_diff_UniqueLCS.new(self.myFirst, self.mySecond, start1, count1, start2, count2);
    local matching = uniqueLCS:execute();
    if (matching == nil) then 
      if (thresholdCheckCounter >= 0) then 
        self:checkReduction(count1, count2);
      end;
      local intLCS = __util_diff_MyersLCS.new(self.myFirst, self.mySecond, start1, count1, start2, count2, self.myChanges1, self.myChanges2);
      intLCS:executeLinear();
    else
      local s1;
      local s2;
      local matched = matching[0].length;
      local c1 = matching[0][0];
      local c2 = matching[1][0];
      self:executeC(start1, c1, start2, c2, thresholdCheckCounter);
      local _g = 1;
      local _g1 = matching[0].length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        s1 = matching[0][i - 1] + 1;
        s2 = matching[1][i - 1] + 1;
        c1 = matching[0][i] - s1;
        c2 = matching[1][i] - s2;
        if ((c1 > 0) or (c2 > 0)) then 
          self:executeC(start1 + s1, c1, start2 + s2, c2, thresholdCheckCounter);
        end;
      end;
      if (matching[0][matched - 1] == (count1 - 1)) then 
        s1 = count1 - 1;
        c1 = 0;
      else
        s1 = matching[0][matched - 1] + 1;
        c1 = count1 - s1;
      end;
      if (matching[1][matched - 1] == (count2 - 1)) then 
        s2 = count2 - 1;
        c2 = 0;
      else
        s2 = matching[1][matched - 1] + 1;
        c2 = count2 - s2;
      end;
      self:executeC(start1 + s1, c1, start2 + s2, c2, thresholdCheckCounter);
    end;
  end;
end
__util_diff_PatienceIntLCS.prototype.matchForward = function(self,start1,count1,start2,count2) 
  local size = Std.int(Math.min(count1, count2));
  local idx = 0;
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self.myFirst[start1 + i] ~= self.mySecond[start2 + i]) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end
end
__util_diff_PatienceIntLCS.prototype.matchBackward = function(self,start1,count1,start2,count2) 
  local size = Std.int(Math.min(count1, count2));
  local idx = 0;
  local _g = 1;
  local _g1 = size;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self.myFirst[(start1 + count1) - i] ~= self.mySecond[(start2 + count2) - i]) then 
      break;
    end;
    idx = idx + 1;
  end;
  do return idx end
end
__util_diff_PatienceIntLCS.prototype.addChange = function(self,start1,count1,start2,count2) 
  local _g = self.myStart1;
  local _g1 = self.myStart1 + count1;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(self.myChanges1, i, true);
  end;
  local _g = self.myStart2;
  local _g1 = self.myStart2 + count2;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(self.myChanges2, i, true);
  end;
end
__util_diff_PatienceIntLCS.prototype.getChanges = function(self) 
  do return _hx_tab_array({[0]=self.myChanges1, self.myChanges2}, 2) end
end
__util_diff_PatienceIntLCS.prototype.checkReduction = function(self,count1,count2) 
  if ((count1 * 2) < self.myCount1) then 
    do return end;
  end;
  if ((count2 * 2) < self.myCount2) then 
    do return end;
  end;
  _G.error(__util_diff_FilesTooBigForDiffException.new(""),0);
end

__util_diff_PatienceIntLCS.prototype.__class__ =  __util_diff_PatienceIntLCS

__util_diff_Reindexer.new = function() 
  local self = _hx_new(__util_diff_Reindexer.prototype)
  __util_diff_Reindexer.super(self)
  return self
end
__util_diff_Reindexer.super = function(self) 
  self.myDiscardedLengths = _hx_tab_array({[0]=-1, -1}, 2);
  self.myOriginalLengths = _hx_tab_array({[0]=-1, -1}, 2);
  local _g = _hx_tab_array({}, 0);
  _g:push(Array.new());
  _g:push(Array.new());
  self.myOldIndices = _g;
end
__util_diff_Reindexer.__name__ = "util.diff.Reindexer"
__util_diff_Reindexer.createSorted = function(Ints1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = Ints1;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local sorted1 = _g;
  sorted1:sort(function(a,b) 
    do return a - b end;
  end);
  do return sorted1 end;
end
__util_diff_Reindexer.getOriginal = function(indexes,i) 
  do return indexes[i] end;
end
__util_diff_Reindexer.increment = function(indexes,i,set,length) 
  if ((i + 1) < indexes.length) then 
    __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(set, indexes[i] + 1, indexes[i + 1]);
  else
    __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(set, indexes[i] + 1, length);
  end;
  do return i + 1 end;
end
__util_diff_Reindexer.prototype = _hx_e();
__util_diff_Reindexer.prototype.myOldIndices= nil;
__util_diff_Reindexer.prototype.myOriginalLengths= nil;
__util_diff_Reindexer.prototype.myDiscardedLengths= nil;
__util_diff_Reindexer.prototype.discardUnique = function(self,Ints1,Ints2) 
  local discarded1 = self:discard(Ints2, Ints1, 0);
  do return _hx_tab_array({[0]=discarded1, self:discard(discarded1, Ints2, 1)}, 2) end
end
__util_diff_Reindexer.prototype.discard = function(self,needed,toDiscard,arrayIndex) 
  self.myOriginalLengths[arrayIndex] = toDiscard.length;
  local sorted1 = __util_diff_Reindexer.createSorted(needed);
  local discarded = _hx_tab_array({}, 0);
  local oldIndices = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = toDiscard.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local index = toDiscard[i];
    if (__util_diff__Reindexer_Reindexer_Fields_.binarySearch(sorted1, index) >= 0) then 
      discarded:push(index);
      oldIndices:push(i);
    end;
  end;
  self.myOldIndices[arrayIndex] = oldIndices;
  self.myDiscardedLengths[arrayIndex] = discarded.length;
  do return discarded end
end
__util_diff_Reindexer.prototype.reindex = function(self,discardedChanges,builder) 
  local changes1;
  local changes2;
  if ((self.myDiscardedLengths[0] == self.myOriginalLengths[0]) and (self.myDiscardedLengths[1] == self.myOriginalLengths[1])) then 
    changes1 = discardedChanges[0];
    changes2 = discardedChanges[1];
  else
    local length = self.myOriginalLengths[0];
    local this1 = _hx_tab_array({[0]=length}, 1);
    local size = Std.int(length / 32) + 1;
    __thx_Arrays.resize(this1, size + 1, 0);
    changes1 = this1;
    local length = self.myOriginalLengths[1];
    local this1 = _hx_tab_array({[0]=length}, 1);
    local size = Std.int(length / 32) + 1;
    __thx_Arrays.resize(this1, size + 1, 0);
    changes2 = this1;
    local x = 0;
    local y = 0;
    while ((x < self.myDiscardedLengths[0]) or (y < self.myDiscardedLengths[1])) do _hx_do_first_1 = false;
      
      if ((((x < self.myDiscardedLengths[0]) and (y < self.myDiscardedLengths[1])) and not __util_SafeBitSetAt.safeAt(discardedChanges[0], x)) and not __util_SafeBitSetAt.safeAt(discardedChanges[1], y)) then 
        x = __util_diff_Reindexer.increment(self.myOldIndices[0], x, changes1, self.myOriginalLengths[0]);
        y = __util_diff_Reindexer.increment(self.myOldIndices[1], y, changes2, self.myOriginalLengths[1]);
      else
        if (__util_SafeBitSetAt.safeAt(discardedChanges[0], x)) then 
          __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(changes1, __util_diff_Reindexer.getOriginal(self.myOldIndices[0], x));
          x = __util_diff_Reindexer.increment(self.myOldIndices[0], x, changes1, self.myOriginalLengths[0]);
        else
          if (__util_SafeBitSetAt.safeAt(discardedChanges[1], y)) then 
            __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(changes2, __util_diff_Reindexer.getOriginal(self.myOldIndices[1], y));
            y = __util_diff_Reindexer.increment(self.myOldIndices[1], y, changes2, self.myOriginalLengths[1]);
          end;
        end;
      end;
    end;
    if (self.myDiscardedLengths[0] == 0) then 
      __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(changes1, 0, self.myOriginalLengths[0]);
    else
      __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(changes1, 0, self.myOldIndices[0][0]);
    end;
    if (self.myDiscardedLengths[1] == 0) then 
      __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(changes2, 0, self.myOriginalLengths[1]);
    else
      __util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween(changes2, 0, self.myOldIndices[1][0]);
    end;
  end;
  local x = 0;
  local y = 0;
  while ((x < self.myOriginalLengths[0]) and (y < self.myOriginalLengths[1])) do _hx_do_first_1 = false;
    
    local startX = x;
    while ((((x < self.myOriginalLengths[0]) and (y < self.myOriginalLengths[1])) and not __thx__BitSet_BitSet_Impl_.at(changes1, x)) and not __thx__BitSet_BitSet_Impl_.at(changes2, y)) do _hx_do_first_2 = false;
      
      x = x + 1;
      y = y + 1;
    end;
    if (x > startX) then 
      builder:addEqual(x - startX);
    end;
    local dx = 0;
    local dy = 0;
    while ((x < self.myOriginalLengths[0]) and __thx__BitSet_BitSet_Impl_.at(changes1, x)) do _hx_do_first_2 = false;
      
      dx = dx + 1;
      x = x + 1;
    end;
    while ((y < self.myOriginalLengths[1]) and __thx__BitSet_BitSet_Impl_.at(changes2, y)) do _hx_do_first_2 = false;
      
      dy = dy + 1;
      y = y + 1;
    end;
    if ((dx ~= 0) or (dy ~= 0)) then 
      builder:addChange(dx, dy);
    end;
  end;
  if ((x ~= self.myOriginalLengths[0]) or (y ~= self.myOriginalLengths[1])) then 
    builder:addChange(self.myOriginalLengths[0] - x, self.myOriginalLengths[1] - y);
  end;
end

__util_diff_Reindexer.prototype.__class__ =  __util_diff_Reindexer

__util_diff__Reindexer_Reindexer_Fields_.new = {}
__util_diff__Reindexer_Reindexer_Fields_.__name__ = "util.diff._Reindexer.Reindexer_Fields_"
__util_diff__Reindexer_Reindexer_Fields_.binarySearch = function(sequence,val) 
  do return __util_diff__UniqueLCS_UniqueLCS_Fields_.binarySearchImpl(sequence, 0, sequence.length, val) end;
end
__util_diff__Reindexer_Reindexer_Fields_.bitSetSetBetween = function(bitset,start,_end,value) 
  local setValue = (function() 
    local _hx_1
    if (value == nil) then 
    _hx_1 = true; else 
    _hx_1 = value; end
    return _hx_1
  end )();
  local endIndex = (function() 
    local _hx_2
    if (_end == nil) then 
    _hx_2 = __thx__BitSet_BitSet_Impl_.get_length(bitset); else 
    _hx_2 = _end; end
    return _hx_2
  end )();
  local _g = start;
  local _g1 = endIndex;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    __thx__BitSet_BitSet_Impl_.setAt(bitset, i, setValue);
  end;
end

__util_diff_UniqueLCS.new = function(first,second,start1,count1,start2,count2) 
  local self = _hx_new(__util_diff_UniqueLCS.prototype)
  __util_diff_UniqueLCS.super(self,first,second,start1,count1,start2,count2)
  return self
end
__util_diff_UniqueLCS.super = function(self,first,second,start1,count1,start2,count2) 
  self.myFirst = first;
  self.mySecond = second;
  if ((((start1 == nil) and (count1 == nil)) and (start2 == nil)) and (count2 == nil)) then 
    self.myStart1 = 0;
    self.myStart2 = first.length;
    self.myCount1 = 0;
    self.myCount2 = second.length;
    do return end;
  end;
  self.myStart1 = start1;
  self.myStart2 = start2;
  self.myCount1 = count1;
  self.myCount2 = count2;
end
__util_diff_UniqueLCS.__name__ = "util.diff.UniqueLCS"
__util_diff_UniqueLCS.binarySearch = function(sequence,val,length) 
  local i = __util_diff__UniqueLCS_UniqueLCS_Fields_.binarySearchImpl(sequence, 0, length, val);
  do return -i - 1 end;
end
__util_diff_UniqueLCS.prototype = _hx_e();
__util_diff_UniqueLCS.prototype.myFirst= nil;
__util_diff_UniqueLCS.prototype.mySecond= nil;
__util_diff_UniqueLCS.prototype.myStart1= nil;
__util_diff_UniqueLCS.prototype.myStart2= nil;
__util_diff_UniqueLCS.prototype.myCount1= nil;
__util_diff_UniqueLCS.prototype.myCount2= nil;
__util_diff_UniqueLCS.prototype.execute = function(self) 
  local map_h = ({});
  local match = Array.new();
  local _g = 0;
  local _g1 = self.myCount1;
  local _hx_continue_1 = false;
  while (_g < _g1) do _hx_do_first_1 = false;
    repeat 
    _g = _g + 1;
    local i = _g - 1;
    local index = self.myStart1 + i;
    local ret = map_h[self.myFirst[index]];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local val = ret;
    if (val == -1) then 
      break;
    end;
    if (val == 0) then 
      local key = self.myFirst[index];
      local value = i + 1;
      if (value == nil) then 
        map_h[key] = __haxe_ds_IntMap.tnull;
      else
        map_h[key] = value;
      end;
    else
      local key = self.myFirst[index];
      map_h[key] = -1;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local count = 0;
  local _g = 0;
  local _g1 = self.myCount2;
  local _hx_continue_1 = false;
  while (_g < _g1) do _hx_do_first_1 = false;
    repeat 
    _g = _g + 1;
    local i = _g - 1;
    local index = self.myStart2 + i;
    local ret = map_h[self.mySecond[index]];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local val = ret;
    if ((val == 0) or (val == -1)) then 
      break;
    end;
    if (match[val - 1] == 0) then 
      match[val - 1] = i + 1;
      count = count + 1;
    else
      match[val - 1] = 0;
      local key = self.mySecond[index];
      map_h[key] = -1;
      count = count - 1;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (count == 0) then 
    do return nil end;
  end;
  local sequence = Array.new();
  local lastElement = Array.new();
  local predecessor = Array.new();
  local length = 0;
  local _g = 0;
  local _g1 = self.myCount1;
  local _hx_continue_1 = false;
  while (_g < _g1) do _hx_do_first_1 = false;
    repeat 
    _g = _g + 1;
    local i = _g - 1;
    if (match[i] == 0) then 
      break;
    end;
    local j = __util_diff_UniqueLCS.binarySearch(sequence, match[i], length);
    if ((j == length) or (match[i] < sequence[j])) then 
      sequence[j] = match[i];
      lastElement[j] = i;
      predecessor[i] = (function() 
        local _hx_1
        if (j > 0) then 
        _hx_1 = lastElement[j - 1]; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
      if (j == length) then 
        length = length + 1;
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = length;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  local ret = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = length;
  while (_g1 < _g2) do _hx_do_first_1 = false;
    
    _g1 = _g1 + 1;
    local _ = _g1 - 1;
    _g:push(0);
  end;
  local ret = _hx_tab_array({[0]=ret, _g}, 2);
  local i = length - 1;
  local curr = lastElement[length - 1];
  while (curr ~= -1) do _hx_do_first_1 = false;
    
    ret[0][i] = curr;
    ret[1][i] = match[curr] - 1;
    i = i - 1;
    curr = predecessor[curr];
  end;
  do return ret end
end

__util_diff_UniqueLCS.prototype.__class__ =  __util_diff_UniqueLCS

__util_diff__UniqueLCS_UniqueLCS_Fields_.new = {}
__util_diff__UniqueLCS_UniqueLCS_Fields_.__name__ = "util.diff._UniqueLCS.UniqueLCS_Fields_"
__util_diff__UniqueLCS_UniqueLCS_Fields_.binarySearchImpl = function(a,fromIndex,toIndex,key) 
  local low = fromIndex;
  local high = toIndex - 1;
  while (low <= high) do _hx_do_first_1 = false;
    
    local mid = _hx_bit.rshift(low + high,1);
    local midVal = a[mid];
    if (midVal < key) then 
      low = mid + 1;
    else
      if (midVal > key) then 
        high = mid - 1;
      else
        do return mid end;
      end;
    end;
  end;
  do return -(low + 1) end;
end
local hasBit32, bit32 = pcall(require, 'bit32')
if hasBit32 then --if we are on Lua 5.1, bit32 will be the default.
  _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw })
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end
else
  --If we do not have bit32, fallback to 'bit'
  local hasBit, bit = pcall(require, 'bit')
  if not hasBit then
    error("Failed to load bit or bit32")
  end
  _hx_bit_raw = bit
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw })
end

-- see https://github.com/HaxeFoundation/haxe/issues/8849
_hx_bit.bor = function(...) return _hx_bit_clamp(_hx_bit_raw.bor(...)) end
_hx_bit.band = function(...) return _hx_bit_clamp(_hx_bit_raw.band(...)) end
_hx_bit.arshift = function(...) return _hx_bit_clamp(_hx_bit_raw.arshift(...)) end

if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

if package.loaded.luv then
  _hx_luv = _G.require("luv");
else
  _hx_luv = {
    run=function(mode) return false end,
    loop_alive=function() return false end
  }
end
local _hx_static_init = function()
  
  if (__lua_lib_lrexlib_Rex == nil) then 
    _G.error(__haxe_Exception.thrown("Rex is missing.  Please install lrexlib-pcre2."),0);
  end;
  String.__name__ = "String";
  Array.__name__ = "Array";DateTools.DAYS_OF_MONTH = _hx_tab_array({[0]=31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, 12);
  
  EReg.FLAGS = __lua_lib_lrexlib_Rex.flags();
  
  __config_DiffConfig.USE_PATIENCE_ALG = false;
  
  __config_DiffConfig.USE_GREEDY_MERGE_MAGIC_RESOLVE = false;
  
  __config_DiffConfig.DELTA_THRESHOLD_SIZE = 20000;
  
  __config_DiffConfig.MAX_BAD_LINES = 3;
  
  __config_DiffConfig.UNIMPORTANT_LINE_CHAR_COUNT = 3;
  
  __diff_comparison_iterables_DiffIterableUtil.SHOULD_VERIFY_ITERABLE = false;
  
  __ds_Pair.__meta__ = _hx_o({__fields__={statics=true},statics=_hx_o({__fields__={createNonNull=true,pair=true},createNonNull=_hx_o({__fields__={NotNull=true},NotNull=nil}),pair=_hx_o({__fields__={NotNull=true},NotNull=nil})})});
  
  __ds_TextRange.EMPTY_RANGE = __ds_TextRange.new(0, 0);
  
  __ds_TextRange.EMPTY_ARRAY = _hx_tab_array({}, 0);
  
  __haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  __haxe_ds_IntMap.tnull = ({});
  
  __haxe_ds_StringMap.tnull = ({});
  
  __thx__BitSet_BitSet_Impl_.blockSize = 32;
  
  __thx_Dates.order = __thx__Ord_Ord_Impl_.fromIntComparison(__thx_Dates.compare);
  
  __thx_Floats.TOLERANCE = 10e-5;
  
  __thx_Floats.EPSILON = 1e-9;
  
  __thx_Floats.pattern_parse = EReg.new("^(\\+|-)?(:?\\d+(\\.\\d+)?(e-?\\d+)?|nan|NaN|NAN)$", "");
  
  __thx_Floats.pattern_inf = EReg.new("^\\+?(inf|Inf|INF)$", "");
  
  __thx_Floats.pattern_neg_inf = EReg.new("^-(inf|Inf|INF)$", "");
  
  __thx_Floats.order = __thx__Ord_Ord_Impl_.fromIntComparison(__thx_Floats.compare);
  
  __thx_Floats.monoid = _hx_o({__fields__={zero=true,append=true},zero=0.0,append=function(self,a,b) 
    do return a + b end;
  end});
  
  __thx_Ints.pattern_parse = EReg.new("^[ \t\r\n]*[+-]?(\\d+|0x[0-9A-F]+)", "i");
  
  __thx_Ints.BASE = "0123456789abcdefghijklmnopqrstuvwxyz";
  
  __thx_Ints.order = function(i0,i1) 
    if (i0 > i1) then 
      do return __thx_OrderingImpl.GT end;
    else
      if (i0 == i1) then 
        do return __thx_OrderingImpl.EQ end;
      else
        do return __thx_OrderingImpl.LT end;
      end;
    end;
  end;
  
  __thx_Ints.monoid = _hx_o({__fields__={zero=true,append=true},zero=0,append=function(self,a,b) 
    do return a + b end;
  end});
  
  __thx_Orderings.monoid = _hx_o({__fields__={zero=true,append=true},zero=__thx_OrderingImpl.EQ,append=function(self,o0,o1) 
    local tmp = o0[1];
    if (tmp) == 0 then 
      do return __thx_OrderingImpl.LT end;
    elseif (tmp) == 1 then 
      do return __thx_OrderingImpl.GT end;
    elseif (tmp) == 2 then 
      do return o1 end; end;
  end});
  
  __thx_Strings.order = __thx__Ord_Ord_Impl_.fromIntComparison(__thx_Strings.compare);
  
  __thx_Strings.HASCODE_MAX = 2147483647;
  
  __thx_Strings.HASCODE_MUL = 31;
  
  __thx_Strings.monoid = _hx_o({__fields__={zero=true,append=true},zero="",append=function(self,a,b) 
    do return Std.string(a) .. Std.string(b) end;
  end});
  
  __thx_Strings.UCWORDS = EReg.new("[^a-zA-Z]([a-z])", "g");
  
  __thx_Strings.IS_BREAKINGWHITESPACE = EReg.new("[^\t\n\r ]", "");
  
  __thx_Strings.IS_ALPHA = EReg.new("[^a-zA-Z]", "");
  
  __thx_Strings.UCWORDSWS = EReg.new("[ \t\r\n][a-z]", "g");
  
  __thx_Strings.ALPHANUM = EReg.new("^[a-z0-9]+$", "i");
  
  __thx_Strings.DIGITS = EReg.new("^[0-9]+$", "");
  
  __thx_Strings.STRIPTAGS = EReg.new("</?[a-z]+[^>]*>", "gi");
  
  __thx_Strings.WSG = EReg.new("[ \t\r\n]+", "g");
  
  __thx_Strings.SPLIT_LINES = EReg.new("\r\n|\n\r|\n|\r", "g");
  
  __thx_Strings.CANONICALIZE_LINES = EReg.new("\r\n|\n\r|\r", "g");
  
  __thx_fp__Map_Map_Impl_.delta = 5;
  
  __thx_fp__Map_Map_Impl_.ratio = 2;
  
  
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

_G.math.randomseed(_G.os.time());

_hx_print = print or (function() end)

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

function _hx_handle_error(obj)
  local message = tostring(obj)
  if _G.debug and _G.debug.traceback then
    -- level 2 to skip _hx_handle_error
    message = _G.debug.traceback(message, 2)
  end
  return setmetatable({}, { __tostring = function() return message end })
end

_hx_static_init();
local success, err = _G.xpcall(function() 
  Main.main();
  _hx_luv.run();
end, _hx_handle_error)
if not success then _G.error(err) end
return _hx_exports
